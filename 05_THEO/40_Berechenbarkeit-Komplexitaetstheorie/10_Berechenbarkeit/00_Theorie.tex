\documentclass{lehramt-informatik-haupt}
\liLadePakete{mathe}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Theorie-Teil
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Berechbarkeitstheorie}

\begin{liQuellen}
\item \cite[Seite 253-340]{hoffmann}
\end{liQuellen}

\subsection{Berechenbarkeitsmodelle}

%%
%
%%

% Info_2021-05-07-2021-05-07_09.32.08.mp4 1h

\subsubsection{Loop-berechenbar}

\begin{liQuellen}
\item \cite[Seite 7-11]{theo:fs:4}
\item \cite[Seite 254-260]{hoffmann}
\item \cite{wiki:loop}
\end{liQuellen}

\paragraph{LOOP-Sprache (einfache Programme)}

\begin{itemize}
\item endlicher Aufbau
\item Variablen aus den natürlichen Zahlen
\end{itemize}

\begin{description}
\item[Programmelemente:] \strut

\begin{description}
\item[Konstante:]
$0$ (andere Kostanten müssen aus den anderen Element )

\item[Variablen:]
$x_0, x_1, x_2, \dots, x_n$

\item[Operator:]

$succ$ (Successor), $pred$ (Sredecessor), $:=$ (Wertzuweisen), $;$ (Anweisungtrenner)

\item[Schleife:]

$loop \dots do \dots end$ (nach dem loop Schlüsselwort steht genau eine
Variable, die dekrementiert wird. Ist 0 erreicht, stop die Schleife)
\end{description}

\item[Speichervektor v:] \strut

\begin{itemize}
\item endlich, aber beliebig lang
\item Speicherung der Variablen des Programms
\item $(x_0, x_1, x_2, \dots, x_n)$
\item Erste Stelle des Vektors ist für das Speichern des Ergebnisses vorgesehen.
\end{itemize}

\item[Übergangsfunktion $\delta(v, P)$:] \strut

\begin{description}
\item[Eingabe:] Speichervektor $v$ und Programm $P$
\item[Ausgabe:] Speichervektor $v'$
\end{description}

nach Programmausführung von $P$

\item[Makro] \strut

Es gibt die Möglichkeit sogenannte Makros zu definieren.
\end{description}

%%
%
%%

% Info_2021-05-07-2021-05-07_09.32.08.mp4 2h

\subsubsection{While-Programme}

\begin{liQuellen}
\item \cite[Seite 7-12]{theo:fs:4}
\item \cite[Seite 260-264]{hoffmann}
\item \cite{wiki:while}
\end{liQuellen}

\begin{itemize}
\item endlicher Aufbau
\item Variablen aus den natürlichen Zahlen
\end{itemize}

\begin{description}
\item[Programmelemente:] \strut

\begin{description}
\item[Konstante:]
$0$ (andere Kostanten müssen aus den anderen Element )

\item[Variablen:]
$x_0, x_1, x_2, \dots, x_n$

\item[Operator:]

$succ$ (Successor), $pred$ (Predecessor), $:=$ (Wertzuweisen), $;$ (Anweisungtrenner)

\item[Schleife:]

 $loop \dots do \dots end$(nach dem $loop$ Schlüsselwort steht genau eine
Variable, die dekrementiert wird. Ist 0 erreicht, stop die Schleife)

\item[Schleife:]

$while \dots do \dots end$
(nach dem $while$ Schlüsselwort steht eine Bedingung. $while$-Schleife
kann nicht terminieren.)
\end{description}

\item[Speichervektor v:] \strut

\begin{itemize}
\item endlich, aber beliebig lang
\item Speicherung der Variablen des Programms
\item $(x_0, x_1, x_2, \dots, x_n)$
 \end{itemize}

\item[Übergangsfunktion $\delta(v, P)$:] \strut

\begin{description}
\item[Eingabe:] Speichervektor $v$ und Programm $P$
\item[Ausgabe:] Speichervektor $v'$
\end{description}

nach Programmausführung von $P$
\begin{equation*}
\delta(v, \text{while }x_i\text{ do }P)
\begin{cases}
\bot & \text{falls }T_i = \emptyset\\
\delta(v, P^{\text{min}T_i}) & \text{falls }T_i \neq \emptyset\\
\end{cases}
\end{equation*}
\end{description}

Mit $f : \mathbb{N}^n \rightarrow \mathbb{N}$ sei eine partielle
Funktion über den natürlichen Zahlen gegeben. $f$ heißt
While-berechenbar, falls ein While-Programm $P$ mit den folgenden
Eigenschaften existiert:

Satz von Kleene:

Jede WHILE-berechenbare Funktion lässt sich als WHILE-Programm mit nur
einer WHILE-Schleife realisieren.\footcite[Seite 13]{theo:fs:4}

\subsection{Weitere Berechnungsmodelle}

\begin{itemize}
\item GOTO
\item primitive und μ-Rekursion

\item Turing-Maschinen
\begin{itemize}
\item Einband-TM
\item Mehrband-TM
\item Universelle-TM

\end{itemize}
\item Registermaschinen
\item lambda-Kalkül\footcite[Seite 17]{theo:fs:4}
\end{itemize}

\section{Universelle Turingmaschine}

% Info_2021-05-07-2021-05-07_09.32.08.mp4 2h47min

Eine Turing-Maschine $U$ heißt universell, wenn sie eine andere
Turing-Maschine $T$ simulieren (ausführen) kann.\footcite[Seite
23]{theo:fs:4}

\begin{equation*}
\delta((0,x_1,x_2,\dots,x_n,0,\dots), P) =
\begin{cases}
\bot &
\text{falls } f(x_1,x_2,\dots,x_n) = \bot\\

(f(x_1,x_2,\dots,x_n), \dots) &
\text{falls }f(x_1,x_2,\dots,x_n) \neq \bot\\
\end{cases}
\end{equation*}\footcite[Seite 261]{hoffmann}

\subsection{Gödelisierung:}

Für jeden Eintrag der Übergangstabelle wird eine Binärzahl erzeugt.
Startzustand, Eingabesymbol, Folgesymbol, Ausgabesymbol und Richtung
werden als Einserketten unär kodiert mit Null als Trennzeichen Nach dem
gleichen Schema werden die erstellten Bitsequenzen zu einer großen
Binärzahl verschmolzen. Die erzeugte Zahl heißt die \memph{Gödelnummer}
der TM $T$. Die Kodierung wird als \memph{Gödelisierung} bezeichnet.
\footcite[Seite 23]{theo:fs:4}

\subsection{Church‘sche These}
\footcite{wiki:church-these}

Die Klasse der turing-berechenbaren Funktionen stimmt mit der
Klasse der intuitiv berechenbaren Funktionen überein.

Der Begriff der intuitiv berechenbaren Funktion bedarf an dieser Stelle
besonderer Aufmerksamkeit. Er bezeichnet eine Funktion, die von einem
Menschen – in welcher Form auch immer – ausgerechnet werden kann. Damit
besagt die Church’sche These nichts anderes, als dass je- de Funktion,
die überhaupt in irgendeiner Weise berechenbar ist, auch durch eine
Turing-Maschine berechnet werden kann. Die Church’sche These ist kein
Satz im mathematisch präzisen Sinne, da der Begriff der intuitiv
berechenbaren Funktion keine formale Definition besitzt. Gäbe es
diese, so hätten wir uns – bewusst oder unbewusst – bereits auf ein
konkretes Berechnungsmodell festgelegt und die eigentliche Bedeutung
dieses Begriffs ad absurdum geführt. Folgerichtig wird es niemals
möglich sein, die Church’sche These zu beweisen. Wir können lediglich
Indizien für ihre Gültigkeit sammeln und genau dies ist Forschern in der
Vergangenheit vielfach gelungen.
\footcite[Seite 308]{hoffmann}

Intuitiv-berechenbar:
Funktionen, die von einem Menschen berechnet werden können.

Church‘sche These kann nicht bewiesen werden!
\footcite[Seite 27]{theo:fs:4}
\literatur

\end{document}
