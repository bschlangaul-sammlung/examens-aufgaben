\documentclass{lehramt-informatik-haupt}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Theorie-Teil
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Berechbarkeitstheorie}

\begin{liQuellen}
\item \cite[Seite 253-340]{hoffmann}
\end{liQuellen}

\subsection{Berechenbarkeitsmodelle}

%%
%
%%

% Info_2021-05-07-2021-05-07_09.32.08.mp4 1h

\subsubsection{Loop-berechenbar}

\begin{liQuellen}
\item \cite[Seite 7-11]{theo:fs:4}
\item \cite[Seite 254-260]{hoffmann}
\item \cite{wiki:loop}
\end{liQuellen}

\paragraph{LOOP-Sprache (einfache Programme)}

\begin{itemize}
\item endlicher Aufbau
\item Variablen aus den natürlichen Zahlen
\end{itemize}

\begin{description}
\item[Programmelemente:] \strut

\begin{description}
\item[Konstante:]
$0$ (andere Kostanten müssen aus den anderen Element )

\item[Variablen:]
$x_0, x_1, x_2, \dots, x_n$

\item[Operator:]

$succ$ (Successor), $pred$ (Sredecessor), $:=$ (Wertzuweisen), $;$ (Anweisungtrenner)

\item[Schleife:]

$loop \dots do \dots end$ (nach dem loop Schlüsselwort steht genau eine
Variable, die dekrementiert wird. Ist 0 erreicht, stop die Schleife)
\end{description}

\item[Speichervektor v:] \strut

\begin{itemize}
\item endlich, aber beliebig lang
\item Speicherung der Variablen des Programms
\item $(x_0, x_1, x_2, \dots, x_n)$
\item Erste Stelle des Vektors ist für das Speichern des Ergebnisses vorgesehen.
\end{itemize}

\item[Übergangsfunktion $\delta(v, P)$:] \strut

\begin{description}
\item[Eingabe:] Speichervektor $v$ und Programm $P$
\item[Ausgabe:] Speichervektor $v'$
\end{description}

nach Programmausführung von $P$

\item[Makro] \strut

Es gibt die Möglichkeit sogenannte Makros zu definieren.
\end{description}
%%
%
%%

\subsubsection{While-Programme}

\begin{liQuellen}
\item \cite[Seite 7-12]{theo:fs:4}
\item \cite[Seite 260-264]{hoffmann}
\item \cite{wiki:while}
\end{liQuellen}

\subsection{Weitere Berechnungsmodelle}

\begin{itemize}
\item GOTO
\item primitive und μ-Rekursion

\item Turing-Maschinen
\begin{itemize}
\item Einband-TM
\item Mehrband-TM
\item Universelle-TM

\end{itemize}
\item Registermaschinen
\item lambda-Kalkül\footcite[Seite 17]{theo:fs:4}
\end{itemize}

\section{Universelle Turingmaschine}

% Info_2021-05-07-2021-05-07_09.32.08.mp4 2h47min

Eine Turing-Maschine $U$ heißt universell, wenn sie eine andere
Turing-Maschine $T$ simulieren (ausführen) kann.\footcite[Seite 23]{theo:fs:4}

\subsection{Gödelisierung:}

Für jeden Eintrag der Übergangstabelle wird eine Binärzahl erzeugt.
Startzustand, Eingabesymbol, Folgesymbol, Ausgabesymbol und Richtung
werden als Einserketten unär kodiert mit Null als Trennzeichen Nach dem
gleichen Schema werden die erstellten Bitsequenzen zu einer großen
Binärzahl verschmolzen. Die erzeugte Zahl heißt die \memph{Gödelnummer}
der TM $T$. Die Kodierung wird als \memph{Gödelisierung} bezeichnet.
\footcite[Seite 23]{theo:fs:4}

\literatur

\end{document}
