\documentclass{lehramt-informatik-haupt}
\liLadePakete{mathe}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Theorie-Teil
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Info_2021-06-11-2021-06-11_09.38.05.mp4

\chapter{Komplexitätstheorie}

%%
%
%%

\section{Komplexitätstheorie}

\memph{Komplexität} bezeichnet die „Kompliziertheit“ von Problemen,
Algorithmen und Daten.
%
Die \memph{Komplexitätstheorie} befasst sich dabei mit dem
Ressourcenverbrauch von Algorithmen.
%
Die betrachteten Ressourcen sind fast immer die Anzahl der
benötigten Rechenschritte (\memph{Zeitkomplexität}) oder der
Speicherbedarf (\memph{Platzkomplexität}).
%
Algorithmen und Probleme werden in der Komplexitätstheorie gemäß ihrer
so bestimmten Komplexität in so genannte \memph{Komplexitätsklassen}
eingeteilt. Diese sind ein wichtiges Werkzeug, um bestimmen zu können,
welche Probleme \emph{„gleich schwierig“} sind.
\footcite[Seite 58]{theo:fs:4}

\section{Komplexitätsklassen}

\begin{description}
% 3min
\item[P]
enthält alle Probleme, für die eine \memph{deterministische}
Turingmaschine in \memph{polynomieller} Zeit eine Lösung berechnen kann.
\footcite[Seite 59]{theo:fs:4}

\item[NP]
% 5min
enthält alle Probleme, für die eine \memph{nicht-deterministische} (=
NP) Turingmaschine in \memph{polynomieller} Zeit eine Lösung berechnen
kann.
\footcite[Seite 60]{theo:fs:4}

\begin{description}
% 11min
\item[NP-schwer] (engl. NP-hard) ist eine Eigenschaft eines
algorithmischen Problems. Ein NP-schweres Problem ist dabei mindestens
genauso „schwer“ wie alle Probleme in NP. Das bedeutet, dass ein
Algorithmus, der ein NP-schweres Problem löst, mithilfe einer
\memph{Reduktion} benutzt werden kann, um alle Probleme in NP zu
lösen.\footcite{wiki:np-schwer}

\item[NP-vollständig] sind die Probleme, die in NP liegen
und NP-schwer sind.\footcite{wiki:np-vollstaendig}
\end{description}
\end{description}

% 7min
\section{Millennium-Problem P=NP}

Das \texttt{P=NP}-Problem gilt als eines der großen offenen Probleme in
der Informatik. Es wird angenommen, dass es nicht gilt. Was würde es
bedeuten, wenn wir \texttt{P=NP} zeigen könnten? Fast alle
kryptographischen Sicherheitsalgorithmen wie Verschlüsselungen usw.
wären knackbar. Es ergäben sich immense Optimierungsmöglichkeiten bei
verschiedenen Problemen.

In dem Moment, wo für ein NP-vollständiges Problem ein deterministischer
Algorithmus in Polynomialzeit gefunden wird, sind alle Probleme in
\texttt{NP} auch in \texttt{P} und damit \texttt{P=NP}.
\footcite[Seite 61]{theo:fs:4}

% 14min
\section{Problemreduktion}

Um die Schwere von Problemen zu vergleichen, werden in der theoretischen
Informatik Problemreduktionen benutzt: Ein \memph{Problem $A$ heißt
reduzierbar} auf ein anderes Problem $B$, wenn jeder Algorithmus, der
\memph{B löst, auch verwendet werden kann, um $A$ zu lösen}, indem man
eine \memph{Probleminstanz von $A$ umrechnet in eine Instanz von $B$}
und diese anschließend löst. Sei $L' \subseteq \Sigma$ eine formale
Sprache. $L'$ heißt dann NP-schwer, wenn gilt:

\begin{displaymath}
\forall L \in \text{NP} \, \colon \, L \leq_p L'
\end{displaymath}

(Alle $L$ aus NP sind polynomiell reduzierbar auf $L'$.) Dies bedeutet,
dass $L'$ mindestens so schwer wie jedes beliebige Problem aus NP ist.
Es gibt einen Algorithmus $A$, der $L'$ in Polynomialzeit löst, für
jedes Problem aus NP ebenfalls ein polynomialer Algorithmus konstruieren
ließe:

\begin{itemize}
\item führe zuerst die Reduktion auf $L'$ aus und
\item anschließend Algorithmus $A$.
\end{itemize}

$L'$ selbst kann jedoch auch schwerer sein. Insbesondere muss $L'$ nicht
notwendigerweise in NP liegen (liegt $L'$ jedoch zusätzlich in NP, so
heißt $L'$ NP- vollständig).\footcite[Seite 63]{theo:fs:4}

% 31min
\section {Polynomialzeitreduktion}

Eine Polynomialzeitreduktion (auch polynomielle Reduktion) ist eine
spezielle Form der Reduktion in der theoretischen Informatik.
Zusätzlich zur Reduzierbarkeit wird hier gefordert, dass die
Reduktion deterministisch in Polynomialzeit berechnet werden kann.

$L_1$ heißt polynomiell reduzierbar auf $L_2$ ($L_1 \leq_p L_2$ ), wenn es
eine total, berechenbare Funktion $f = \Sigma^* \rightarrow \Sigma^*$
gibt, so dass gilt:
$w \in L_1 \Leftrightarrow f(w) \in L_2$
Es gibt
eine deterministische Turingmaschine $M$, die $f$ in Polynomialzeit
berechnet. => $L_2$ ist „mindestens genauso schwer“ wie $L_1$.
\footcite[Seite 64]{theo:fs:4}

% 36min
Was muss gezeigt werden:

\begin{itemize}
\item Es gibt eine Funktion, die Instanzen von $L_1$ auf Instanzen von
$L_2$ „umbaut“.

\item Die Funktion ist total.

\item Die Funktion arbeitet in Polynomialzeit.

\item Korrektheit der Reduktion: $w \in L_1 \Leftrightarrow f(w) \in
L_2$\footcite[Seite 65]{theo:fs:4}
\end{itemize}

% i e 66115:2016:03 1 5

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

% 1min7min

\subsection{Satz von Cook}

Stephen A. Cook zeigte, dass eine \memph{Teilmenge der Klasse NP
existiert}, auf die sich alle \memph{Probleme aus NP reduzieren} lassen.
Diese Teilmenge ist damit repräsentativ für die Schwierigkeit von NP und
wird als NP-vollständig (englisch: NP complete) bezeichnet. Der nach ihm
benannte Satz von Cook sagt aus, dass das \memph{Erfüllbarkeitsproblem
der Aussagenlogik} (SAT, v. engl. satisfiability) NP-vollständig ist.

Es ist allerdings nicht das einzige schwerste Problem, denn Richard M.
Karp zeigte, dass es in NP Probleme gibt, auf die SAT reduziert werden
können, die also \memph{genauso schwer sind wie SAT}.
\footcite[Seite 70]{theo:fs:4}

% 1h11min
\subsection{SAT und k-SAT}

SAT und k-SAT mit $k \geq 3$, $k \in \mathbb{N}$ (Satz von Cook)

Das Problem fragt, ob eine aussagenlogische Formel erfüllbar ist. Das
Erfüllbarkeitsproblem der \memph{Aussagenlogik} ist in exponentieller
Zeit in Abhängigkeit der Anzahl der Variablen mit Hilfe einer
Wahrheitstabelle entscheidbar. Diese \memph{Wahrheitstabelle} kann nicht
in polynomieller Zeit aufgestellt werden.
\footcite[Seite 71]{theo:fs:4}

\section{Karps 21 NP-vollständige Probleme}

Nachdem Stephen Cook 1971 den Nachweis erbrachte, dass SAT
NP-vollständig ist, griff Richard Karp 1972 diese Idee auf und zeigte
die NP-Vollständigkeit für 21 weitere Probleme. Diese werden als
klassische NP-vollständige Probleme bezeichnet.\footcite{wiki:karps-21}

Seit 1972 wurden mehr als 10000 Probleme als NP-vollständig
charakterisiert.
\footcite[Seite 80]{theo:fs:4}

\section{Aussagenlogische Formeln}

\begin{description}
\item[Negation:]

$\neg A$

\item[Disjunktion:]

Verknüpfung mit Oder $\lor$
$A \lor B$

\item[Konjunktion:]

Verknüpfung mit Und $\land$
$A \land B$

\item[Konjunktive Normalform:]
Konjunktion von Disjunktionstermen
$(A \lor B) \land D \land (A \lor B \lor C)$
\end{description}

3-SAT => höchstens drei Literale (also Variablen) pro Klausel
Aber beliebig viele verschiedene Variablen: $x_1, x_2, x_3, x_4, \dots$
Klausel ist ein Disjunktionsterm (=Oder-Term)

Beispiel:

$F = (\neg x_1 \lor x_2 \lor x_3 ) \land (x_2 \lor \neg x_3 \lor x_4 )
\land (x_1 \lor \neg x$
\footcite[Seite 72]{theo:fs:4}
%%
%
%%

% 1h20min
\subsection{Problem des Handlungsreisenden}

(TSP: engl. traveling salesman problem, Optimierungsproblem der
Kombinatorik): Die Aufgabe besteht darin, eine Reihenfolge für den
Besuch mehrerer Orte so zu wählen, dass keine Station außer der ersten
mehr als einmal besucht wird, die gesamte Reisestrecke des
Handlungsreisenden möglichst kurz und die

erste Station gleich der letzten Station ist. Eingabe: Ungerichteter
Graph mit Längen als Beschriftungen für Kanten

Ausgabe: Kürzeste Tour, auf der alle Knoten

genau einmal vorkommen\footcite[Seite 73]{theo:fs:4}

%%
%
%%

% 1h22min
\subsection{Hamiltonkreisproblem}

Existiert ein geschlossener Pfad in einem Graphen, der jeden Knoten nur
genau einmal enthält?

Wichtiges Problem der Graphentheorie Ist eine Verallgemeinerung des TSP,
bei welchem nur nach dem kürzesten Hamiltonkreis in einem Graphen
gefragt wird.

%%
%
%%

\subsection{Teilsummenproblem}

(auch Untermengensummenproblem, SSP engl. subset sum problem)

Gegeben sei eine Menge von ganzen Zahlen $M = \{z_1 , z_2 , \dots, z_n
\}$. Gesucht ist eine Untermenge, deren Elementsumme maximal, aber nicht
größer als eine gegebene obere Schranke c ist (oft ist auch gefragt, die
Schranke c exakt zu erreichen). Es ist ein spezielles Rucksackproblem.
\footcite[Seite 74]{theo:fs:4}

%%
%
%%

% 1h24min
\subsection{Rucksackproblem}

(auch englisch knapsack problem) ist ein Optimierungsproblem der
Kombinatorik.

Aus einer Menge von Objekten, die jeweils ein Gewicht und einen Nutzwert
haben, soll eine \memph{Teilmenge ausgewählt} werden, deren
Gesamtgewicht eine vorgegebene \memph{Gewichtsschranke nicht
überschreitet}. Unter dieser Bedingung soll der \memph{Nutzwert} der
ausgewählten Objekte \memph{maximiert} werden.
\footcite[Seite 75]{theo:fs:4}

%%
%
%%

% 1h25min
\subsection{Cliquenproblem}

(CLIQUE) fragt nach der Existenz einer Clique der Mindestgröße $n$ in
einem gegebenen Graphen.

Eine Clique ist eine Teilmenge von Knoten in einem ungerichteten
Graphen, bei der \memph{jedes Knotenpaar durch eine Kante verbunden ist}
(informell: jeder mit jedem innerhalb des Teilgraphen)

Beispiel: In dem nebenstehenden Graphen wird mit der Brute-Force-Methode
nach einer 4er-Clique gesucht.
\footcite[Seite 76]{theo:fs:4}

%%
%
%%

% 1h26min
\subsection{Stabilitätsproblem}

(Independent Set oder Co-Clique) fragt nach der Existenz einer Teilmenge
von Knoten in einem gegebenen Graphen der Mindestgröße $n$, bei denen
die Knoten zueinander \memph{nicht adjazent} (= keine direkte
Verbindung) sind.

Das Stabilitätsproblem ist das „Gegenproblem“ zum Cliquenproblem

Beispiel: Die neun blauen Knoten bilden im nebenstehenden Graphen eine
(maximale) stabile Menge.\footcite[Seite 77]{theo:fs:4}

%%
%
%%

\subsection{Knotenüberdeckungsproblem}

(VERTEX COVER) fragt, ob zu einem gegebenen einfachen Graphen und einer
natürlichen Zahl k eine Knotenüberdeckung der Größe von höchstens $k$
existiert.

Das heißt, ob es eine aus maximal $k$ Knoten bestehende Teilmenge $U$
der Knotenmenge gibt, so dass \memph{jede Kante des Graphen mit
mindestens einem Knoten aus $U$} verbunden ist.\footcite[Seite
78]{theo:fs:4}

Beispiele: Zwei nicht minimale Überdeckungen.

%%
%
%%

% 1h29min
\subsection{COL und k-COL}

COL und k-COL mit $k \geq 3$, $k \in \mathbb{N}$ (graph coloring –
Färbung eines Graphen) fragt, ob ein gegebener Graph mit $k$ Farben so
färbbar ist, dass zwei benachbarte Knoten niemals die gleiche Farben
haben.

\literatur

\end{document}
