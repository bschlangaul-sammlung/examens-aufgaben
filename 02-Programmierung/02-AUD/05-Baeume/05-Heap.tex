\documentclass{lehramt-informatik-haupt}
\usepackage{tabularx}
\usepackage{float}
\InformatikPakete{baum,mathe}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Theorie-Teil
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Halden}

\begin{quellen}
\item \cite[Seite 25-32]{aud:fs:tafeluebung-11}
\item \cite{wiki:heap}
\item \cite[Seite 407-409 (PDF 423-425), Kapitel 14.6.1]{saake}
\end{quellen}

Min-Heap: \url{https://www.cs.usfca.edu/~galles/visualization/Heap.html}
Max-Heap: \url{https://visualgo.net/en/heap}
Max-Heap: \url{http://btv.melezinek.cz/binary-search-tree.html}

\noindent
Ein Heap (englisch wörtlich: \memph{Haufen} oder \memph{Halde}) ist
eine auf Bäumen basierende \memph{abstrakte} und
\memph{dynamische} Datenstruktur.
%
Der Begriff Heap wird häufig als bedeutungsgleich zu einem
\memph{partiell geordneten Binärbaum} verstanden.
\footcite{wiki:heap}

Die Datenstruktur Heap bezeichnet einen binären Baum, der folgende
Eigenschaften erfüllt:\footcite[Seite 407 (PDF 423), Kapitel 14.6.1]{saake}

\begin{itemize}
\item Der Baum ist vollständig, d.h., die Blattebene ist von links nach
rechts gefüllt.

\item Der Schlüssel eines jeden Knotens ist kleiner (oder gleich) als
die Schlüssel seiner Kinder. Diese partielle Ordnung wird auch als
Heap-Eigenschaft bezeichnet.
\end{itemize}

%
Es gibt zwei unterschiedlichen Arten von Halden, nämlich:

\begin{itemize}
\item ein \memph{Max-Heap}. Hier ist die Wurzel jedes Teilbaums ist das
\memph{Maximum} aller Knoten des Teilbaums.
%
\item eine \memph{Min-Heap}: Die Wurzel jedes Teilbaums ist das
\memph{Minimum} aller Knoten des Teilbaums.
\end{itemize}
%
\memph{Duplikate} sind in einem Heap \memph{erlaubt}.
%
Heaps erlauben einen schnellen Zugriff auf das \memph{größte} bzw.
\memph{kleinste} Element. Sie werden deshalb als
\memph{Prioritätswarteschlange} verwendent.
%
Heaps können als „klassischer“ Binärbaum implementiert werden. Eine
effiziente Speicherung ist in einem \memph{Array} möglich.
\footcite[Seite 22]{aud:fs:tafeluebung-11}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Links-Vollständigkeit}

Oft (nicht immer) verstehen wir unter Heaps links-vollständige Bäume:
d.\,h. alle „Ebenen“ (bis auf die unterste) sind \memph{voll besetzt}
und auf unterster „Ebene“ sitzen alle Knoten \memph{soweit links wie
möglich}. Dadurch ist eine \memph{lückenlose Darstellung} in einem
\memph{Array} möglich (sog. Feld-Einbettung). Nicht nur Halden können
linksvollständig sein, sondern jeder beliebige Baum.

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\subsection{Berechnung der Indizes}

\begin{compactitem}
\item \emph{Wurzel} steht an Position $0$

\item \emph{Kinder} von Knoten an Position $i$ stehen an Stelle
$2 \cdot i + 1$ und $2 \cdot i + 2$

\item \emph{Elternknoten} von Knoten an Position $i$ steht an Stelle
$\frac{i - 1}{2}$
\footcite[Seite 26]{aud:fs:tafeluebung-11}
\end{compactitem}

\begin{center}
\begin{tikzpicture}[binaerer baum]
\Tree
[.1
  [.12
    [.15
      [.24 ]
      [.18 ]
    ]
    [.13
      [.17 ]
      [.19 ]
    ]
  ]
  [.2
    [.5
      [.28 ]
      \edge[blank]; \node[blank]{};
    ]
    [.42 ]
  ]
]
\end{tikzpicture}
\end{center}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Operationen}

%%
%
%%

\subsection{Einfügen eines neuen Elements}

Ein neues Element wird an die nächste freie Position in der untersten
Ebene einfügt. Falls die Ebene voll ist, wird das neue Element erster
Knoten einer neuen Ebene. Solange die Halden-Eigenschaft in einem
Teilbaum verletzt ist, lassen wir das neue Element entsprechend der
Halden-Eigenschaft nach oben wandern.

%%
%
%%

\subsection{Löschen eines Elements}

Wir ersetzen das zu löschende Element mit dem letzten Element der
untersten Ebene.
%
Solange die Halden-Eigenschaft in einem Teilbaum verletzt ist, lassen
wir das neue Element entsprechend der Halden-Eigenschaft nach unten.
%
Bei einer Min-Heap wird mit dem kleineren Kind getauscht, bei einer
Max-Heap mit dem größeren Kind.
\footcite[Seite 28]{aud:fs:tafeluebung-11}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Aufgaben
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Aufgaben}

\section{Zeichnen der Heap
\footcite[Seite 4, Aufgabe 7: Heap (H 2012 (66115) - T2, A7, a/ii)]{aud:ab:7}}

Fügen Sie nacheinander die Zahlen \texttt{3}, \texttt{5}, \texttt{1},
\texttt{2}, \texttt{4} in einen leeren Heap ein. Geben Sie die
Ergebnisse an (Zeichnung).

\begin{figure}[H]
\begin{minipage}[t][5cm][b]{0.32\linewidth}
\begin{tikzpicture}[binaerer baum]
\Tree
[.\node(3){3};
      [.\node(5){5}; ]
      \edge[blank]; \node[blank]{};
]
\draw[dotted,<->] (3) .. controls +(west:1) .. (5);
\end{tikzpicture}
\caption{Erstellen einer Max.-Halde, einfügen von 3 und 5, Versickern notwendig
}
\end{minipage}
%
\begin{minipage}[t][5cm][b]{0.32\linewidth}
\begin{tikzpicture}[binaerer baum]
\Tree
[.5
  [.\node(3){3};
    [.2 ]
    [.\node(4){4}; ]
  ]
  [.1 ]
]
\draw[dotted,<->] (3) .. controls +(east:0.5) .. (4);
\end{tikzpicture}
\caption{Einfügen von 1 und 2 ohne Änderungen, Einfügen von 4, versickern notwendig}
\end{minipage}
%
\begin{minipage}[t][5cm][b]{0.32\linewidth}
\begin{tikzpicture}[binaerer baum]
\Tree
[.5
  [.4
    [.2 ]
    [.3 ]
  ]
  [.1 ]
]
\end{tikzpicture}
\caption{Fertiger Heap}
\end{minipage}
\end{figure}

\literatur

\end{document}
