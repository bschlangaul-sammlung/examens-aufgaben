\documentclass{lehramt-informatik-haupt}
\liLadePakete{syntax,uml,mathe}

\usepackage{tikz-cd}
\usepackage{tabularx}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Theorie-Teil
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Listen}

\begin{quellen}
\cite[Kapitel 6.2.1.2, Seite 180-181]{schneider}
\cite[Kapitel 13.2 Verkettete Listen Seite 323-330 (PDF 339-346)]{saake}
\cite[Kapitel 13.3 Doppelt verkette Liste, Seite 323-330 (PDF 339-346)]{saake}

\end{quellen}

Eine Liste ist eine Zusammenfassung von Daten gleicher Struktur. Listen
sind aus mehreren Elementen aufgebaut. Listen sind eine \memph{rekursive
Datenstruktur}. Rekursive Datenstrukturen sind \memph{dynamisch}, da zur
Laufzeit \memph{neue Elemente} erzeugt und \memph{hinzugefügt} werden
können.

Jedes Element enthält einen Inhalt (beliebiger Datentyp). Jedes Element
einer Liste beinhaltet zudem einen \memph{Verweis} auf das
\memph{nächste Listenelement} (Zeiger), also auf ein Objekt derselben
Klasse. Diese Struktur nennt man rekursiv.

\section{Rekursive Definition}

Eine Liste ist entweder eine \memph{leere Liste} oder besteht aus
\memph{Kopfelement und Restliste}. Der Zeiger des letzten Elements zeigt
auf \memph{NIL(Not In List)}

\section{Operationen:}

\begin{compactitem}
\item Einfügen eines Elements (Aufbau)
\item Entfernen eines Elements (Abbau)
\item Suchen eines Elements
\end{compactitem}

\section{Liste vs. Array}

Beim Array muss bei der Deklaration die Länge angegeben werden, diese
ist unveränderlich, die Liste wächst hingegen dynamisch. Beim Array
ist der direkte Zugriff auf die Einzelelemente möglich, durch die Liste
muss iteriert werden.
\footcite[Seite 4]{aud:fs:4}

\newcommand\tmpelement[1]{%
  \tikz{
    \node[
      draw,
      inner sep=2pt,
      minimum width=8mm,
      outer sep=0,
      text height=1.5ex,
      text depth=.3ex,
    ](a){#1}
  }
  \tikz{
    \node[
      draw,
      inner sep=2pt,
      minimum width=3mm,
      outer sep=0,
      text height=1.5ex,
      text depth=.3ex,
    ](a){}
  }
}

\begin{tikzcd}
\arrow[r,-to]{}{Start} &
  \tmpelement{1. Inhalt} \arrow[r,-to]{}{Next} &
  \tmpelement{2. Inhalt} \arrow[r,-to]{}{Next} &
  \tmpelement{3. Inhalt} \arrow[r]{}{NIL} &
\varnothing
\end{tikzcd}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Löschen eines inneren Listenelements}

Vom Vorgängerelement muss der Zeiger „nächstes Element“auf das
Folgeelement gesetzt werden. Das zu löschende Element wird später vom
Garbage Collector aufgeräumt.
\footcite[Seite 9-10]{aud:fs:4}

\begin{minted}{java}
while (element.next_element != NULL) { // Ende der Liste?
  if (element.next_element.wert != a) // Zu löschen?
    element = element.next_element; // Nein? Weitersuchen!
  else
    element.next_element=element.next_element.next_element; // Ja? Next-Zeiger anpassen!
}
\end{minted}

\section{Einfügen eines Listenelements}

Vom neuen Element muss der Zeiger „nächstes Element“ auf das
„Nachfolgeelement“ gesetzt werden. Vom „Vorgängerelement“ muss der
Zeiger „nächstes Element“auf das neue Element gesetzt werden.
\footcite[Seite 11-12]{aud:fs:4}

\begin{minted}{java}
if (element.next_element.wert < a) // Einfügestelle erreicht?
  element = element.next_element; // Nein? Weitersuchen!
else {
  new_element.next_element = element.next_element; // Ja? Einfügen!
  element.next_element = new_element;
}
\end{minted}

%%
%
%%

\subsection{Definition des Knoten}

\inputcode[firstline=15,lastline=49]{liste/saake/Liste}
\footcite[Seite 326]{saake}

%%
%
%%

\subsection{Definition der Liste}

\inputcode[firstline=53,lastline=125]{liste/saake/Liste}
\footcite[Seite 327-329]{saake}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Das Kompositum}

Das Kompositum (englisch \emph{composite} oder \emph{whole-part}) ist
ein Entwurfsmuster aus dem Bereich der Softwareentwicklung. Das
Kompositionsmuster (\emph{composite pattern}) wird angewendet, um
\emph{Teil-Ganzes-Hierarchien} zu repräsentieren, indem Objekte zu
\emph{Baumstrukturen} zusammengefügt werden. Die Grundidee des
Kompositionsmusters ist, in einer \emph{abstrakten Klasse} sowohl
\emph{primitive Objekte} als auch ihre \emph{Behälter} zu
repräsentieren. Somit können sowohl einzelne Objekte als auch ihre
Kompositionen \emph{einheitlich behandelt} werden.
\footcite{aud:fs:4}

Ein anderes Beispiel sind die \emph{Klassendefinitionen} der
\emph{grafischen Benutzeroberfläche von Java}. Alle Elemente wie
Schaltflächen und Textfelder sind \emph{Spezialisierungen der Klasse
Component}. Die Behälter für diese Elemente sind aber ebenfalls
Spezialisierungen derselben Klasse. Mit anderen Worten: Alle
Standardelemente werden wesentlich durch eine einzige
(Kompositum-)Klasse definiert.
\footcite{wiki:kompositum}

\begin{center}
\begin{tikzpicture}
\umlclass[x=2.5,y=3,type=abstract]{Komponente}{}{+ agiere()}
\umlclass[x=0]{Blatt}{}{+ agiere()}
\umlclass[x=5]{Kompositum}{}{
  + agiere()\\
  + fügeKindHinzu()\\
  + entferneKind()\\
  + gibKind()
}

\umlVHVinherit{Kompositum}{Komponente}
\umlVHVinherit{Blatt}{Komponente}
\umlHVHaggreg[anchor1=east,arm1=1.5cm,arg1=eltern,mult1=1,arg2=kind,mult2=0..*,pos2=2.9,pos1=0.4]{Kompositum}{Komponente}

\end{tikzpicture}
\end{center}

Details zum Nachlesen: Klett: Informatik 4, S.27 - 29

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Listen im Vergleich}

\begin{tabularx}{\linewidth}{|l|X|X|}

\hline
%%
%
%%

\textbf{Merkmal} & \textbf{Liste} & \textbf{Array}
\\
\hline\hline

%%
%
%%

\textbf{Speicherverhalten} &

Speicherung einer variablen Anzahl verketteter Elemente. Listengröße
während des Programmablaufs änderbar &

Speicherung einer festen Anzahl zusammengehörender Element. Arraygröße
während des Programmablaufs nicht änderbar.

\\
\hline

%%
%
%%

\textbf{Zugriffszeit} &

Jedes Element muss nacheinander durchlaufen werden $\rightarrow$ langsam
&

Jedes Element ist durch einen Index direkt abrufbar $\rightarrow$
schnell

\\
\hline

%%
%
%%

\textbf{Datensortierung} &

Unkompliziert duch Änderung der Verkettung $\rightarrow$
Daten bleiben an ihrem Speicherort &

Kompliziert durch Datenaustausch $\rightarrow$
Speicherort der Daten ändert sich

\\
\hline

\textbf{Wahlfreier Zugriff} &

wahlfreier Zugriff über den Index &

keine wahlfreier Zugriff, sondern \emph{sequential access}, je länger
die Liste, umso länger dauert der Zugriff (im \emph{average} und
\emph{worst case})

\end{tabularx}
\footcite[Seite 8]{aud:fs:4}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Aufgaben
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Aufgaben}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Aufgabe zu Heterogenen Listen\footcite[Seite 1, Aufgabe 1: Heterogene Liste]{aud:pu:4}}

Für die Umsetzung der Maut auf deutschen Autobahnen soll eine
Java-basierte Lösung entworfen werden. Dazu sollen alle Fahrzeuge, die
von einer Mautbrücken erfasst werden, in einer \emph{einfach verketteten
Liste} abgelegt werden. Um einen besseren Überblick über die Einnahmen
zu erhalten, soll zwischen \emph{LKWs}, \emph{PKWs} und
\emph{Motorrädern} unterschieden werden. Als Informatiker schlagen Sie
eine \emph{heterogene Liste} zur Realisierung vor. Notieren Sie unter
Verwendung des \emph{Entwurfsmusters Kompositum} ein entsprechendes
\emph{Klassendiagramm} zur Realisierung der Lösung für eine Mautbrücke.
Auf die Angabe von Attributen und Methoden kann verzichtet werden.
Kennzeichen Sie in Ihrem Klassendiagramm die \emph{abstrakten Klassen}
und benennen Sie die bestehenden \emph{Beziehungen}.

\begin{center}
\begin{tikzpicture}
\umlsimpleclass[type=abstract,x=4.5,y=5]{Listenelement}
\umlsimpleclass[x=3,y=3]{Abschluss}
\umlsimpleclass[x=6,y=3]{Datenknoten}
\umlsimpleclass[x=0,y=5]{Mautbrücke}
\umlassoc[mult2=1,arg2=erster\LeserichtungRechts{},pos2=0.7]{Mautbrücke}{Listenelement}
\umlinherit{Abschluss}{Listenelement}
\umlinherit{Datenknoten}{Listenelement}

\umlsimpleclass[type=abstract,x=5,y=2]{Fahrzeug}
\umlsimpleclass[x=3,y=0]{Motorrad}
\umlsimpleclass[x=5,y=0]{PKW}
\umlsimpleclass[x=7,y=0]{LKW}
\umlinherit{PKW}{Fahrzeug}
\umlinherit{Motorrad}{Fahrzeug}
\umlinherit{LKW}{Fahrzeug}

\umlHVHassoc[
  anchor1=east,
  anchor2=east,
  arm1=3cm,arg1=\LeserichtungLinks{}enthält,pos1=0.3,mult1=1,
  arg2=\LeserichtungLinks{}nächster,pos2=2.7,mult2=1
]{Fahrzeug}{Listenelement}
\end{tikzpicture}
\end{center}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Musikliste
\footcite[Seite 1-2, Aufgaben 1-3]{aud:ab:4}}

\subsection{Aufgabe 1}

\begin{center}
\begin{tikzpicture}[scale=0.8, transform shape]
\tiny
\umlclass
{MusikListe}
{
  int anzahl
}
{
  void setzeErsten(Knoten e)\\
  int aktualisiereAnzahl()\\
  String gibMusikstückListe()\\
  Knoten entnimmOben()\\
  Knoten gibKnoten()
}

\umlclass[x=6]
{Knoten}
{
}
{
  Knoten gibNächsten()\\
  void setzeNächsten(Knoten k)\\
  MusikStück gibMusikstück()
}

\umlclass[x=13]
{MusikStueck}
{
  String titel
}
{
  String gibTitel()
}

\umlaggreg[mult1=1,mult2=1,stereo=verwaltet \LeserichtungRechts]{Knoten}{MusikStueck}

\umlaggreg[
  angle1=10,
  angle2=90,
  loopsize=3cm,
  mult1=1,
  mult2=0..1,
  pos1=0.05,
  pos2=0.95,
  stereo=nächster \LeserichtungRechts
]{Knoten}{Knoten}

\umlassoc[arg1=erster \LeserichtungRechts, pos1=0.4]{MusikListe}{Knoten}

\end{tikzpicture}
\end{center}

Das Klassendiagramm zeigt den Aufbau einer Playlist.

\begin{enumerate}
\item Implementieren Sie das Klassendiagramm.

\begin{antwort}
\liPseudoUeberschrift{Klasse „MusikListe“}
\inputcode[firstline=3,lastline=66]{aufgaben/aud/ab_4/musikliste/MusikListe}

\liPseudoUeberschrift{Klasse „Knoten“}
\inputcode[firstline=3,lastline=24]{aufgaben/aud/ab_4/musikliste/Knoten}

\liPseudoUeberschrift{Klasse „MusikStueck“}
\inputcode[firstline=3]{aufgaben/aud/ab_4/musikliste/MusikStueck}
\end{antwort}

\item Schreiben Sie eine Testklasse, in der Sie eine Playlist mit
mindestens vier Liedern erstellen.

\begin{antwort}
\inputcode[firstline=3,lastline=16]{aufgaben/aud/ab_4/musikliste/TestKlasse}
\end{antwort}
\end{enumerate}

\subsection{Aufgabe 2}

Die Playlist aus Aufgabe 1 soll nun erweitert werden. Aktualisieren Sie
Ihren Code entsprechend!

\begin{enumerate}

%%
%
%%

\item Bisher wurde das erste Element der Musikliste in einer öffentlich
sichtbaren Variable gespeichert, dies ist jedoch nicht sinnvoll.
Erstellen Sie eine Methode \java{setzeErsten()}, mit der anstatt dessen
die Liste der erstellten Musikstücke angesprochen werden kann.

\begin{antwort}
\inputcode[firstline=12,lastline=13]{aufgaben/aud/ab_4/musikliste/MusikListe}
\end{antwort}

%%
%
%%

\item Außerdem wird ein Attribut \java{anzahl} benötigt, dass mit Hilfe
der Methode \java{aktualisiereAnzahl()} auf dem aktuellen Stand
gehalten werden kann.

\begin{antwort}
\inputcode[firstline=14,lastline=15]{aufgaben/aud/ab_4/musikliste/MusikListe}
\end{antwort}

%%
%
%%

\item Eine weitere Methode \java{gibMusikstückListe()} soll die Titel
aller Lieder in der Liste als \java{String} zurückgeben.

\begin{antwort}
\inputcode[firstline=32,lastline=43]{aufgaben/aud/ab_4/musikliste/MusikListe}
\end{antwort}

%%
%
%%

\item Mit \java{entnimmOben()} soll der erste Titel aus der Liste
entnommen werden können.

\begin{antwort}
\inputcode[firstline=45,lastline=53]{aufgaben/aud/ab_4/musikliste/MusikListe}
\end{antwort}

%%
%
%%

\item Es soll der Titel des Musikstücks ermittelt werden, das an einer
bestimmten Position in der Musikliste abgespeichert ist. Implementieren
Sie dazu die Methode \java{gibKnoten()}.

\begin{antwort}
\inputcode[firstline=55,lastline=66]{aufgaben/aud/ab_4/musikliste/MusikListe}
\end{antwort}

%%
%
%%

\item Die Musikliste soll nun in eine doppelt verkettete Liste umgebaut
werden. Fügen Sie entsprechende Attribute, getter- und setter-Methoden
hinzu.

\begin{antwort}
\inputcode[firstline=5,lastline=5]{aufgaben/aud/ab_4/musikliste/Knoten}
\inputcode[firstline=22,lastline=28]{aufgaben/aud/ab_4/musikliste/Knoten}
\end{antwort}

%%
%
%%

\item Testen Sie die Funktionalität der neuen Methoden in Ihrer
Testklasse.

\begin{antwort}
\inputcode[firstline=17,lastline=29]{aufgaben/aud/ab_4/musikliste/TestKlasse}
\end{antwort}

\end{enumerate}

\subsection{Rekursion}

Die Anzahl der Titel in der Musikliste aus Aufgabe 1 kann auch unter
Verwendung einer rekursiven Methode ermittelt werden. Implementieren Sie
eine Methode \java{zaehleEintraege()}, die analog zu
\java{aktualisiereAnzahl()} angibt, wie viele Titel in der Musikliste
gespeichert sind, dies aber rekursiv ermittelt! Testen Sie diese Methode
in der Testklasse. Hinweis: Um für die gesamte Musikliste aufgerufen
werden zu können, muss diese Methode in der Musikliste selbst und auch
in der Klasse Knoten existieren!

\begin{antwort}
\liPseudoUeberschrift{Klasse „MusikListe“}
\inputcode[firstline=68,lastline=74]{aufgaben/aud/ab_4/musikliste/MusikListe}

\liPseudoUeberschrift{Klasse „Knoten“}
\inputcode[firstline=34,lastline=40]{aufgaben/aud/ab_4/musikliste/Knoten}

\liPseudoUeberschrift{Klasse „TestKlasse“}
\inputcode[firstline=30,lastline=20]{aufgaben/aud/ab_4/musikliste/TestKlasse}
\end{antwort}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Aufgabe 5: Listen (Check-Up)}

Erstellen Sie ein Deutsch-Englisch Wörterbuch. Verwenden Sie dazu eine
einfach verkettete Liste mit Kompositum. Identifizieren Sie die
benötigten Klassen, legen Sie das Wörterbuch an und implementieren Sie
anschließend die geforderten Methoden.
\footcite[Seite 4, Aufgabe 5]{aud:ab:5}

\begin{itemize}
\item Ein Listenelement, welches immer jeweils auf seinen Nachfolger
verweisen kann, enthält jeweils einen Eintrag des Wörterbuchs. Ein
Eintrag besteht aus dem deutschen und dem zugehörigen englischen Wort.
Diese können natürlich jeweils zurückgegeben werden.

\item Mit der Methode \java{einfuegen (String deutsch, String englisch)}
soll ein neuer Eintrag in das Wörterbuch eingefügt werden können. Wie in
jedem Wörterbuch müssen die (deutschen) Einträge jedoch alphabetisch
sortiert sein, sodass nicht an einer beliebigen Stelle eingefügt werden
kann. Um die korrekte Einfügeposition zu finden, ist das Vergleichen von
Strings notwendig. Recherchieren Sie dazu, wie die Methode
\java{compareTo()} in Java funktioniert!

\item Der Aufruf der Methode \java{uebersetze(String deutsch)} auf der
Liste soll nun für ein übergebenes deutsches Wort die englische
Übersetzung ausgeben.

%%
%
%%

\subsection{Lösung}

\paragraph{Klasse \texttt{WörterbuchEintrag}}

Die abstrakte Klasse im Kompositumentwurfsmuster von der sowohl die
primitive Klasse als auch die Behälterklasse erben.

\begin{antwort}
\inputcode[firstline=3]{aufgaben/aud/ab_5/WoerterbuchEintrag}
\end{antwort}

%%
%
%%

\paragraph{Klasse \texttt{WortPaar}}

Das Listenelement (die primitive Klasse im Kompositumentwurfsmuster).

\begin{antwort}
\inputcode[firstline=3]{aufgaben/aud/ab_5/WortPaar}
\end{antwort}

%%
%
%%

\paragraph{Klasse \texttt{Wörterbuch}}

Die Behälterklasse im Kompositumentwurfsmuster.

\begin{antwort}
\inputcode[firstline=6]{aufgaben/aud/ab_5/Woerterbuch}
\end{antwort}

\end{itemize}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\ExamensAufgabeTA 66112 / 2005 / 03 : Thema 1 Aufgabe 1

\literatur

\end{document}
