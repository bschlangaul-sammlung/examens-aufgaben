\documentclass{lehramt-informatik-haupt}
\liLadePakete{syntax,spalten,tabelle}
\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Theorie-Teil
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Einfacher Assembler: Ein-Adress-Befehl}

Info\_2020-11-20-2020-11-20\_09.49.27 0h6min

https://schule.awiedemann.de/minimaschine.html

\subsection{Speicherbefehle}

\begin{tabularx}{\linewidth}{lX}
LOAD adresse & Lädt den Wert von der angegebenen Adresse in den Akkumulator. \\
LOADI zahl & Lädt die angegebenen Zahl in den Akkumulator, negative Werte sind möglich, Adressen sind nicht zulässig. \\
STORE adresse & Speichert den Wert im Akkumulator an der angegebenen Adresse.
\end{tabularx}

%%
%
%%

\subsection{Arithmetikbefehle}

\begin{tabularx}{\linewidth}{lX}
ADD adresse & Addiert den Wert von der angegebenen Adresse zum Akkumulator. \\
SUB adresse & Subtrahiert den Wert der angegebenen Adresse vom Akkumulator. \\
MUL adresse & Multipliziert den Wert von der angegebenen Adresse zum Akkumulator. \\
DIV adresse & Dividiert den Wert im Akkumulator durch den Wert der angegebenen Adresse. \\
MOD adresse & Dividiert den Wert im Akkumulator durch den Wert der angegebenen Adresse und speichert den Rest im Akkumulator. \\
CMP adresse & Vergleicht den Wert der angegebenen Adresse mit dem Akkumulator und setzt Null- und Negativflag entsprechend. \\
ADDI zahl & Addiert den angegebenen Wert zum Akkumulator. \\
SUBI zahl & Subtrahiert den angegebenen Wert vom Akkumulator. \\
MULI zahl & Multipliziert den angegebenen Wert zum Akkumulator. \\
DIVI zahl & Dividiert den Wert im Akkumulator durch den angegebenen Wert. \\
MODI zahl & Dividiert den Wert im Akkumulator durch den angegebenen Wert und speichert den Rest im Akkumulator. \\
CMPI zahl & Vergleicht den angegebenen Wert mit dem Akkumulator und setzt Null- und Negativflag entsprechend.
\end{tabularx}

%%
%
%%

\subsection{Bitmanipulationsbefehle}

\begin{tabularx}{\linewidth}{lX}
AND adresse & Bitweise logische Und-Verknüpfung des Werts der angegebenen Adresse mit dem Akkumulator. \\
OR adresse & Bitweise logische Oder-Verknüpfung des Werts der angegebenen Adresse mit dem Akkumulator. \\
XOR adresse & Bitweise logische Exklusiv-Oder-Verknüpfung des Werts der angegebenen Adresse mit dem Akkumulator. \\
NOT & Bitweise logische Invertierung des Werts im Akkumulator. \\
SHL adresse & Die Bitfolge im Akkumulator wird um die unter der angegebenen Adresse gespeicherten Anzahl Bits nach links geschoben. Frei werdende Bits werden mit 0-Werten belegt. \\
SHR adresse & Die Bitfolge im Akkumulator wird um die unter der angegebenen Adresse gespeicherten Anzahl Bits nach rechts geschoben. Frei werdende Bits werden mit 0-Werten belegt. \\
SHRA adresse & Die Bitfolge im Akkumulator wird um die unter der angegebenen Adresse gespeicherten Anzahl Bits nach rechts geschoben. Frei werdende Bits werden mit dem ursprünglich vordersten Bit belegt (Vorzeichenerhalt). \\
ANDI zahl & Bitweise logische Und-Verknüpfung der angegebenen Zahl mit dem Akkumulator. \\
ORI zahl & Bitweise logische Oder-Verknüpfung der angegebenen Zahl mit dem Akkumulator. \\
XORI zahl & Bitweise logische Exklusiv-Oder-Verknüpfung der angegebenen Zahl mit dem Akkumulator. \\
SHLI zahl & Die Bitfolge im Akkumulator wird um die angegebene Anzahl Bits nach links geschoben. Frei werdende Bits werden mit 0-Werten belegt. \\
SHRI zahl & Die Bitfolge im Akkumulator wird um die angegebene Anzahl Bits nach rechts geschoben. Frei werdende Bits werden mit 0-Werten belegt. \\
SHRAI zahl & Die Bitfolge im Akkumulator wird um die angegebene Anzahl Bits nach rechts geschoben. Frei werdende Bits werden mit dem ursprünglich vordersten Bit belegt (Vorzeichenerhalt). \\
\end{tabularx}

%%
%
%%

\subsection{Sprungbefehle}

\begin{tabularx}{\linewidth}{lX}
JMPP adresse &
Springt zur angegebenen Adresse, wenn das Ergebnis der letzen Operation
positiv ($> 0$) war, d. h. weder N noch Z-Flag sind gesetzt.
\\

JMPNN adresse &
Springt zur angegebenen Adresse, wenn das Ergebnis der letzen Operation
nicht negativ ($\geq 0$) war, d. h. das N-Flag ist nicht gesetzt. \\

JMPN adresse &
Springt zur angegebenen Adresse, wenn das Ergebnis der letzen Operation
negativ ($< 0$) war, d. h. das N-Flag ist gesetzt. \\

JMPNP adresse &
Springt zur angegebenen Adresse, wenn das Ergebnis der letzen Operation
nicht positiv ($\leq 0$) war, d. h. das N-Flag oder das Z-Flag ist gesetzt.
\\

JMPZ adresse &
Springt zur angegebenen Adresse, wenn das Ergebnis der letzen Operation
null ($= 0$) war, d. h. das Z-Flag ist gesetzt. \\

JMPNZ adresse &
Springt zur angegebenen Adresse, wenn das Ergebnis der letzen Operation
nicht null ($\neq 0$) war, d. h. das Z-Flag ist nicht gesetzt. \\

JMPV adresse &
Springt zur angegebenen Adresse, wenn die letzte Operation einen
Überlauf verursacht hat, d. h. das V-Flag ist gesetzt. \\

JMP adresse &
Springt zur angegebenen Adresse. \\
\end{tabularx}

%%
%
%%

\subsection{Alternative Notation der Sprungbefehle}

\begin{tabularx}{\linewidth}{lX}
JGT (= JMPP) adresse &
Springt zur angegebenen Adresse, wenn das Ergebnis der letzen Operation
positiv ($> 0$) war, d. h. weder N noch Z-Flag sind gesetzt. \\

JGE (= JMPNN) adresse &
Springt zur angegebenen Adresse, wenn das Ergebnis der letzen Operation
nicht negativ ($\geq 0$) war, d. h. das N-Flag ist nicht gesetzt. \\

JLT (= JMPN) adresse &
Springt zur angegebenen Adresse, wenn das Ergebnis der letzen Operation
negativ ($< 0$) war, d. h. das N-Flag ist gesetzt. \\

JLE (= JMPNP) adresse &
Springt zur angegebenen Adresse, wenn das Ergebnis der letzen Operation
nicht positiv ($\leq 0$) war, d. h. das N-Flag oder das Z-Flag ist gesetzt.
\\

JEQ (= JMPZ) adresse &
Springt zur angegebenen Adresse, wenn das Ergebnis der letzen Operation
null ($= 0$) war, d. h. das Z-Flag ist gesetzt. \\

JNE (= JMPNZ) adresse &
Springt zur angegebenen Adresse, wenn das Ergebnis der letzen Operation
nicht null ($\neq 0$) war, d. h. das Z-Flag ist nicht gesetzt. \\

JOV (= JMPV) adresse &
Springt zur angegebenen Adresse, wenn die letzte Operation einen
Überlauf verursacht hat, d. h. das V-Flag ist gesetzt. \\
\end{tabularx}

%%
%
%%

\subsection{Sonstige Befehle}

\begin{tabularx}{\linewidth}{lX}
HOLD & Hält den Prozessor an. Dieser Befehl hat keine Adresse. \\
RESET & Setzt den Prozessor auf den Startzustand zurück. Dieser Befehl hat keine Adresse. \\
NOOP & Tut einfach nichts (NO OPeration). Dieser Befehl hat keine Adresse. \\

\end{tabularx}

%%
%
%%

\subsection{Den Stackpointer verändernde Befehle}

\begin{tabularx}{\linewidth}{lX}
JSR & Springt zu der angegebenen Adresse und speichert den Folge-PC auf dem Stack (Unterprogrammaufruf). Der Stackpointer wird dazu um 1 erniedrigt. \\
RTS & Springt zu der Adresse in der Speicherzelle, auf dei der Stackpointer zeigt (Unterprogamrücksprung). Der Stackpointer wird anschließend um 1 erhöht. \\
PUSH & Erniedrigt den Stackpointer um 1 und speichert den Akkumulatorwert an der nun durch den Stackpointer gegebenen Adresse. \\
POP & Lädt den Inhalt der durch den Stackpointer gegebenen Adresse in den Akkumulator und erhöht den Stackpointer um 1. \\
RSV & Erniedrigt den Stackpointer um den im Adressteil gegebenen Wert (Platz reservieren). \\
REL & Erhöht den Stackpointer um den im Adressteil gegebenen Wert (Platz freigeben). \\
CALL & Alternative Notation zu JSR. \\
RETURN & Alternative Notation zu RTS. \\
\end{tabularx}

\subsection{Speicherorganisation}

\begin{tabularx}{\linewidth}{lX}
WORD zahl & Besetzt eine Speicherzelle mit der angegebenen Zahl, negative Werte sind möglich. \\
\end{tabularx}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Umsetzen elementarer Kontrollstrukturen}

%%
%
%%

\subsection{Bedingte Anweisung}

\begin{multicols}{3}
\liPseudoUeberschrift{Java}

\begin{minted}{java}
if (x == 0) {
  y = 0;
}
// ... next
\end{minted}

\liSpaltenUmbruch
\liPseudoUeberschrift{Assembler}

\begin{minted}{asm}
      LOAD x
      CMPI 0
      JMPNZ next
true: LOADI 0
      STORE y
next: # ...
\end{minted}

\liSpaltenUmbruch
\liPseudoUeberschrift{Minisprache}

\begin{minted}{componentpascal}
PROGRAM bedingte_anweisung;
VAR x, y;
BEGIN
  IF x = 0 THEN
    y := 0;
  END
END bedingte_anweisung.
\end{minted}
\vfill\strut
\end{multicols}

%%
%
%%

\subsection{Bedingte Anweisung mit Alternative}

\begin{multicols}{3}

\liPseudoUeberschrift{Java}

\begin{minted}{java}
if (x == 0) {
  y = 0;
} else {
  y = 1;
}
// ... next
\end{minted}

\liSpaltenUmbruch

\liPseudoUeberschrift{Assembler}

\begin{minted}{asm}
      LOAD x
      CMPI 0
      JMPNZ else
true: LOADI 0
      STORE y
      JMP next
else: LOADI 1
      STORE y
next: # ...
\end{minted}

\liSpaltenUmbruch
\liPseudoUeberschrift{Minisprache}

\begin{minted}{componentpascal}
PROGRAM bedingte_alternative;
VAR x, y;
BEGIN
  IF x = 0 THEN
    y := 0;
  ELSE
    y := 1;
  END
END bedingte_alternative.
\end{minted}
\vfill\strut
\end{multicols}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Aufgaben}

\begin{enumerate}

%%
%
%%

\item Speichere die Zahl 2 in der Variablen n.

\begin{multicols}{2}
\liPseudoUeberschrift{Assembler}

\begin{minted}{asm}
   LOADI 2
   STORE n
   HOLD
n: WORD 0
\end{minted}

\liSpaltenUmbruch
\liPseudoUeberschrift{Minisprache}

\begin{minted}{componentpascal}
PROGRAM zuweisung;
VAR
  n;
BEGIN
  n := 2;
END zuweisung.
\end{minted}
\vfill\strut
\end{multicols}

%%
%
%%

\item Addiere die beiden Zahlen 2 und 3.

\begin{multicols}{2}
\liPseudoUeberschrift{Assembler}

\begin{minted}{asm}
   LOADI 2
   ADDI 3
   STORE x
   HOLD
x: WORD 0
\end{minted}

\liSpaltenUmbruch
\liPseudoUeberschrift{Minisprache}

\begin{minted}{componentpascal}
PROGRAM addition;
VAR x;
BEGIN
  x := 2 + 3;
END addition.
\end{minted}
\vfill\strut
\end{multicols}

\item Überführe folgenden Java-Code in Assembler:

\begin{enumerate}

%%
%
%%

\item \liJavaCode{x = x + 2;}

\begin{multicols}{2}
\liPseudoUeberschrift{Assembler}

\begin{minted}{asm}
   LOAD x
   ADDI 2
   STORE x
   HOLD
x: WORD 0
\end{minted}

\liSpaltenUmbruch
\liPseudoUeberschrift{Minisprache}

\begin{minted}{componentpascal}
PROGRAM addition;
VAR x;
BEGIN
  x := x + 2;
END addition.
\end{minted}
\vfill\strut
\end{multicols}

%%
%
%%

\item \liJavaCode{x = x + y;}

\begin{multicols}{2}
\liPseudoUeberschrift{Assembler}

\begin{minted}{asm}
   LOAD x
   ADD y
   STORE x
   HOLD
x: WORD 0
y: WORD 0
\end{minted}

\liSpaltenUmbruch
\liPseudoUeberschrift{Minisprache}

\begin{minted}{componentpascal}
PROGRAM addition;
VAR x, y;
BEGIN
  x := x + y;
END addition.
\end{minted}
\vfill\strut
\end{multicols}
\end{enumerate}

%%
%
%%

\item Erstelle jeweils ein Assemblerprogramm zur

\begin{enumerate}

%%
%
%%

\item Bestimmung, ob eine Zahl größer ist als eine andere.

\begin{multicols}{2}
\liPseudoUeberschrift{Assembler}

\begin{minted}{asm}
          LOAD x
          CMP y
          JMPNP M$1
          LOADI 1
          STORE ergebnis
          JMP M$2
M$1:      LOADI 0
          STORE ergebnis
M$2:      HOLD
x:        WORD 0
y:        WORD 0
ergebnis: WORD 0
\end{minted}

\liSpaltenUmbruch
\liPseudoUeberschrift{Minisprache}

\begin{minted}{componentpascal}
PROGRAM groesser;
VAR x, y, ergebnis;
BEGIN
  IF x > y THEN
    ergebnis := 1;
  ELSE
    ergebnis := 0;
  END
END groesser.
\end{minted}
\vfill\strut
\end{multicols}

%%
%
%%

\item Bestimmung, ob eine Zahl gerade ist oder nicht.

\begin{multicols}{2}
\liPseudoUeberschrift{Assembler}

\begin{minted}{asm}
          LOAD x
          MODI 2
          STORE hi$1
          LOAD hi$1
          CMPI 0
          JMPNZ M$1
          LOADI 1
          STORE ergebnis
          JMP M$2
M$1:      LOADI 0
          STORE ergebnis
M$2:      HOLD
x:        WORD 0
ergebnis: WORD 0
hi$1:     WORD 0
\end{minted}

\liSpaltenUmbruch
\liPseudoUeberschrift{Minisprache}

\begin{minted}{componentpascal}
PROGRAM gerade;
VAR x, ergebnis;
BEGIN
  IF x % 2 = 0 THEN
    ergebnis := 1;
  ELSE
    ergebnis := 0;
  END
END gerade.
\end{minted}
\vfill\strut
\end{multicols}

\end{enumerate}

%%
%
%%

\item Summe der ersten $n$ Zahlen

\begin{multicols}{2}
\liPseudoUeberschrift{Assembler}

\begin{minted}{asm}
          LOADI 4
          STORE n
          LOADI 0
          STORE ergebnis

addition: LOAD n
          CMPI 0
          JMPNP ende
          LOAD ergebnis
          ADD n
          STORE ergebnis
          LOAD n
          SUBI 1
          STORE n
          JMP addition

ende:     HOLD
          ergebnis: WORD 0
          n: WORD 0
\end{minted}

\liSpaltenUmbruch
\liPseudoUeberschrift{Minisprache}

\begin{minted}{componentpascal}
PROGRAM summe;
VAR n, ergebnis;

BEGIN
  n := 4;
  ergebnis := 0;
  WHILE n > 0 DO
    ergebnis := ergebnis + n;
    n := n - 1;
  END
END summe.
\end{minted}
\end{multicols}

%%
%
%%

\item
\end{enumerate}

\literatur

\end{document}
