
------------------------------------------------------------------------

------------------------------------------------------------------------
Repetitorium
der Informatik

Prüfungsaufgaben und Lösungen 2001 –2008

von
Ulrich Kiesmüller und
Sandra Leibinger

Oldenbourg Verlag München


------------------------------------------------------------------------
Sandra Leibinger, geboren 1984 in Duisburg-Rheinhausen. Im September 2003 begann sie
das Studium für das Lehramt an Gymnasien in Mathematik und Informatik an der TU Dres-
den.  Im  September  2006  wechselte  sie  an  die  Friedrich-Alexander-Universität  Erlangen-
Nürnberg, wo sie ihr Studium dann im Frühjahr 2008 mit dem ersten Staatsexamen abschloss.
Ab dem Wintersemester 2006 war sie als studentische Hilfskraft in der Didaktik der Informa-
tik  eingesetzt,  wo  sie  insbesondere  mit  der  Betreuung  und  Staatsexamensvorbereitung  der
Teilnehmenden  am Projekt FLIEG (Flexible Lehrerweiterbildung in Informatik als Erweite-
rungsfach für Gymnasien) betraut war. Im Schuljahr 2008/2009 hat sie ihr Referendariat am
Adam-Kraft-Gymnasium, Schwabach begonnen

Ulrich Kiesmüller, geboren 1964 in München. Von September 1983 bis 1989 studierte er das
Lehramt  an  Gymnasien  in  Mathematik  und  Physik  an  der  Julius-Maximilians-Universität
Würzburg.  Im  Herbst  1989  schloss  er  sein  Studium  mit  dem  ersten  Staatsexamen  ab.  Nach
seinem  Referendariat  von  Februar  1990  bis  1992  absolvierte  er  dann  das  zweite  Staatsexa-
men. Nach absolvieren eines Erweiterungsstudiums für das Fach Informatik an der Friedrich-
Alexander-Universität  Erlangen-Nürnberg  legte  er  im  Herbst  2003  das  Staatsexamen  für
Informatik ab. Seit dem ist er als wissenschaftlicher Mitarbeiter in der Didaktik der Informa-
tik  bei  Prof.  Dr.  Torsten  Brinda  an  der  Friedrich-Alexander-Universität  Erlangen-Nürnberg
tätig.  Dort  zählt  neben  einem  Promotionsvorhaben  zu  seinen  Aufgaben  insbesondere  die
Betreuung  und  Staatsexamensvorbereitung  der  Teilnehmenden  am  Projekt  FLIEG  (Flexible
Lehrerweiterbildung in Informatik als  Erweiterungsfach für Gymnasien).

Bibliografische Information der Deutschen Nationalbibliothek

Die Deutsche Nationalbibliothek verzeichnet diese Publikation in der Deutschen
Nationalbibliografie; detaillierte bibliografische Daten sind im Internet über
<http://dnb.d-nb.de> abrufbar.

© 2009  Oldenbourg Wissenschaftsverlag GmbH
Rosenheimer Straße 145, D-81671 München
Telefon: (089) 45051-0
oldenbourg.de

Das  Werk  einschließlich  aller  Abbildungen  ist  urheberrechtlich  geschützt.  Jede  Verwertung
außerhalb der Grenzen des Urheberrechtsgesetzes ist ohne Zustimmung des Verlages unzulässig
und  strafbar.  Das  gilt  insbesondere  für  Vervielfältigungen,  Übersetzungen,  Mikroverfilmungen
und die Einspeicherung und Bearbeitung in elektronischen Systemen.

Lektorat: Dr. Margit Roth
Herstellung: Anna Grosser
Coverentwurf: Kochan & Partner, München
Gedruckt auf säure- und chlorfreiem Papier
Druck: Grafik + Druck, München
Bindung: Thomas Buchbinderei GmbH, Augsburg

ISBN 978-3-486-58905-4











------------------------------------------------------------------------
Vorwort

Mit der Einführung des achtstuﬁgen Gymnasiums in Bayern im Jahr 2004 und
dem damit verbundenen neuen Lehrplan wurde die Informatik als Pﬂichtfach ab
bereits der 6. Jahrgangsstufe eingeführt. Um die möglichst baldige Versorgung der
Schulen mit genügend Informatiklehrkräften zu erreichen, wurde von Prof. Dr. Pe-
ter Hubwieser (TU München) und Prof. Dr. Torsten Brinda (Friedrich-Alexander-
Universität Erlangen-Nürnberg) das Projekt FLIEG (Flexible Lehrerweiterbildung
für Informatik als Erweiterungsfach an Gymnasien) ins Leben gerufen. Hierbei
werden Gymnasiallehrer, die bereits in zwei Fächern das Staatsexamen absolviert
haben, parallel zum laufenden Unterrichtsbetrieb innerhalb von 2,5 bis 4 Jahren
durch betreutes Tele-Learning auf das Staatsexamen in Informatik als Erweite-
rungsfach an Gymnasien vorbereitet. Die ersten Absolventen traten im Herbst
2008 zur Examensprüfung an.
Die Autoren dieses Buches waren an der Friedrich-Alexander-Universität Erlangen-
Nürnberg in der Didaktik der Informatik damit betraut, die am FLIEG-Projekt
Teilnehmenden zu betreuen und auf das Staatsexamen vorzubereiten. Hierbei wur-
den die in diesem Buch zusammengestellten Lösungen zu den Staatsexamensaufga-
ben der Jahrgänge 2001 bis 2008 entwickelt. Wir danken den Teilnehmenden sehr
für die konstruktive Mitarbeit bei der Erstellung der Lösungen und die kritische
Kontrolle sowie die eingebrachten Verbesserungsvorschläge.
Theoretische
Die Einteilung der Staatsexamensaufgaben in die Themenbereiche
”
Objektorientierte Modellie-
Informatik“,
Algorithmen und Datenstrukturen“,
”
”
rung“,
Betriebssysteme“ spiegeln sich in der Kapiteleintei-
”
lung dieses Buches wieder. Innerhalb dieser Kapitel werden die Aufgaben (An-
gabentexte sind grau unterlegt) jeweils chronologisch aufgeführt. Am Seitenrand
sind den Stoﬀumfang der Aufgabe charakterisierende Stichworte angegeben. Er-
scheint ein bestimmter Aufgabentyp zum ersten Mal, so werden zusätzlich zur
Lösung ausführliche theoretische Grundlagen vermittelt. Später auftretende ähnli-
che Aufgabenlösungen werden dann knapper gehalten. An manchen Stellen werden
Hinweise auf hilfreiche Literatur ((cid:27)
) ge-
bzw. (cid:28)
geben. Die Programme sind in den jeweils in der Aufgabenstellung vorgegebenen
Programmiersprachen verfasst. Ist dort nichts näheres speziﬁziert, so werden für
objektorientierte Probleme Java, für funktionale Programme Haskell und für impe-
rative Programme historisch bedingt Pascal eingesetzt. Durch Kommentierung des
Quellcodes werden die Strukturen und Denkweisen der Programme näher erläutert.
Der Wortlaut der Aufgabenstellungen wurde unverändert übernommen, lediglich
hinsichtlich des Layouts wurden kleinere änderungen vorgenommen. Die Anga-
bentexte sind auch zu ﬁnden unter:

Datenbanken“ und
”

) bzw. Webseiten ((cid:17)

bzw. (cid:18)

http://ddi.informatik.uni-erlangen.de/Service/st ex/index.xml

(cid:18)

------------------------------------------------------------------------
VI

Vorwort

Rechnerarchi-
(Teil-)Aufgaben, die den Themenbereichen
”
tektur“ entstammen, wurden in diesem Buch nicht behandelt, da diese Themen-
bereiche nach der aktuellen Prüfungsordnung nicht mehr zum Stoﬀumfang der
schriftlichen Prüfungen gehören.

Rechnernetze“ und
”

Insbesondere bei Modellierungsaufgaben (Entity-Relation-Ship Modelle, objektori-
entierte Klassendiagramme), aber auch in anderen Bereichen wie die Implementie-
rung von Algorithmen oder die Ableitung von Worten bei gegebenen Grammatiken
und endlichen Automaten, existieren verschiedene Lösungsmöglichkeiten für eini-
ge der gestellten Aufgaben; die dargestellten Wege sind als Vorschläge und nicht
als einzig gültige Musterlösung zu verstehen. In einigen Fällen bieten wir mehrere
Alternativlösungen an.

Seitenzahlen, die im Stichwortverzeichnis durch Fettdruck hervorgehoben sind,
verweisen auf besonders ausführliche Lösungen mit Hintergrundinformationen zum
jeweiligen Thema.

Dieses Repetitorium der Informatik soll dazu dienen, den grundlegenden Lehr-
stoﬀ der oben genannten Teilgebiete der Informatik an Hand der thematisch und
chronologisch geordneten Lösungen der bayerischen Staatsexamensprüfungsaufga-
ben der Jahrgänge 2001-2008 zu lernen und zu wiederholen. Es richtet sich somit
in erster Linie an Studierende der Informatik für das Lehramt an Gymnasien als
Vorbereitung für das erste Staatsexamen, eignet sich jedoch gleichermaßen als stu-
dienbegleitende Lektüre für alle Informatikstudierenden sowie für den begleitenden
Einsatz im Unterricht der Mittel- und Oberstufe an der Schule.

Erlangen, im November 2008

S. Leibinger, U. Kiesmüller


------------------------------------------------------------------------
Inhaltsverzeichnis

1

Theoretische Informatik

Frühjahr 01 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Frühjahr 01 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

1

1
1
3
4

6
6

9
Herbst 01 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
Aufgabe 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
Aufgabe 6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12

Herbst 01 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16

Frühjahr 02 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20

Frühjahr 02 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
Aufgabe 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
Aufgabe 6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
Aufgabe 7 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26

Herbst 02 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29

Herbst 02 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31


------------------------------------------------------------------------
VIII

Inhaltsverzeichnis

Frühjahr 03 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
Aufgabe 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
Aufgabe 6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
Aufgabe 7 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37

Frühjahr 03 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
Aufgabe 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
Aufgabe 6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40

Herbst 03 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
Aufgabe 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
Aufgabe 6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
Aufgabe 7 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
Aufgabe 8 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44

Herbst 03 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47

Frühjahr 04 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52

Frühjahr 04 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
Aufgabe 6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55
Aufgabe 7 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56

Herbst 04 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56

Herbst 04 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
Aufgabe 6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61

Frühjahr 05 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62

Frühjahr 05 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64


------------------------------------------------------------------------
Inhaltsverzeichnis

IX

Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66

Herbst 05 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67

Herbst 05 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69

Frühjahr 06 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75
Aufgabe 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76

Frühjahr 06 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80

Herbst 06 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87

Herbst 06 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89

Frühjahr 07 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93

Frühjahr 07 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95

Herbst 07 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99

Herbst 07 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103

Frühjahr 08 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107


------------------------------------------------------------------------
X

Inhaltsverzeichnis

Frühjahr 08 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113

2

Algorithmen und Datenstrukturen

115

Frühjahr 01 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
Aufgabe 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116

Frühjahr 01 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119

Herbst 01 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122

Frühjahr 02 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124

Herbst 02 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129

Frühjahr 03 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131

Frühjahr 03 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132

Herbst 03 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134

Herbst 03 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136
Aufgabe 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136
Aufgabe 6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 137
Aufgabe 7 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138
Aufgabe 8 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140

Frühjahr 04 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143
Aufgabe 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145
Aufgabe 6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 146

Frühjahr 04 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150


------------------------------------------------------------------------
Inhaltsverzeichnis

XI

Aufgabe 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151

Herbst 04 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154

Herbst 04 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156
Aufgabe 7 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156

Frühjahr 05 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 162

Frühjahr 05 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 164
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 164
Aufgabe 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165
Aufgabe 6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167
Aufgabe 7 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168
Aufgabe 8 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 169
Aufgabe 9 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 170

Herbst 05 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 172

Herbst 05 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173
Aufgabe 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 174
Aufgabe 6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175

Frühjahr 06 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176
Aufgabe 6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176
Aufgabe 7 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 177
Aufgabe 8 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 179

Herbst 06 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 182
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 182

Herbst 06 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187
Aufgabe 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 189

Frühjahr 07 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 192
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 192
Aufgabe 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193
Aufgabe 6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 196
Aufgabe 7 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 196
Aufgabe 8 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198


------------------------------------------------------------------------
XII

Inhaltsverzeichnis

Frühjahr 07 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199

Herbst 07 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200

Herbst 07 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203

Frühjahr 08 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 207
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 207

3

Objektorientierte Modellierung

209

Herbst 02 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 209
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 209

Herbst 02 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213
Aufgabe 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213

Frühjahr 04 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 215
Aufgabe 6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 215

Herbst 04 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 216
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 216

Herbst 05 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 219
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 219

Frühjahr 06 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 220
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 220

Herbst 06 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 221
Aufgabe 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 221

Herbst 06 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 224
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 224

4

Betriebssysteme

229

Frühjahr 01 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 229
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 229

Herbst 01 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 230
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 230
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 231
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232

Frühjahr 02 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232
Aufgabe 6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232
Aufgabe 7 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 233

Frühjahr 02 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 233
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 233


------------------------------------------------------------------------
Inhaltsverzeichnis

XIII

Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 234

Herbst 02 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 236
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 236
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 237
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 239

Herbst 02 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240
Aufgabe 7 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240
Aufgabe 8 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 241
Aufgabe 9 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 242

Frühjahr 03 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 244
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 244

Frühjahr 03 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 245
Aufgabe 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 245

Herbst 03 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 249
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 249

Herbst 03 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 252
Aufgabe 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 252
Aufgabe 6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 254
Aufgabe 7 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 256

Frühjahr 04 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 257
Aufgabe 10 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 257
Aufgabe 11 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 257

Herbst 04 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 258
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 258
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 261

Herbst 04 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 262
Aufgabe 6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 262
Aufgabe 7 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264
Aufgabe 8 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 266
Aufgabe 9 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 268

Frühjahr 05 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270
Aufgabe 10 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270
Aufgabe 11 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 271

Herbst 05 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273

Herbst 05 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 274
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 274
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 274


------------------------------------------------------------------------
XIV

Inhaltsverzeichnis

Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 274
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 274
Aufgabe 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 274

Frühjahr 06 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 275
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 275
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 275
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 276

Frühjahr 06 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 279
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 279
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 282
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 284

Herbst 06 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 286
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 286
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 290
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 292

Herbst 06 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 293
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 293
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 295
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 296

Frühjahr 07 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 297
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 297
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 300
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 302
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 303

Frühjahr 07 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 304
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 304
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 306
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 306
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 308
Aufgabe 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 308

Herbst 07 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 311
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 311
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 314
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 316
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 317

Herbst 07 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 319
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 319
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 321
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 322

Frühjahr 08 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 323
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 323
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 325


------------------------------------------------------------------------
Inhaltsverzeichnis

XV

Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 326
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327
Aufgabe 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 328

Frühjahr 08 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 329
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 329
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 332
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 334
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 337
Aufgabe 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 339

5

Datenbanken

341

Frühjahr 01 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 341
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 341

Herbst 01 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 343
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 343

Herbst 01 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 346
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 346

Frühjahr 02 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 349
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 349

Frühjahr 02 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 350
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 350

Herbst 02 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 352
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 352

Herbst 02 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 355
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 355
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 357

Frühjahr 03 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 359
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 359
Aufgabe 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 360

Frühjahr 03 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 362
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 362
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 364
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 365

Herbst 03 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 365
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 365
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 367
Aufgabe 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 368
Aufgabe 6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 370

Herbst 03 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 372
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 372
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 373


------------------------------------------------------------------------
XVI

Inhaltsverzeichnis

Frühjahr 04 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 375
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 375
Aufgabe 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 375
Aufgabe 6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 376
Aufgabe 7 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 376
Aufgabe 8 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 378
Aufgabe 9 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 379

Frühjahr 04 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 379
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 379
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 379
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 379
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 380
Aufgabe 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 381

Herbst 04 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 382
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 382
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 383

Herbst 04 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 385
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 385
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 386
Aufgabe 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 388

Frühjahr 05 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 389
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 389
Aufgabe 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 389
Aufgabe 6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 389
Aufgabe 7 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 389
Aufgabe 8 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 389

Frühjahr 05 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 390
Aufgabe 9 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 390

Herbst 05 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 393
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 393
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 393
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 393
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 393
Aufgabe 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 393
Aufgabe 6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 393
Aufgabe 7 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 393

Herbst 05 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 393
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 393
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 394
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 394

Frühjahr 06 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 394
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 394
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 395


------------------------------------------------------------------------
Inhaltsverzeichnis

XVII

Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 396
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 398
Aufgabe 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 400

Frühjahr 06 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 402
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 402
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 403
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 405

Herbst 06 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 407
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 407
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 408
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 410

Herbst 06 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 412
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 412
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 412
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 414

Frühjahr 07 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 415
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 415
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 416
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 417
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 419
Aufgabe 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 420
Aufgabe 6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 421
Aufgabe 7 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 423

Frühjahr 07 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 424
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 424
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 428
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 432

Herbst 07 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 435
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 435
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 436
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 438
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 438
Aufgabe 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 440
Aufgabe 6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 442

Herbst 07 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 445
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 445
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 447
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 448

Frühjahr 08 - Thema 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 450
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 450
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 451
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 452
Aufgabe 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 453


------------------------------------------------------------------------
XVIII

Inhaltsverzeichnis

Aufgabe 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 454
Aufgabe 6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 457
Aufgabe 7 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 460

Frühjahr 08 - Thema 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 463
Aufgabe 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 463
Aufgabe 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 465
Aufgabe 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 467

Literaturverzeichnis

Index

469

471


------------------------------------------------------------------------
1

Theoretische Informatik

Frühjahr 01 - Thema 1

Aufgabe 1

Gegeben sei das Alphabet Σ = {0, 1} und die Sprache L = {10i1j0|i und j sind
gerade; i, j ≥ 0}.
a) Geben Sie einen regulären Ausdruck mit Sprache L an.
b) Geben Sie eine rechtslineare Grammatik an, die L erzeugt.

c) Konstruieren Sie einen nichtdeterministischen Automaten ohne Leerüber-

gänge, der die Sprache L akzeptiert.

regulärer
Ausdruck,
rechts-
lineare
Gramma-
tik, NEA,
DEA,
Minimali-
sierung

d) Konstruieren Sie einen minimalen deterministischen Automaten, der L

akzeptiert.

a) 1(00)*(11)*0
b) G = ({S, A, B}, {0, 1}, P, S) wobei

P = {S → 1A

A → 00A | B
B → 11B | 0}

c) M = (Z, Σ, δ, S, F )

Z = {S, q0, q1, q2, q3, q4, F }
Σ = {0, 1}

S
∅
0
1 {q0}

q0

q1
{q1, F } q0

{q2}

q2
∅
∅ {q3, q4} {q2}

q3
∅

q4 F
{F } ∅
∅

∅

d) Zuerst wird der deterministische Automat bestimmt:

Initialisierung: Z = {{S}}, ZH = {{S}}


------------------------------------------------------------------------
2

1 Theoretische Informatik

{q2}}

Hilfsmenge

ZH = {{q0}}

Zustandsmenge

Z = {{S}, {q0}}

Zustands
übergänge
δ({S}, 1) = {q0}
δ({q0}, 0) = {q1, F }, Z = {{S}, {q0}, {q1, F }, ZH = {{q1, F }, {q2}}
δ({q0}, 1) = {q2}
δ({q1, F }, 0) = {q0}, Z = {{S}, {q0},
{q1, F }, {q2}}
δ({q1, F }, 1) = ∅
Z = {{S}, {q0}, {q1, F }, ZH = {{q3, q4}}
δ({q2}, 0) = ∅,
{q2}, {q3, q4}}
δ({q2}, 1) = {q3, q4}
δ({q3, q4}, 0) = {F }, Z = {{S}, {q0}, {q1, F }, ZH = {{F }}
{q2}, {q3, q4}, {F }}
δ({q3, q4}, 1) = {q2}
Z = {{S}, {q0}, {q1, F }, ZH = ∅
δ({F }, 0) = ∅,
{q2}, {q3, q4}, {F }}
δ({F }, 1) = ∅

ZH = {{q2}}

Jetzt kommt die Minimalisierung:

{S}
{q0}
{q1, F}
{q2}
{q3, q4}

∗1
∗1

∗1
∗1
{F}

∗1

∗1

{S}

{q0}

∗1
∗1
{q1, F}

{q2}

Bemerkung: Der Table-ﬁlling-Algorithmus versagt hier. Wird er auf den
vollständigen Automaten angewendet, lässt sich zeigen, dass der Automat
bereits minimal ist. Alternativ kann ein anderer Algorithmus angewendet
werden:
Dazu werden die Zustände in Gruppen (möglicherweise) äquivalenter Zustän-
de eingeteilt. Im ersten Schritt werden die Gruppen der Endzustände und
der Nicht-Endzustände betrachtet (die auf jeden Fall nicht äquivalent sind)
und notiert, in welche der beiden Gruppen eine Eingabe jeweils führt:
A = {{q1, F }, {F }}, B = {{S}, {q0}, {q2}, {q3, q4}}
{q3, q4}
{S}
∅
A
B
B

{q2}
∅
0
B
1
Nun werden die Gruppen aufgeteilt, denn z. B. {S} und {q2} sind äquivalent
(übereinstimmend in beiden Einträgen), {S} und {q0} sowie {S} und {q3, q4}
hingegen nicht.

{q1, F }
B
∅

{q0}
A
B

{F }
∅
∅


------------------------------------------------------------------------
Frühjahr 01 - Thema 1

3

A1 = {{q1, F }}, A2 = {{F }}, B1 = {{S}, {q2}}, B2 = {{q0}, {q3, q4}}

{q1, F }
B2
∅

{F }
∅
∅

{S}
∅
B2

{q2}
∅
B2

{q0}
A1
B1

{q3, q4}
A2
B1

0
1

Wiederum werden die inhomogenen Gruppen aufgespalten:
A1 = {{q1, F }}, A2 = {{F }},
B1 = {{S}, {q2}}, B21 = {{q0}}, B22 = {{q3, q4}}
{q3, q4}
{S}
∅
A2
B1

{q1, F }
B21
∅

{q0}
A1
B1

{F }
∅
∅

B21 B22

{q2}
∅

0
1

Die Aufspaltung von B1 führt nun zu ausschließlich einelementigen Gruppen.
Es können folglich keine Zustände zusammgengefasst werden, der Automat
ist minimal.
Anmerkung: Wäre der Automat nicht minimal, gäbe es irgendwann kei-
ne änderungen mehr an den Gruppeneinteilungen/Gruppeneinträgen. Dann
können alle Zustände einer Gruppe zusammengefasst werden.
Siehe hierzu auch:
http://www.num.math.uni-goettingen.de/damm/Info2/01/doc/Minimalautomat.html

Aufgabe 2

Gegeben sei die folgende Grammatik G zur Erzeugung arithmetischer Aus-
drücke:
G = ({E}, {a, b, +, ∗, (, )}, P, E}) wobei
P = E → E + E, E → E ∗ E, E → (E), E → a, E → b.
a) Geben Sie eine Ableitung für den Ausdruck (a+b)*(a*b) an.
b) Zeigen Sie, dass die Grammatik G nicht eindeutig (d. h. ambig) ist.

Ableitung,
eindeutige
Gramma-
tik,
Syntax-
baum

c) Gesucht ist eine eindeutige Grammatik G’, die dieselbe Sprache wie G hat.

Vervollständigen Sie dazu den folgenden Ansatz durch Hinzunahme weiterer
Produktionsregeln:
G0 = ({E, F, G}, {a, b, +, ∗, (, )}, P 0, E}) wobei
P 0 = {E → E + F, E → F, ...}.

(cid:18)

------------------------------------------------------------------------
4

a)

1 Theoretische Informatik

b) Eine Grammatik ist mehrdeutig, wenn es zu einem Wort mehrere Ablei-

tungsbäume gibt, wie der Ausdruck b + b + b im folgenden Beispiel:

c) G0 = ({E, F, G}, {a, b, +, ∗, (, )}, P 0, E} wobei

P 0 = {E → E + F, E → F, F → F ∗ G, F → G, G → (E), G → a, G → b}

Aufgabe 3

primitiv
rekursiv

Beim Beweis der folgenden Aufgaben ist jeweils das Schema der primitiven
0 → N0 und
Rekursion mit geeigneten primitiv rekursiven Funktionen g : Nn
h : N2
a) Zeigen Sie, dass die folgenden Funktionen primitiv rekursiv sind:

0 → N0 anzuwenden.

iszero: N0 → N0, iszero(0) = l, iszero(x) = 0, falls x 6= 0.
even: N0 → N0, even(x) = l, falls x gerade, even(x) = 0, falls x ungerade.
case: N3
0 → N0, case(x, y, z) = y, falls x = 0, case(x, y, z) = z, falls x 6= 0.
b) Zeigen Sie:

Ist f : N0 → N0 primitiv rekursiv, dann ist auch
r : N2
0 → N0 mit r(x, i) = f i(x) primitiv rekursiv.
Dabei bezeichnet f 0 die Identität und für i > 0 bezeichnet
f i die i-malige Hintereinanderausführung f(....f(x)...) von f.

a) Da im Laufe der Lösung mehrfach die modiﬁzierte Subtraktion (alle Diﬀe-
renzwerte, die kleiner als 0 wären, werden auf 0 gesetzt) sowie die Addition
und die Multiplikation verwendet werden, werden diese erst einmal als pri-
mitiv rekursive Funktion abgeleitet:


------------------------------------------------------------------------
Frühjahr 01 - Thema 1

5

2(y, p(n)).

1(x) und
3(x, y, sub(x, y))).

Die (modiﬁzierte) Vorgängerfunktion p(n) lautet:
p(0) = 0
p(s(n)) = n (s ist die als primitiv rekursiv bekannte Nachfolgerfunktion)
Hierbei ergeben sich g() = 0 und h(y, p(n)) = π2
Die (modiﬁzierte) Subtraktion sub(x, y) lautet:
sub(x, 0) = x
sub(x, s(y)) = p(sub(x, y))
Hierbei wären also g(x) = π1
h(x, y, sub(x, y)) = p(π3
Die Addition add(n) lautet:
add(x, 0) = x
add(x, s(n)) = s(add(x, n))
Dies bedeutet g(x) = π1
Die Multiplikation mult(x, y) lautet:
mult(x, 0) = 0
mult(x, s(n)) = add(x, mult(x, n))
Damit erhält man g(x) = 0 und
h(x, n, mult(x, n)) = add(π3
Nun zur Lösung der gestellten Aufgaben:

1(x) und h(x, n, add(x, n)) = s(π3

1(x, n, mult(x, n)), π3

3(x, n, mult(x, n))).

3(x, n, add(x, n))).

iszero(0)
=s(0)
iszero(s(n)) =sub(0, iszero(n))

mit g() = s(0) und h(y, iszero(n)) = sub(0, π2

2(y, iszero(n))).

=s(0)
even(0)
even(s(n)) =sub(s(0), even(n))

mit g() = s(0) und h(y, even(n)) = sub(s(0), π2

2(y, even(n))).

case(x, y, z) =add(

2(x, y, z), iszero(π3

mult(π3
mult(sub(s(0), iszero(π3

1(x, y, z))),
1(x, y, z))), π3

3(x, y, z)))

mit g(y, z) = π2

1(y, z) und
h(x, y, z) =add(

2(x, y, z), iszero(π3

mult(π3
mult(sub(s(0), iszero(π3

1(x, y, z))),
1(x, y, z))), π3

3(x, y, z))).


------------------------------------------------------------------------
6

1 Theoretische Informatik

b) Beweis mittels vollständiger Induktion über i:

i = 0:
i = 1:

i → i + 1:

r(x, 0) = id(x) = x ist per Deﬁnition primitiv rekursiv.
r(x, 1) = f 1(x) = f (x) ist laut Aufgabenstellung ebenfalls
primitiv rekursiv.
Sei nun f n(x) als primitiv rekursiv bereits gezeigt.
r(x, n + 1) = f (f n(x)) ist primitiv rekursiv als Komposition
zweier primitiv rekursiver Funktionen.

Frühjahr 01 - Thema 2

Aufgabe 2

Ableitung,
DEA,
kontextfreie
Gram-
matik,
Produk-
tionsregeln,
reguläre
Sprache,
Keller-
automat,
Turing-
maschine

Gegeben sei die Grammatik Γ mit der Menge {a, b} von Terminalzeichen, dem
Startsymbol S als einzigem Nicht-Terminalzeichen und den 4 Produktionsregeln
S → a
S → aS
S → aSb
S → bSa
sowie der reguläre Ausdruck
R = a(aa∗b + baaa∗).
L(Γ) sei die von Γ erzeugte Sprache, L(R) die durch R beschriebene Sprache.
Schließlich sei L die Menge aller nicht-leeren Zeichenreihen über {a, b}, in denen
a öfter als b vorkommt.
a) Geben Sie eine Ableitung der Zeichenreihe aababaaab in Γ an.
b) Beweisen Sie: L(R) ( L(Γ) ( L.
c) Geben Sie einen deterministischen endlichen Automaten an, der die Sprache

L(R) akzeptiert.

d) Geben Sie eine kontextfreie Grammatik (Typ 2) mit höchstens

5 Produktionsregeln an, die L(R) erzeugt.

e) Beweisen Sie, dass L keine reguläre Sprache ist.
f) Geben Sie einen nichtdeterministischen Kellerautomaten an, der die

Sprache L(Γ) akzeptiert.

g) Geben Sie eine deterministische Turingmaschine an, die die Sprache L

akzeptiert.


------------------------------------------------------------------------
Frühjahr 01 - Thema 2

7

a)

b) Betrachte zuerst L(R) ⊂ L(Γ):

Die Wörter aus L(R) enthalten alle genau ein b, die Wörter von L(Γ) können
aber auch mehrere b enthalten.
Andererseits sind alle Wörter aus L(R) in L(Γ) enthalten, da sie mit den
Ableitungregeln 3 → n ∗ 2 → 1 bzw. 2 → 4 → n ∗ 2 → 1 gebildet werden
können (die Nummern beziehen sich hierbei auf die Ableitungsregeln aus der
Angabe, n ∈ N0).
Betrachte nun L(Γ) ⊂ L:
Mit den Regeln 3 und 4 der Grammatik entstehen Wörter, die genau so viele
a wie b enthalten. Um das Wort abzuschließen muss Regel 1 angewendet
werden, so dass alle Wörter aus L(Γ) mindestens ein a mehr als b besitzen.
Damit gilt L(Γ) ⊂ L.
L(Γ) 6= L, da sich das Wort aba z. B. nicht mit Γ produzieren lässt, aber
aba ∈ L gilt.

c) M = (Z, Σ, δ, S, F ), Z = {S, Z1, Z2, Z3, Z4, E}, F = {E}, Σ = {a, b}

δ:

S

Z1 Z2 Z3 Z4 E1 E2
E2
∅

a Z1 Z2 Z2 Z4 E2
∅
Z3 E1
b

∅
∅

∅

∅

d) Durch die Beschränkung der Anzahl der Regeln ist es nicht möglich, eine

reguläre Grammatik zu L(R) anzugeben.
G = ({S, A, B}, {a, b}, P, S)
P = {S → aAb | abAa
A → aA | a}


------------------------------------------------------------------------
8

1 Theoretische Informatik

e) Für jedes Wort der Form anbn+1 bräuchte ein endlicher Automat 2n + 1
Zustände. Da die Wörter aus L von beliebiger Länge sind, bräuchte der
Automat unendlich viele Zustände und damit kann L nicht regulär sein.

f)

Parameter
Zustand Eingabe Keller
a
a
a
b
b
b
a
ε
a
a
ε

#
A
B
#
B
A
A
A
A
#
A

S
S
S
S
S
S
S
S
F
F
F

Funktionswert
Zustand Keller

S
S
S
S
S
S
F
F
F
F
F

A#
AA
ε
B#
BB
ε
ε
ε
ε
ε
ε

g) M = (Z, Σ, Γ, δ, Z0, #, {Z+}), Z = {Z0, Z1, Z2, Z3, Z4, Z+}

Σ = {a, b}, Γ = {a, b, ∗, #}

δ:
a
b
#
∗

Z0
(Z1, ∗, L)
(Z0, b, R)

(Z0, ∗, R)

Z1
(Z1, a, L)
(Z1, b, L)
(Z2, #, R)
(Z1, ∗, L)

Z2
(Z2, a, R)
(Z3, ∗, L)
(Z+, #, N )
(Z2, ∗, R)

Z3
(Z3, a, L)
(Z3, b, L)
(Z0, #, R)
(Z3, ∗, R)

Z+


------------------------------------------------------------------------
Herbst 01 - Thema 1

9

Zur Erklärung:
Beginne in Z0 und laufe nach rechts bis das erste a gefunden wird. Das wird
durch * ersetzt. Dann wird im Zustand Z1 wieder zurück zum Wortanfang
gegangen und von dort aus in Z2 ein b gesucht. Wenn das b gefunden ist,
wird in Z3 wieder ganz nach links gelaufen. Wenn die TM ein a gefunden
hat und kein weiteres b mehr ﬁndet bis zum Wortende, also sich dort in Z2
beﬁndet, geht sie über in den Endzustand, weil sicher ist, dass mindestens
ein a mehr als b im Wort enthalten war.

Herbst 01 - Thema 1

Aufgabe 1

Gegeben sei die Sprache L = {anbmcn|n > 0, m > 0} über Σ = {a, b, c}.
a) Ist L regulär? (Begründung!)
b) Ist L kontextfrei? (Begründung!)
c) Ist L kontextsensitiv? (Begründung!)
d) Ist L entscheidbar? (Begründung!)

reguläre,
kontext-
freie,
kontext-
sensitive,
entscheid-
bare
Sprache

a) Nein, L ist nicht regulär, denn sonst wäre das Pumping-Lemma erfüllbar.
Um dieses zu erfüllen, müsste das Wort anbmcn gleichzeitig im Bereich der
a’s und c’s gepumpt werden. Bei der Pump-Zahl n besteht der aufgepumpte
Teil v jedoch nur aus a und enthält keine c. Damit exisitiert für das Wort
anbmcn keine Zerlegung, die das Pumping-Lemma erfüllt und L ist nicht
regulär.

b)

G = ({S, B}, {a, b, c}, P, S)
P = {S → aSc | aBc

B → bB | b}


------------------------------------------------------------------------
10

1 Theoretische Informatik

G ist eine kontextfreie Grammatik, die L erzeugt: die 1. Regel wird (n-1)-mal
angewendet und erzeugt an−1Scn−1. Danach resultiert mit Regel 2 anBcn.
Nun können mit Regel 3 beliebig viele b erzeugt werden. Regel 4 garantiert
jedoch, dass mindestens ein b produziert wird. Wegen der Existenz dieser
Grammatik ist L somit kontextfrei.

c) Ja, L ist kontextsensitiv, da jede kontextfreie Sprache auch kontextsensitiv

ist.

d) L ist entscheidbar, da folgende deterministische Turing-Maschine, die L er-

kennt, konstruiert werden kann:
Von außen nach innen werden paarweise a und c gelöscht. Nach dem letzten
a muss zwangsläuﬁg ein b kommen. Es werden auch alle b gelöscht. Wenn
danach das Band leer ist (es könnten noch überzählige c vorhanden sein),
wird das Wort akzeptiert.

Aufgabe 2

DEA Konstruieren Sie einen vollständigen deterministischen erkennenden Automa-
n ist weder durch 4 noch durch 6
”

ten, der genau die Wörter der Form an mit
teilbar“ akzeptiert.

Vielfache von 4 und 6 sind keine Endzustände, alle anderen Zustände schon. Der
Automat hat deshalb genau 12 Zustände, weil 12 das kleinste gemeinsame Vielfa-
che (kgV) von 4 und 6 ist.

Aufgabe 3

entscheid-
bar

Diskutieren Sie die Frage, ob die Menge

M = {x ∈ N| die Ziﬀernfolge der Dezimaldarstellung von x kommt (als
Teilwort) in der Dezimaldarstellung der Zahl π vor}

entscheidbar ist. (Beispiel: π = 3, 141592... enthält 159, also 159 ∈ M )


------------------------------------------------------------------------
Herbst 01 - Thema 1

11

π ist bekanntlich irrational, d. h. das Band einer Turing-Maschine kann mit π nur
deshalb beschrieben werden, weil das Band unendlich lang ist. In diesem Fall ist es
einfacher statt mit einer 1-Band-TM mit einer 2-Band-TM zu arbeiten. Das eine
Band enthält π, das andere x. Der Kopf des 1. Bands fährt nach rechts, bis er
ein Zeichen gefunden hat, das mit dem 1. Zeichen von x übereinstimmt. Nun wird
parallel geprüft, ob auf beiden Bändern die gleiche Zeichenfolge steht. Falls dies
der Fall ist, gilt x ∈ M und die TM terminiert. Andernfalls läuft der Kopf des 2.
Bands wieder zurück zum 1. Zeichen von x und der Kopf des 1. Bands sucht die
nächste übereinstimmung.
Falls x 6∈ M läuft der Kopf des 1. Bands immer weiter nach rechts. Nachdem die
überprüfung nie mit einem positiven Ergebnis abgeschlossen wird, terminiert die
TM in diesem Fall nicht.

Die Menge ist folglich nicht entscheidbar, sondern nur semi-entscheidbar.

Aufgabe 4

Für die Simulation der Stapelalgebra mit WHILE-Programmen benötigt man
eine Funktion code = N∗ → N, die endliche Folgen natürlicher Zahlen codiert.
Sei durch stapel = [x1, ..., xk] ein Stapel natürlicher Zahlen mit oberstem Ele-
ment x1 gegeben.

Keller-
operation,
Paarungs-
funktion,
WHILE

a) Deﬁnieren Sie eine geeignete Funktion code und erläutern Sie code(stapel)

(Hinweis: Eine Paarungsfunktion ist nützlich!)

b) Berechnen Sie code([2, 4]).

c) Geben Sie WHILE-Programme an, die die Stapel-Operationen

empty, push, pop, top, isempty implementieren.

a) Zuerst wird die Cantorsche Paarungsfunktion deﬁniert:

siehe auch http://de.wikipedia.org/wiki/Cantorsche Paarungsfunktion

paarcode : N2 → N,

paarcode(x, y) =

x+yX

i=0

i + y ∀x,y∈N0

Damit werden zwei natürliche Zahlen mit dem Cantorschen Diagonalisie-
rungsverfahren eindeutig codiert. Für die Erweiterung auf ein n-Tupel natürli-
cher Zahlen, wird paarcode rekursiv aufgerufen:

code : N∗ → N,

code(x1, ..., xk) = paarcode(x1, code(x2, ..., xk)) + 1

wobei code(x) = x gilt, falls x ∈ N0.

(cid:18)

------------------------------------------------------------------------
12

b)

1 Theoretische Informatik

code([2, 4]) = paarcode(2, code[4]) + 1

= paarcode(2, 4) + 1

2+4X

=

i + 4 + 1

i=0

= (0 + 1 + 2 + 3 + 4 + 5 + 6) + 4 + 1 = 26

c) Anmerkung: Ein Unterschied zwischen empty und isempty ist in der Litera-

tur nicht allgemein geltend zu ﬁnden.
Da die in Frühjahr 2002 Thema 2 Aufgabe 6b verlangten Programme primitiv-
rekursiv (äquivalent zu LOOP-Programmen) sind und die LOOP-Programme
eine echte Teilmenge der hier verlangten WHILE-Programme sind, siehe zur
Lösung der hier gestellten Aufgabe Seite 25 - dort ist lediglich pop als rest
und isempty als leer bezeichnet.

y

Aufgabe 5

Turing-
maschine

Neben der Turingmaschine mit einem beidseitig unendlichen Band gibt es auch
eine Variante, die nur ein einseitig (nach rechts) unendliches Band zur Verfügung
hat.
a) Präzisieren Sie die Deﬁnition einer solchen
b) Zeigen Sie die Aquivalenz der beiden Varianten von Turingnaschinen.

einseitigen“ Turingmaschine.
”

a) Eine komplette Lösung zu dieser Aufgabe ﬁndet sich in [REP] auf Seite 83.

b) Eine komplette Lösung zu dieser Aufgabe ﬁndet sich in [REP] auf Seite 83f.

Aufgabe 6

Aussagen-
logik,
Tautologie

Sei F die Formel (¬(A → B) ∨ ¬(¬A ∨ C)) ∧ ¬A.
a) Ist F erfüllbar? (Begründung!)
b) Ist F eine Tautologie? (Begründung!)

Bemerkung: Da diese Thematik nicht eindeutig einem der großen Kapitel zuzuord-
nen ist, ist sie dort eingeordnet, wo sie auch in den Aufgabenstellungen zu ﬁnden
ist. Als begleitende Literatur hierzu ist empfehlenswert [LOG].

a) Anmerkung zur Lösung: C → D ist aussagenlogisch äquivalent zu ¬C ∨ D.
Um F zu erfüllen, müssen beide Teilformeln links und rechts des ∧ erfüllt
werden:

1. ¬A ist nur erfüllt, wenn A =false gilt.

(cid:27)
(cid:27)
(cid:27)

------------------------------------------------------------------------
Herbst 01 - Thema 2

13

2. ¬(A → B)∨¬(¬A∨C) ⇔ ¬(¬A∨B)∨(A∧¬C) ⇔ (A∧¬B)∨(A∧¬C)
Da wegen 1.A =false gilt, kann weder (A ∧ ¬B) noch (A ∧ ¬C) erfüllt
sein.

Somit ist die erste Teilformel sicher false und damit die gesamte Formel nicht
erfüllbar.
Ein weiterer Lösungsansatz besteht darin, mit Hilfe eines Unerfüllbarkeits-
tests (s. Kapitel
erfullbarkeit der Formel
Hierzu muss zuerst die Formel in die konjunktive Normalform gebracht, also
als Konjunktion von Disjunktionen von Literalen dargestellt werden:

Resolution“ in [LOG]) vorzugehen. Hierzu muss die Un- (cid:28)
”

¬((A → B) → (¬B → ¬A)) gezeigt werden.

¨

(¬(A → B) ∨ ¬(¬A ∨ C)) ∧ ¬A
⇔ (¬(¬A ∨ B) ∨ (A ∧ ¬C)) ∧ ¬A
⇔ ((A ∧ ¬B) ∨ (A ∧ ¬C)) ∧ ¬A
⇔ ((A ∨ (A ∧ ¬C)) ∧ (¬B ∨ (A ∧ ¬C))) ∧ ¬A
⇔ A ∧ (A ∨ ¬C) ∧ (¬B ∨ A) ∧ (¬B ∨ ¬C) ∧ ¬A

Jetzt kann man diese Formel umschreiben als Formelmenge
{{A}, {A, ¬B}, {A, ¬C}, {¬B, ¬C}, {¬A}}, deren Einträge auch als Klau-
seln bezeichnet werden. Aus Klausel 1 und Klausel 5 lässt sich sofort die
Klausel {} ableiten. Somit ist die Formel F unerfüllbar.

b) Wenn F eine Tautologie wäre, müsste jede Belegung ein Modell für F sein.
Da aber nach Teilaufgabe a) F unerfüllbar ist, existiert noch nicht einmal
eine einzige Belegung, so dass F erfüllbar ist und somit kann F also keine
Tautologie sein.

Herbst 01 - Thema 2

Aufgabe 2

Gegeben sei das Alphabet Σ{0, 1} und

Z = {w ∈ Σ+|w = 0 oder w beginnt mit dem Zeichen 1}.
Jedes w = wm...w2w1w0 ∈ Z kann als Binärdarstellung der natürlichen Zahl
N (w) = wm2m + ... + w222 + w12 + w0
aufgefasst werden. Umgekehrt gibt es zu jedem n ∈ N0 eine derartige Binärdar-
stellung W (n) ∈ Z (d. h.: N (W (n)) = n).
Weiter sei die Grammatik G = (V, Σ, P, S) mit V = {S, A} und der Menge P
der Produktionen
S → 1|1A
A → 1|1A|0S
gegeben. L(G) sei die von G erzeugte Sprache.

DEA,
reguläre
Gramma-
tik,
Ableitung
eines
Wortes,
regulärer
Ausdruck,
entscheid-
bar,
reguläre,
kontextfreie
Sprache


------------------------------------------------------------------------
14

1 Theoretische Informatik

a) Geben Sie eine reguläre Grammatik (Typ 3) an, die Z erzeugt!
b) Geben Sie eine Ableitung der Zeichenreihe 11101011011 in G an.
c) Beweisen Sie: L(G) ⊆ Z.
d) Beweisen Sie: Für jedes w ∈ L(G) ist N (w) ungerade.
e) Geben Sie einen deterministischen endlichen Automaten an, der die Spra-

che L(G) akzeptiert.

f) Ist die Menge n ∈ N0|W (n) ∈ L(g) entscheidbar? Begründen Sie Ihre

Antwort.

Sei nun N ⊆ N0 die Menge aller natürlichen Zahlen
2p − 2q − 1 mit p ≥ 3 und 0 < q < p − 1
(Beispiele: 23 = 25 − 23 − 1, 59 = 26 − 22 − 1, also 23, 59 ∈ N )
und ZN = {w ∈ Z|w = W (n), n ∈ N }.

g) Beweisen Sie: W (23) ∈ L(G) und W (59) ∈ L(G).
h) Beweisen Sie: ZN ( L(G).
i) Geben Sie einen regulären Ausdruck an, der ZN beschreibt.
j) Beweisen Sie: Es gibt eine Teilmenge M von N derart, dass die Menge

ZM = {w ∈ Z|w = W (n), n ∈ M }
keine reguläre, jedoch eine kontextfreie (Typ 2-)Sprache ist.

a)

G = ({S, A}, {0, 1}, P, S)
P = {S → 0 | 1A

A → 0A | 1A | ε}

b) S → 1A → 11A → 111A → 1110S → 11101A → 111010S → 1110101A →

11101011A → 111010110S → 1110101101A → 11101011011

c) Jedes Wort aus L(G) beginnt mit 1 und enthält danach eine beliebige Kom-
bination aus 1 und 0, wobei 0 nur paarweise auftreten kann. Außerdem muss
das Wort mit 1 enden. Alleine durch die 1. Bedingung ist gesichert, dass
w ∈ L(G) ⇒ w ∈ Z.

d) Jedes Wort aus L(G) kann nur mit 1 terminieren, weil S → 1 bzw. A → 1 die
einzigen Regeln sind um ein Wort abzuschließen. Dies wiederum bedeutet,
dass ∀w∈L(G)w0 = 1.
N (w) = wm2m + · · · + w222 + w121 + w020 = wm2m + · · · + w222 + w121 + 1 =
2 ∗ (wm2m−1 + · · · + w221 + w120) + 1
Der 1. Summand von N (w) ist durch den Faktor 2 auf jeden Fall gerade und
die Addition von 1 führt dazu, dass N (w) immer ungerade ist.


------------------------------------------------------------------------
Herbst 01 - Thema 2

15

e)

δ:

S A
∅
0
S
1 A A

M = ({S, A}, {0, 1}, δ, S, {A})

f) Ja, die Menge ist entscheidbar. Wird W (n) auf das Band einer Turing-
Maschine geschrieben und steht der Schreib-/Lese-Kopf der Maschine zu
Beginn rechts von der Eingabe, so kann die TM in einem Schritt entschei-
den, ob W (n) ∈ L(G) ist: Wenn das Zeichen links vom Kopf eine 1 ist, so
ist W (n) ungerade und damit ist n Element der Menge, andernfalls nicht.

g) W (23) = 1 ∗ 24 + 1 ∗ 22 + 1 ∗ 21 + 1 = 10111
W (59) = 25 + 24 + 23 + 21 + 1 = 111011
Zum Beweis W (23) ∈ L(G) wird wieder der Ableitungsbaum verwendet:
S → 1A → 10S → 101A → 1011A → 10111
Analog für W (59):
S → 1A → 11A → 111A → 1110S → 11101A → 111011

h) ∀w∈ZN w ∈ L(G), denn w = W (n) und n ist ungerade weil n = 2p − 2q − 1.

1 ∈ L(G) aber 1 6∈ ZN , denn die kleinste Zahl aus ZN ist
23 − 23−1 − 1 = 8 − 4 − 1 = 3
⇒ ZN 6= L(G) ⇒ ZN ⊂ L(G).

i) 1(0|1)∗1

j) Eine Teilmenge von N sind alle symmetrischen Wörter. D. h. M ist die

Spiegelwortsprache:

G = ({S, A}, {0, 1}, P, S)
P = {S → 1S1

A → 1A1 | 0A0 | ε}


------------------------------------------------------------------------
16

1 Theoretische Informatik

Aufgabe 3

Komplexi-
tät,
Turing-
maschine

Mit deterministischen Turingmaschinen (DTM) lassen sich Funktionen
f : Nk
a) Präzisieren Sie formal, was es bedeutet, dass eine DTM eine derartige

0 → N0 berechnen.

Funktion berechnet mit der Vorgabe, dass alle auftretenden natürlichen
Zahlen z in Binärdarstellung W (m) (wie in Teilaufgabe 2) dargestellt sein
sollen.

b) Geben Sie eine DTM an, die in der unter a) angegebenen Weise die Funk-
tion s(n) = n + 1 berechnet. Für n ∈ N0 sei nb die Länge der Zeichenrei-
he W (n). Welche der folgenden Aussagen über die Zeitkomplexität der
Berechnung von s(z) ist richtig?
b1) Die Zeitkomplexität der Berechnung ist O(nb).
b2) Die Zeitkomplexität der Berechnung ist O(log nb).
b3) Die Zeitkomplexität der Berechnung ist O(log n).
Begründen Sie Ihre Antworten.

c) Gibt es eine andere Zahldarstellung als die Binärdarstellung, mit der die

Berechnung von s(n) konstante Zeitkomplexität hat?
Begründen Sie Ihre Antwort.

a) Dazu wird eine k-Band Turing-Maschine mit dem Eingabealphabet {0, 1}
verwendet. Sollten alle Eingaben zu Beginn auf dem ersten Band stehen, so
wird dieses abgefahren und die Einträge 2 bis k der Reihe nach auf die Bänder
2 bis k geschrieben. Auf jedem der Bänder steht dann also eine natürliche
Zahl z in ihrer Binärdarstellung. Diese Darstellung wird begrenzt von einem
Zeichen des Bandalphabets, z. B. (cid:3). Gemäß der Funktionsvorschrift von f
verarbeitet die TM nun die Eingabe und schreibt das Ergebnis wieder auf
das erste Band.
Formal sieht die Zustandsübergangsfunktion einer solchen Turingmaschine
folgendermaßen aus:

δ : Z × Γk → Z × Γk × {L, R, N }k

b)

S
δ:
(F, 1, R)
0
1
(S, 0, L)
# (F, 1, R)

F
(F, 0, R)
(F, 1, R)
(F, #, N )

M = ({S, F }, {0, 1}, {0, 1, #}, δ, S, #, {F })

Der Lesekopf steht zu Beginn am rechten Ende der Eingabe. Da Addition von
1 beim Lesen einer 0 (oder der leeren Eingabe) nur bedeutet, statt dessen eine
1 zu schreiben, wird dies entsprechend der übergang von S zu F gestaltet.
Wird eine 1 gelesen, muss eine 0 geschrieben werden und der übertrag auf


------------------------------------------------------------------------
Frühjahr 02 - Thema 1

17

der Stelle links daneben addiert werden. Hier gelten jetzt wieder genau die
drei eben beschriebenen Fälle. Bei Erreichen des Bandendes muss noch der
übertrag geschrieben werden. Anschließend läuft der Lesekopf wieder an
das rechte Ende der Eingabe, was durch den reﬂexiven übergang bei F
dargestellt wird.

Die Zeichenreihe wird also im worst case einmal von rechts nach links und
wieder zurück abgefahren. D. h. die Turing-Maschine terminiert nach 2nb
Schritten. Die Aussage b1) ist demnach korrekt.
Die Länge der Zahl n ist in Binärdarstellung maximal log n, d. h. nb ≤ log n.
Aus diesem Grund ist auch die Aussage b3) korrekt.

c) Ja, es kann auch die unäre Darstellung gewählt werden. Dabei werden ein-
fach n Striche auf das Band geschrieben. Steht der Kopf der TM zu Beginn
wieder rechts von der Eingabe, so muss nur ein weiterer Strich geschrieben
werden und die TM terminiert. Die Zeitkomplexität ist hierbei in jedem Fall
konstant, da die TM immer genau eine Operation ausführen muss.

Frühjahr 02 - Thema 1

Aufgabe 1

Sei Σ = {a, b, c} ein Alphabet. Man gebe an, von welchem Chomsky-Typ i
(mit 1 ≤ i ≤ 3) die folgenden Sprachen sind, wobei i jeweils maximal sein
soll. Zur Begründung gebe man jeweils eine erzeugende Grammatik oder einen
akzeptierenden Automaten für die Sprache an und beweise, dass die Sprache
davon erzeugt bzw. akzeptiert wird!
(i) L = {akbmcn|0 ≤ k, m, n} sowie

L0 = Σ∗ − L

(ii) L = {akbmcn|0 ≤ m < k, 0 ≤ n}
(iii) L = (Σ∗ − {ambmcn|0 ≤ m, n}) ∩ a∗b∗c∗

Chomsky-
Hierarchie,
kontext-
sensitive,
kontext-
freie,
reguläre
Sprache,
reguläre
Gramma-
tik,
Keller-
automat

(i) Für L gibt es eine reguläre Grammatik G = ({A, B, C}, {a, b, c}, P, A), wobei

P = {A → aA|B
B → bB|C
C → cC|ε}

Nur mit der ersten Regel werden a erzeugt. Diese wird genau k-mal angewen-
det und dann wird mit der zweiten Regel zur Erzeugung der b übergegangen.
Diese werden durch m-malige Anwendung der dritten Regel erzeugt. Analog
wird mit Regel 4 zur Erzeugung der c übergegangen, die durch Regel 5 ent-
stehen. Die Regeln müssen zwangläuﬁg in aufsteigender Reihenfolge durch-
laufen werden und es gibt nur eine Terminierungsmöglichkeit. Die Sprache


------------------------------------------------------------------------
18

1 Theoretische Informatik

enthält auch das leere Wort (durch Anwenden nur von Regel 2, 4 und 6) und
ist vom Chomsky-Typ 3.
G = ({A, B, C, D, E, F, G, H}, {a, b, c}, P, A), wobei

P = {A → aA|B
B → bB|C
C → cC|D|F
D → cE
E → aH|bH
F → bG
G → aH
H → aH|bH|cH|ε}

L0 enthält nicht das leere Wort und da auch die Wörter a, b und c bereits
in L enthalten sind, hat jedes Wort aus L0 mindestens Länge 2. Außerdem
besitzt jedes Wort mindestens eine Stelle, an denen zwei aufeinanderfolgende
Zeichen nicht alphabetisch geordnet sind, d. h. das Wort enthält entweder
die Kombination ca, cb oder ba. Mit den ersten fünf Regeln werden wieder
die Worte aus L erzeugt, also akbmcn (falls das Wort aus L0 ein alphabetisch
geordnetes Präﬁx besitzt). Danach muss entweder in D oder F übergegangen
werden. Mit D und E wird ca bzw. cb erzeugt, mit F und G ba. Was nach
dieser Kombination erfolgt, ist völlig egal, so dass mit H alle Kombinationen
aus a, b, c erzeugt werden.

(ii) Wegen der Bedingung, dass m < k sein muss, kann die Sprache nicht mehr

regulär sein. G = ({A, C}, {a, b, c}, P, A), wobei
P = {A → aA|aAb|aC
C → cC|ε}

(iii) Zur Verdeutlichung der durch Mengenbeziehungen festgelegten Sprache wird

zuerst ein Venn-Diagramm gezeichnet:

Eine alternative Darstellung von L ist also L = {akbmcn|k 6= m, 0 ≤ k, m, n}
Es wird ein Kellerautomat konstruiert, der mit dem akzeptierenden Endzu-
stand F terminiert.


------------------------------------------------------------------------
Frühjahr 02 - Thema 1

19

Funktionswert
Zustand Keller

Parameter
Zustand Eingabe Keller
a
a
b
b
c
b
b
c
b
c
ε
ε

S
S
C
B
C
C
B
C
C
C
F
F
M = ({S, B, C, F }, Σ, {A, #}, δ, S, #)

#
A
#
A
A
#
A
A
#
A
A
#

S
S
S
S
S
B
B
B
C
C
C
C

A#
AA
#
ε
A
#
ε
A
#
A
ε
#

Aufgabe 2

Welche Sprache wird von folgender Chomsky-Grammatik vom Typ 1 erzeugt?

S → SA|1$1
1A → A11
$A → 0$|1$1

Hinweis: Oﬀensichtlich werden Wörter der Gestalt u$v erzeugt. Man gebe an,
wie die Teilwörter v aussehen und in welcher Beziehung jeweils das u zum v
steht - natürlich jeweils mit Beweis!

v besteht nur aus Einsen. Die Anzahl der 1en ist die unäre Darstellung (Strichco-
dierung) der Binärzahl, die durch u dargestellt wird.

Das kürzeste Wort, das erzeugt werden kann, ist 1$1.
Der weitere Beweis erfolgt mittels vollständiger Induktion über die Anzahl der
Anwendung der 1. Regel:

kontextsen-
sitive
Sprache,
kontextfreie
Gramma-
tik,
vollständige
Induktion


------------------------------------------------------------------------
20

1 Theoretische Informatik

.

i = 1:
Wird zuerst einmal die erste Regel angewendet, entsteht SA. Wendet man danach
Regel 2 an, resultiert 1$1A. Hier kann nur mit Regel 3 weitergearbeitet werden:
1$A11. Nun gibt es zwei Möglichkeiten das Wort abzuschließen: entweder 10$11
oder 11$111.
Sei nun für i = n gezeigt, dass u(2) = v(1) = 12n
n → n + 1:
Es wird einmal mehr die erste Regel angewendet, somit entsteht u$vA, wobei u$v
das für i = n erzeugte Wort ist.
Nun muss die 3. Regel wiederholt angewendet werden, damit $A auftritt. Dabei
entstehen genau doppelt so viele 1en, also 12n
. Egal ob das Wort mit
Regel 4 oder 5 abgeschlossen wird, wird auf der linken Seite ein Zeichen erzeugt.
D. h. mit u wird ein Linksshift um eine Stelle durchgeführt. Das entspricht dem
Verdoppeln der Binärzahl. Wird mit Regel 4 abgeschlossen, entsteht u0$12(n+1)
und
die Aussage ist wahr. Im anderen Fall wird durch 1$1 zu u 1 dazu addiert, aber
gleichzeitig wird auch auf der rechten Seite genau eine zusätzliche 1 erzeugt: u1$1
12(n+1)
. Auch in diesem Fall stimmt die Behauptung und damit ist die Aussage
bewiesen.

= 12(n+1)

12n

Aufgabe 3

Postsches
Korrespon-
denz-
problem

Welche der folgenden Fälle des Postschen Korrespondenzproblems haben eine
Lösung, welche nicht? Man gebe entweder eine Lösung oder eine Begründung
für die Nichtlösbarkeit an.
(i)
(ii)
(iii)
(iv)

(aa, aab), (bb, ba), (abb, b)
(aaa, aa), (aaaa, aaa)
(a, aaa), (abaaa, ab), (ab, b)
(ab, aba), (ba, aa), (abab,baa)

(i) Das Problem besitzt die Lösung (1, 2, 1, 3), denn es ist
x1x2x1x3 = aa|bb|aa|abb = aab|ba|aab|b = y1y2y1y3.

(ii) Das Problem ist nicht lösbar, da |xi| = |yi| + 1 für i = 1, 2. Es ist also
nicht möglich, eine Kette aus xi zu konstruieren, die gleich lang ist wie die
entsprechende Kette aus yi.

(iii) Eine mögliche Lösung ist die Folge (2, 1, 1, 3), denn es ist
x2x1x1x3 = abaaa|a|a|ab = ab|aaa|aaa|b = y2y1y1y3.

(iv) Dieses Problem ist ebenfalls unlösbar, denn damit xi1 und yi1 zumindest
im ersten Zeichen übereinstimmen, kann die Lösung weder mit i = 2 noch
i = 3 beginnen. Wird deshalb mit i = 1 begonnen, entsteht x1 = ab und
y1 = aba. Das nächste Folgenglied muss also in x mit a beginnen. Dies kann
nur durch x1x1 = abab bzw. x1x3 = ababab geschehen. Die entsprechenden y-
Folgen wären: y1y1 = abaaba bzw. y1y3 = ababaa. Diese stimmen im vierten


------------------------------------------------------------------------
Frühjahr 02 - Thema 2

21

bzw. sechsten Zeichen nicht mehr mit der x-Folge überein und somit ist das
Problem nicht lösbar.

Frühjahr 02 - Thema 2

Aufgabe 1

Sei L die Sprache aller Wörter über dem Zeichenvorrat {a, b}, die doppelt so
viele Vorkommen von ’a’ wie von ’b’ enthalten. Beweisen Sie oder widerlegen
Sie:
(i) L ist kontextsensitiv.
(ii) L ist kontextfrei.
(iii) L ist regulär.

kontext-
sensitive,
kontext-
freie,
reguläre
Sprache

(i) G = ({S, A, B}, {a, b}, P, S), wobei

P = {S → AABS|ε
AB → BA
BA → AB
A → a
B → b}

L wird von dieser kontextsensitiven Grammatik erzeugt, denn die erste Regel
stellt sicher, dass es doppelt so viele A wie B gibt und diese können dann
beliebig permutiert werden.

(ii) Für diese Sprache lässt sich auch eine kontextfreie Grammatik G angeben mit
G = ({S}, {a, b}, P, S), wobei P = {S → SaSaSbS|SaSbSaS|SbSaSaS|ε}

(iii) L ist nicht regulär. Nachweis mittels Pumping-Lemma:

Um beim Aufpumpen die Eigenschaft zu wahren, dass |w|a = 2|w|b ist, muss
gelten |v|a = 2|v|b.
Es sei nun n die Pumping-Zahl und x = a2nbn ∈ L.
Weil das Pumping-Lemma fordert, dass |uv| ≤ n ist, besteht v nur aus a. Da-
mit lässt sich für x keine Zerlegung ﬁnden, die das Pumping-Lemma erfüllt.


------------------------------------------------------------------------
22

1 Theoretische Informatik

Aufgabe 2

NEA,
DEA,
regulärer
Ausdruck

Konstruieren Sie einen vollständigen deterministischen erkennenden Automa-
ten, der genau die durch den regulären Ausdruck ab∗|(ac)∗ gegebene Sprache
über dem Zeichenvorrat {a, b, c} akzeptiert!

Zuerst wird der nichtdeterministische Automat erstellt:

q0
{q1, q2}
∅
∅

q1
∅
{q1}
∅

q2
∅
∅
{q3}

q3
{q2}
∅
∅

a
b
c

M = ({q0, q1, q2, q3}, {a, b, c}, δ, q0, {q0, q1, q3})

Dann wird der Potenzmengenalgorithmus angewendet:
Initialisierung: Z = {{q0}}, ZH = {{q0}}

Zustandsübergänge Zustandsmenge
δ({q0}, a) = {q1, q2},
δ({q1, q2}, b) = {q1},
δ({q1, q2}, c) = {q3}
δ({q1}, b) = {q1}
δ({q3}, a) = {q2}
δ({q2}, c) = {q3}

Z = {{q0}, {q1, q2}}
Z = {{q0}, {q1, q2}, {q1}, {q3}}

Z = {{q0}, {q1, q2}, {q1}, {q3}}
ZH = {{q3}}
Z = {{q0}, {q1, q2}, {q1}, {q2}, {q3}} ZH = {{q2}}
Z = {{q0}, {q1, q2}, {q1}, {q2}, {q3}} ZH = ∅

Hilfsmenge
ZH = {{q1, q2}}
ZH = {{q1}, {q3}}

Alle nicht aufgeführten Zustände führen in den Fehlerzustand F ,
d. h. Z = {{q0}, {q1, q2}, {q1}, {q2}, {q3}, F }.
Endzustände sind {q0}, {q1, q2}, {q1} und {q3}.


------------------------------------------------------------------------
Frühjahr 02 - Thema 2

23

Aufgabe 3

Zeigen Sie die äquivalenz der beiden regulären Ausdrücke

• b|a(ba)∗bb
• (ab)∗b

vollständige
Induktion,
regulärer
Ausdruck

Es wird der zweite Ausdruck betrachtet, α1 = (ab)nb mit n ∈ N0:
Für n = 0 ist (ab)0b = b und dies entspricht dem anderen Ausdruck
α2 = b|a(ba)mbb für den 1. Fall, so dass α2 = b.
Für n = 1 ist α1 = abb = a(ba)0bb = α2 für m = n − 1 = 0.
Sei für n gezeigt, dass (ab)nb = ab(ab)n−1b = a(ba)n−1bb.
Für n + 1 gilt: (ab)n+1b = ab(ab)nb = aba(ba)n−1bb = a(ba)nbb
Somit ist die äquivalenz der beiden Ausdrücke bewiesen.

Aufgabe 4

Beweisen Sie: Ist f : N2 → N primitiv rekursiv, so ist auch g : N → N mit

primitiv rekursiv.

g(n) =

nP

i=1

f (i, n)

primitiv

rekursiv

Die Addition add(x, y) sowie die Nachfolgerfunktion succ(n) sind primitiv rekursiv
(s. [DUD]).

Wir betrachten die Funktion sumbis(n, f (i, n)) =

zeigen, dass sie primitiv rekursiv ist.

nP

i=1

f (i, n), von der wir jetzt

(cid:28)

------------------------------------------------------------------------
24

1 Theoretische Informatik

sumbis(succ(n), f (i, succ(n))) =
= add(sumbis(n, f (i, succ(n))), f (succ(n), succ(n)))

Da laut Aufgabenstellung f (m, n) primitiv rekursiv ist, ist auch g(n) als Kombi-
nation primitiv rekursiver Funktionen selbst primitiv rekursiv.

Aufgabe 5

entscheid-
bar,
Turing-
maschine

Zeigen Sie, dass die Präﬁxrelation
(präﬁx(u, v) :↔ ∃w ∈ {a, b}∗ : uw = v) auf {a, b}∗ entscheidbar ist.

Die Entscheidbarkeit der Präﬁx-Relation ist gleichbedeutend damit, dass es eine
terminierende Turingmaschine für die Präﬁx-Relation gibt, unter deren Schreib-
/Lesekopf am Ende entweder 0 (d. h. w 6∈ L) bzw. 1 (d. h. w ∈ L) steht.
Die Eingabe steht zu Beginn folgendermaßen auf dem Band: #u#v# und der Kopf
sei ganz links.
M = (Z, {a, b}, {a, b, $ #}, δ, Z0, #, {Z+}), Z = {Z0, Z1, Z2, Z3, Z4, Z5, Z6, ZF }

Start
Z0
δ
(Z1,$, R)
a
(Z2,$, R)
b
# (ZF , 1, N )
$

suche a
Z1
(Z1, a, R)
(Z1, b, R)
(Z3, #, R)

suche b
Z2
(Z2, a, R)
(Z2, b, R)
(Z4, #, R)

prüfe a
Z3
(Z5,$, L)
(ZF , 0, N )
(ZF , 0, N )
(Z3,$, R)

prüfe b
Z4
(ZF , 0, N )
(Z5,$ , L)
(ZF , 0, N )
(Z4,$, R)

laufe zurück
Z6
Z5
(Z6, a, L)
(Z6, b, L)

(Z6, #, L)
(Z5,$, L)

(Z0,$, R)


------------------------------------------------------------------------
Frühjahr 02 - Thema 2

Aufgabe 6

25

Seien paarcod : N2 → N; q1, q2 : N → N gegebene primitiv rekursive Funktionen
mit paarcod(x,y) = z ↔ q1(z) = x; q2(z) = y für alle x, y, z.
a) Zeigen Sie, dass die durch (x ∈ N, y ∈ N∗, ε leere Folge)

• c : N∗ → N, c(ε) = 0, c(hxi ◦ y) = paarcod(x,c(y)) + 1

gegebene Funktion c bijektiv ist.

primitiv
rekursiv,
bijektive
Funktion,
Kellerope-
ration,
Paarungs-
funktion

b) Für Zahlenfolgen hy1, ..., yki und Zahlen x seien die Kelleroperationen

Push, Top, Rest, Leer charakterisiert durch:
• Push(x, hy1, ..., yki) = hx, y1, ..., yki
• Top(hy1, ..., yki) = y1
• Rest(hy1, ..., yki) = hy2, ..., yki
• Leer(hy1, ..., yki) = if k = 0 then true else false

Beschreiben Sie primitiv rekursive Funktionen push, top, rest, leer, die
entsprechende Operationen auf den Codewerten c(y) von Zahlenfolgen y
ausführen.

a) Prinzipiell ist die Paarungsfunktion paarcod nur für zwei Parameter deﬁ-
niert, kann aber auf ein n-Tupel erweitert werden. Die Funktion c ist diese
Erweiterung auf beliebig viele Eingabeparameter, also Werten aus N ∗. Dabei
wird die Paarungsfunktion mehrfach hintereinander angewendet: zuerst auf
die letzten beiden Werte, dann auf dieses Ergebnis +1 und den drittletzten
Wert, danach wiederum auf das Ergebnis +1 der letzten Rechnung und den
nächsten Wert usw.
Die Funktion paarcod ist bijektiv, da q1 und q2 zusammen die Umkehrfunk-
tion zu paarcod bilden und diese bekanntlich nur für bijektive Funktionen
existiert.
Um zu zeigen, dass c bijektiv ist, muss gezeigt werden, dass c sowohl injektiv
als auch surjektiv ist. c ist injektiv, da es aus der bijektiven, also insbesonde-
re injektiven Funktion paarcod besteht und auch die Addition von 1 nichts
an dieser Eindeutigkeit ändert. paarcod ist somit als Konkatenation zweier
injektiver Funktionen bijektiv.
Der Wertebereich von paarcod ist laut Aufgabenstellung gleich N und da
c(ε) = 0 und c(x) ≥ 1 für x 6= ε gilt, ist der Wertebereich von c ebenfalls
ganz N. Damit ist c surjektiv, also auch bijektiv. Bijektive Funktionen be-
sitzen eine eindeutige Umkehrfunktion, die in diesem Fall lautet:
c−1(z) = (q1(z − 1) ◦ q2(c−1(z − 1))) und c−1(0) = ε

b) push(x, y) = paarcod(x, c(y)) + 1

top(y) = q1(y − 1)
rest(y) = q2(y − 1)
Sei sub(n, m) die in Frühjahr 2001 Thema 1 Aufgabe 3a) (siehe Seite 5) als x


------------------------------------------------------------------------
26

1 Theoretische Informatik

primitiv rekursiv gezeigte modiﬁzierte Subtraktion, dann gilt
leer(y) = sub(1, c(y)).

Aufgabe 7

Aussagen-
logik,
Tautologie

a) Beweisen Sie: (A → B) → (¬B → ¬A) ist eine Tautologie.
b) Folgt aus {(A → B), ¬A}, {(¬A ∨ B), ¬A} die Formel ¬B?
c) Formalisieren Sie aussagenlogisch die folgenden beiden Aussagen und zei-

gen Sie ihre äquivalenz:

•

•

Wenn das Kind durstig oder hungrig ist und wir den Koch erreichen,
”
so rufen wir ihn.“
Wenn das Kind durstig ist, so rufen wir den Koch, fa1ls wir ihn errei-
”
chen, und, wenn wir den Koch erreichen, so rufen wir ihn, wenn das
Kind hungrig ist.“

Bemerkung: Da diese Thematik nicht eindeutig einem der großen Kapitel zuzuord-
nen ist, ist sie dort eingeordnet, wo sie auch in den Aufgabenstellungen zu ﬁnden
ist. Als begleitende Literatur hierzu ist empfehlenswert [LOG].

a) Anmerkung zur Lösung: C → D ist aussagenlogisch äquivalent zu ¬C ∨ D.

(A → B) → (¬B → ¬A) ⇔ ¬(¬A ∨ B) ∨ (¬¬B ∨ ¬A)

⇔ (¬¬A ∧ ¬B) ∨ (B ∨ ¬A)
⇔ ((A ∧ ¬B) ∨ B) ∨ ((A ∧ ¬B) ∨ ¬A)
⇔ ((A ∨ B) ∧ (¬B ∨ B)) ∨ ((A ∨ ¬A) ∧ (A ∨ ¬B))
⇔ (A ∨ B) ∨ (A ∨ ¬B)
⇔ wahr

Die Formel ist also für alle Besetzungen von A und B wahr und stellt damit
eine Tautologie dar.

Bereits nach dem ersten Umformungsschritt könnte auch wie folgt argumen-
tiert werden:

(A → B) → (¬B → ¬A) ⇔ ¬(¬A ∨ B) ∨ (¬¬B ∨ ¬A)

⇔ ¬(¬A ∨ B) ∨ (¬A ∨ B)
⇔ ¬C ∨ C
⇔ wahr

Ein weiterer Lösungsansatz besteht darin, mit Hilfe eines Unerfüllbarkeits-
tests (s. Kapitel
Resolution“ in [LOG]) vorzugehen. Hierzu muss die Un-
”
erfüllbarkeit der Formel ¬((A → B) → (¬B → ¬A)) gezeigt werden.

(cid:27)
(cid:27)

------------------------------------------------------------------------
Frühjahr 02 - Thema 2

27

Hierzu muss zuerst die Formel in die konjunktive Normalform gebracht, also
Konjunktion von Disjunktionen von Literalen dargestellt werden:

¬((A → B) → (¬B → ¬A))¬(¬(A → B) ∨ (¬B → ¬A))

(A → B) ∧ ¬(¬B → ¬A))
(¬A ∨ B) ∧ ¬(B ∨ ¬A)
(¬A ∨ B) ∧ ¬B ∧ A)

Jetzt kann man diese Formel umschreiben als Formelmenge
{{¬A, B}, {¬B}, {A}}, deren Einträge auch als Klauseln bezeichnet werden.
Mit Hilfe von Klausel 1 und Klausel 2 lässt sich die Klausel {¬A} ableiten.
Diese ergibt mit Klausel 3 die Klausel {}, was gleichbedeutend damit ist,
dass die negierte ursprüngliche Formel unerfüllbar ist. Dies ist wiederum
äquivalent dazu, dass die Formel selbst eine Tautologie darstellt.

b) Um zu zeigen, dass eine Formel G aus einer gegebenen Formelmenge
{F1, F2, F3, ..., Fn} folgt, kann man gleichwertig nachweisen, dass
F1 ∧ F2 ∧ F3 ∧ ... ∧ Fn ∧ G unerfüllbar ist. Deshalb betrachten wir hier nun
{(A → B), ¬A} = {(¬A ∨ B), ¬A} als die gegebene Formelmenge.
¬(¬B) = B kommt als zusätzliche Klausel hinzu. Insgesamt ergibt sich also
{(¬A ∨ B), ¬A, B} = {{¬A, B}, ¬A, B} als zu untersuchende Menge von
Klauseln. Da kein Literal gleichzeitig mit seiner Negation in dieser Menge
enthalten ist, ist {{¬A, B}, ¬A, B} unerfüllbar und es folgt, dass ¬B nicht
aus {(A → B), ¬A} gefolgert werden kann.

c) D = durstig H = hungrig E = erreichbar R = rufen

Die erste Aussage lautet: (D ∨ H) ∧ E → R
Die zweite Aussage lautet: ((D ∧ E) → R) ∨ ((E ∧ H) → R)
Zeigen der äquivalenz:

(D ∨ H) ∧ E → R ⇔ ¬((D ∨ H) ∧ E) ∨ R
⇔ ¬(D ∨ H) ∨ ¬E ∨ R
⇔ (¬D ∧ ¬H) ∨ ¬E ∨ R
⇔ (¬D ∨ ¬E) ∧ (¬E ∨ ¬H) ∨ R
⇔ ¬(D ∧ E) ∧ ¬(E ∧ H) ∨ R
⇔ (¬(D ∧ E) ∨ R) ∧ (¬(E ∧ H) ∨ R)
⇔ ((D ∧ E) → R) ∨ ((E ∧ H) → R)


------------------------------------------------------------------------
28

1 Theoretische Informatik

Herbst 02 - Thema 1

Aufgabe 1

NEA,
DEA,
Minimali-
sierung,
rechts-
lineare
Gramma-
tik,
regulärer
Ausdruck

Gegeben ist ein endlicher Automat A mit Zustandsmenge
S = {S0, S1, S2, S3, S4, S5}, Alphabet Σ = {0, 1}, Anfangszustand S0 , End-
zuständen {S4, S5} und der folgenden Zustandsübergangsfunktion:

δ(S0, 0) = S1,δ(S0, 1) = S2,δ(S1, 0) = S4,δ(S1, 1) = S5,δ(S2, 0) = S0,δ(S2, 1) = S0
δ(S3, 0) = S5,δ(S3, 1) = S4,δ(S4, 0) = S3,δ(S4, 1) = S5,δ(S5, 0) = S3,δ(S5, 1) = S4

a) Zeichnen Sie das Zustandsdiagramm des Automaten! Ist der Automat

,

deterministisch?

b) Welche Zustände sind äquivalent (mit Begründung)?
c) Konstruieren Sie einen zu A äquivalenten, minimalen deterministischen

Automaten.

d) Geben Sie eine rechtslineare Grammatik an, die die Sprache L(A) (von A)

erzeugt.

e) Geben Sie einen regulären Ausdruck mit der Sprache L(A) an!

a)

b)

Ja, der Automat ist deterministisch, da von keinem Zustand aus mit dem
selben Eingabezeichen in mehrere verschiedene Folgezustände übergegangen
werden kann.

{S0}
{S1}
{S2}
{S3}
{S4}

∗1
∗1
∗1
∗1

{S5}

∗2
∗2
∗2
∗1
{S0}

∗2

∗1
{S1}

∗2
∗1
{S2}

∗1
{S3}

Die Zustände S1 und S3 sowie S4 und S5 sind jeweils äquivalent zueinander
und können somit jeweils zusammengefasst werden:
Bemerkung: Argumentativ erhält man die äquivalenz von S4 und S5 auch da-
durch, dass man die Nachfolger dieser Zustände bei jeweils gleichem Symbol


------------------------------------------------------------------------
Herbst 02 - Thema 1

29

betrachtet: beide haben bei 0 den Nachfolger S3, während bei 1 S5 Nachfolger
von S4 ist und umgekehrt. Anschließend lässt sich die äquivalenz von S1 und
S3 daraus folgern, dass beide bei 0 und bei 1 jetzt als Nachfolger den Zustand
S45 besitzen.

c)

d) G = ({S, A, B, C}, {0, 1}, P, S), wobei

P = {S → 0A|1B
A → 0C|1C
B → 0S|1S
C → 0A|1C}

e) (1(0|1))∗0(0|1)(1|0(0|1))∗

Aufgabe 2

Gegeben sei das Alphabet Σ = {a, b} und die Sprache L = {w ∈ Σ∗|w enthält
gleich viele a wie b}
a) Geben Sie eine mehrdeutige, kontextfreie Grammatik G an, die die Sprache

L erzeugt!

b) Geben Sie für die Worte baab und abab jeweils einen Ableitungsbaum an!
c) Zeigen Sie, dass die Grammatik G nicht eindeutig (ambig) ist!
d) Gesucht ist eine eindeutige Grammatik G0, die dieselbe Sprache wie G hat!
Vervollständigen Sie dazu den folgenden Ansatz durch Hinzunahme von
fünf weiteren Produktionsregeln.
G0 = ({S, A, B}, Σ, P 0, S) wobei P 0 = {S → aB, S → bA, S → bAS, ...}

kontext-
freie,
mehrdeu-
tige
Gramma-
tik,
Ableitungs-
baum,
Produk-
tionsregel

a) G = ({S}, {a, b}, P, S), wobei

P = {S → ε|SaSbS|SbSaS}


------------------------------------------------------------------------
1 Theoretische Informatik

Anmerkung: In den Ableitungsbäumen sind jeweils die Stellen, an denen im
nächsten Schritt eine Regel angewendet wird, grau gekennzeichnet.

30

b)

c)

Das Wort baab besitzt also zwei verschiedene Ableitungsbäume, die Gram-
matik ist somit nicht eindeutig.
d) G0 = ({S, A, B}, {0, 1}, P 0, S), wobei

P 0 = {S → aB|bA|aBS|bAS

A → a|Sa
B → b|Sb}

Hiermit werden zwar genau die verlangten fünf Produktionsregeln hinzu-
gefügt, aber das leere Wort, das laut Deﬁnition zur Sprache gehört, wäre
durch diese Grammatik nicht erreichbar. ändert man dies durch eine zusätz-
liche Regel, können zwei andere entfallen, so dass man nur noch vier Regeln
hinzugefügt hätte (außer man lässt eine der beiden Regeln einfach stehen):
G0 = ({S, A, B}, {0, 1}, P 0, S), wobei

P 0 = {S → aB|bA|aBS|bAS|ε

A → Sa
B → Sb}


------------------------------------------------------------------------
LBA,
Keller-
automat,
Sprache,
kontextfreie
Gramma-
tik,
regulärer
Ausdruck

Herbst 02 - Thema 2

31

Herbst 02 - Thema 2

Aufgabe 1

Gegeben sei folgende Grammatik G über dem Alphabet Σ = {a, b, <, >}
S →< R >
R → T
L(G) beschreibt die bezüglich einer Klammer korrekt geschachtelten Wörter!
a) Geben Sie die von G erzeugte Sprache L(G) als Teilmenge von Σ∗ an!
b) Geben Sie einen geeigneten, möglichst einfachen Automaten an, der diese

R →< R >
T → aU

U → BU
U → B

B → a
B → b

Sprache L(G) akzeptiert!

c) G1 sei die Teilgrammatik aus G mit dem Startsymbol T . Beschreiben Sie

die zu L(G1) gehörenden Wörter durch einen regulären Ausdruck.

d) ändern Sie die Sprache, so dass Wörter die bezüglich zweier verschiedener

Klammern < a <> a > und < b <> b > korrekt geschachtelt sind,
akzeptiert werden! Geben Sie eine kontextfreie Grammatik G2 an!
e) Erweitern Sie den Automaten aus b), so dass die Schachtelung mit

allgemeinen Klammern < w <> w > endlicher Länge k d. h. |w| < k,
analysiert werden kann. Dabei ist w ∈ L(G1). Es soll also die öﬀnende und
die schließende Klammer durch dasselbe Wort markiert werden!

f) Können Sie eine kontextfreie Grammatik angeben, die Klammern beliebiger

Länge erlaubt? Wie sehen öﬀnende und schließende Klammern aus?

a) <n a(a|b)+ >n mit n ≥ 1

b) Die Grammatik ist kontextfrei, da auf der linken Seite nur einzelne Ter-
minalzeichen stehen. Sie ist allerdings wegen der ersten und dritten Regel
nicht regulär. Da diese Regeln nicht in reguläre Regeln umgewandelt wer-
den können, gibt es für diese Sprache keinen endlichen Automaten, sondern
maximal einen Kellerautomaten.

M = (Z, Σ, Γ, δ, S, #)
Z = {S0, S1, S2, S3, S4}
Γ = {<, #}


------------------------------------------------------------------------
32

1 Theoretische Informatik

Die Zustandsübergangsfunktion sieht folgendermaßen aus:

Parameter
Zustand Eingabe Keller
<
<
a
a
b
a
b
>
>
ε

S0
S0
S0
S1
S1
S2
S2
S2
S3
S3

#
<
<
<
<
<
<
<
<
#

Funktionswert
Zustand Keller

S0
S0
S1
S2
S2
S2
S2
S3
S3
S4

<#
<<
<
<
<
<
<
ε
ε
#

Je nachdem wie die Angabe
kann auch ein linear beschränkter Automat gebaut werden:

möglichst einfacher Automat“ zu verstehen ist,
”

M = (Z, Σ, Γ, δ, S0, #, {S7})
Z = {S0, S1, S2, S3, S4, S5, S6, S7}
Γ = {a, b, <, >, $ }

Als Begrenzungszeichen des Wortes wird # verwendet.

|

S1

S2

S0

S3

|
|
|
|<|(S1, $, R)|(S1, <, R)|
|>|
| a |
| b |
| $ |
|#|

|(S1, >, R)|(S3, $, L)|(S3, >, L)|
| (S1, a, R) |
| (S1, b, R) |
| (S2, $, L) |
|(S2, #, L)|

|
|
|
|
|(S3, <, L)|(S1, $, R)|
|
|
|
| (S3, a, L) |(S5, $, R)|(S6, $, R)|(S6, $, R)|
|(S6, $, R)|(S6, $, R)|
| (S3, b, L) |
|(S7, $, N)|
|
|(S4, $, R)|
|
|
|
|
|

S6

S4

S5

|
|
|

c) a(a|b)+
d) Es werden nur die Regeln mit den Klammern abgeändert:

S → < a < R > a > | < b < R > b >
R → < a < R > a > | < b < R > b >

e) Wenn in der vorderen und hinteren Klammer dasselbe Wort stehen soll, han-
delt es sich hier um eine Abwandlung der Copy-Sprache. Diese ist bekanntlich
kontextsensitiv und damit nur von einem LBA erkennbar. Folglich kann der
Kellerautomat aus Aufgabe b) nicht abgewandelt werden. Es muss hier mit
dem LBA weitergearbeitet werden:


------------------------------------------------------------------------
Herbst 02 - Thema 2

33

f) Anstatt innerhalb der Klammern das gleiche Wort zu verwenden, kann für
die schließende Klammer auch das gespiegelte Wort verwendet werden. Zu
der öﬀnenden Klammer < w > gehört die schließende Klammer < wR >. Da-
mit reduziert sich das Erkennen der Klammern auf die Spiegelwort-Sprache
und innerhalb der Klammern können beliebige Ausdrücke aus G1 stehen. Es
können hier beliebig viele Klammerpaare ineinander geschachtelt werden.

S → < R >
R → aRa|bRb|T
T → > U <
U → < R > |aA
A → aA|bA|a|b


------------------------------------------------------------------------
34

1 Theoretische Informatik

Frühjahr 03 - Thema 1

Aufgabe 1

regulärer
Ausdruck,
vollständige
Induktion

Beweisen Sie: L((αβ)∗α) = L(α(βα)∗) für beliebige reguläre Ausdrücke α, β!

L((αβ)∗α) = {(αβ)nα | n ∈ N0} sowie L(α(βα)∗) = {α(βα)n | n ∈ N0}
Beweis mittels vollständiger Induktion:

Induktionsverankerung: n = 0
(αβ)0α = α = α(βα)0
Induktionsannahme: Es sei bereits gezeigt, dass (αβ)nα = α(βα)n
Induktionsschritt: n → n + 1
(αβ)n+1α = (αβ)(αβ)nα I.A.= (αβ)α(βα)n = α(βα)(βα)n = α(βα)n+1

Aufgabe 2

reguläre
Sprache,
kontextfreie
Grammatik

Betrachten Sie folgende kontextfreie Grammatik G:
S → AB|AaBb
A → aaA|ε
B → bbB|ε
a) Bestimmen Sie die durch G erzeugte Sprache!

b) Ist L(G) regulär? (Begründung!)

a) L(G) = {a2nb2m, a2n+1b2m+1 | n, m ∈ N0}

Nach Anwendung der ersten Regel können nur noch die Regeln 3 bis 6 ange-
wendet werden, die Worte der Form L(G) = a2nb2m mit n, m ∈ N0 erzeugen.
Bei Anwendung der Regel 2 wird sowohl ein a als auch ein b geschrieben und
dann können wieder nur noch die Regeln 3 bis 6 verwendet werden, die
jeweils gerade Buchstabenanzahlen hinzufügen. Dies führt zu den Worten
a2n+1b2m+1 mit n, m ∈ N0.

b) Ja, denn L(G) kann auch mit dem regulären Ausdruck

(aa)∗(bb)∗|(aa)∗a(bb)∗b beschrieben werden.


------------------------------------------------------------------------
Frühjahr 03 - Thema 1

Aufgabe 3

35

Ist die Menge der durch 7 teilbaren natürlichen Zahlen (jeweils mit Begründung)

a) entscheidbar?
b) semi-entscheidbar?
c) primitiv-rekursiv?
d) regulär?
e) rekursiv aufzählbar?

regulär,
(semi-)ent-
scheidbar,
primitiv
rekursiv,
rekursiv
aufzählbar

a) Ja, die Menge ist entscheidbar. Man kann eine TM konstruieren, die die unäre
Darstellung der Zahl auf dem Band als Eingabe hat. Nun werden immer 7
Striche in einem Durchgang gelöscht, so lange, bis das Band leer ist. Ist das
Ende der Eingabe genau dann erreicht, wenn ein Vielfaches von 7 Strichen
gelöscht wurde, so ist die Zahl durch 7 teilbar. Kann die TM nicht genau 7
Striche in einem Durchgang löschen, so gehört die Zahl nicht zur Menge.

b) Jede entscheidbare Menge ist auch semi-entscheidbar.

c) Im Folgenden werden die als primitiv-rekursiv bekannten Funktionen add
(Addition), mult (Multiplikation) und sub (modiﬁzierte Subtraktion) ver-
wendet (siehe hierzu auch Frühjahr 2001 Thema 1 Aufgabe 3a) (siehe Sei-
te 5)). Außerdem wird noch sgn (die Signumsfunktion) benötigt, die wie folgt x
primitiv-rekursiv dargestellt ist:
sgn(0) = 0
sgn(n + 1) = 1
Damit ergibt sich nun:
Die Funktion tb7 lässt sich mit Hilfe dieser Funktionen darstellen und hat
für durch 7 teilbare Zahlen das Ergebnis 1 und für alle anderen 0.
tb7(n) =
= add(mult(sgn(sub(n, 7)), tb7(sub(n, 7))), mult(sub(1, sgn(sub(n, 7))), sub(n, 6)))
Somit ist die Menge der durch 7 teilbaren natürlichen Zahlen primitiv-
rekursiv.

d) Die Menge kann mit Hilfe der unären Zahldarstellung durch den regulären

Ausdruck (|||||||)∗ beschrieben werden, ist also regulär.

e) Hier gibt es zwei Argumentationsmöglichkeiten: einerseits ist eine Sprache
genau dann rekursiv aufzählbar, wenn sie semi-entscheidbar ist (s. [THEO]
S. 116), andererseits muss es eine totale und berechenbare Funktion geben,
die alle Elemente der Menge erzeugt. In diesem Fall lautet die Funktion:
f : N0 → N0, f (n) = 7 ∗ n

(cid:28)

------------------------------------------------------------------------
36

1 Theoretische Informatik

Aufgabe 5

primitiv
rekursiv

Zeigen Sie, dass die Teilbarkeitsrelation (x teilt y ↔ ∃zx · z = y) primitiv-
rekursiv ist.

Bemerkung: Es werden hier wieder die modiﬁzierte Subtraktion sub(a, b) = a ˙−b
sowie die bereits als primitiv-rekursiv bekannte Signumsfunktion sign(x) - s. z. B.
Aufgabe 3 - verwendet.
x teilt y ↔ ∃zx · z = y
χ∃zx·z=y = sgn((x · z ˙−y) + y ˙−(x · z)) ist als Kombination primitiv-rekursiver

Funktionen selbst primitiv-rekursiv, wodurch auch die Teilbarkeitsrelation selbst
primitiv-rekursiv ist.

Aufgabe 6

Tautologie,
Aussagen-
logik,
erfüllbar

Sei F die Formel (A ∧ B) ∨ (¬A ∧ C) → B ∨ C.
a) Ist F eine Tautologie? (Begründung!)
b) Ist F erfüllbar? (Begründung!)

a)

((A ∧ B) ∨ (¬A ∧ C)) → (B ∨ C)
⇔ ¬((A ∧ B) ∨ (¬A ∧ C)) ∨ (B ∨ C)
⇔ (¬(A ∧ B) ∧ ¬(¬A ∧ C)) ∨ (B ∨ C)
⇔ (¬A ∨ ¬B) ∧ (A ∨ ¬C)) ∨ (B ∨ C)
⇔ (¬A ∧ A) ∨ (¬A ∧ ¬C) ∨ (¬B ∧ A) ∨ (¬B ∧ ¬C) ∨ (B ∨ C)
⇔ (¬A ∧ ¬C) ∨ (¬B ∧ A) ∨ (¬B ∧ ¬C) ∨ (B ∨ C)
Um zu prüfen ob F eine Tautologie ist, kann man testen, ob ¬F unerfüllbar
ist. Dazu betrachten wir die Klauselmenge zu ¬F (F ist in disjunktiver
Normalform, also ¬F in KNF):
{{¬A, ¬C}, {A, ¬B}, {¬B, ¬C}, {¬B}, {¬C}}
Nur aus Klausel 1 und Klausel 2 lässt sich eine Resolution ableiten, diese ist
identisch mit Klausel 3. Insbesondere ist also {} nicht ableitbar, ¬F somit
nicht unerfüllbar und aus diesem Grund F keine Tautologie.

b) Jede Belegung, bei der B oder C wahr ist, erfüllt F .


------------------------------------------------------------------------
37

allgemein-
gültig,
Prädikaten-
logik

Frühjahr 03 - Thema 2

Aufgabe 7

Sei F die Formel ∃x∀yP (x, y) → ∀x∃yP (y, x).

Ist F allgemeingültig? (Begründung!)

∃x∀yP (x, y) → ∀x∃yP (y, x)
⇔ ¬(∃x∀yP (x, y)) ∨ ∀x∃yP (y, x)
⇔ ¬∃x∀yP (x, y) ∨ ∀x∃yP (y, x)
⇔ ∀x¬∀yP (x, y) ∨ ∀x∃yP (y, x)
⇔ ∀x∃y¬P (x, y) ∨ ∀x∃yP (y, x)
⇔ ∀x(∃y¬P (x, y) ∨ ∀x∃yP (y, x))
⇔ ∀x(∀x∃yP (y, x) ∨ ∃y¬P (x, y))
⇔ ∀x∃y(P (y, x) ∨ ∃y¬P (x, y))
⇔ ∀x∃y(∃y¬P (x, y) ∨ P (y, x))
⇔ ∀x∃y(¬P (x, y) ∨ P (y, x))

Verwendet man als P (x, y) eine Funktion, die prüft, ob x Teiler von y ist, so steht
rechts vom Oderzeichen die Aussage
x ist nicht
Teiler von y“. Es sei nun (x, y) ∈ {((1, 2), (1, 3)}, so ist F nicht erfüllt, denn die
Oderaussage ist immer falsch. Somit ist F nicht allgemeingültig.

y ist Teiler von x“, links dagegen

”

”

Frühjahr 03 - Thema 2

Aufgabe 1

Führen Sie die Subtraktion 342 − 773 für zwei Darstellungen durch, nämlich zur
Basis 8 und 16! D. h. betrachten Sie die beiden Zahlen einmal als Oktalzahlen
und einmal als Hexadezimalzahlen und rechnen Sie jeweils das entsprechende
Ergebnis aus! Geben Sie neben dem Oktal- bzw. Hexadezimalwert des Ergeb-
nisses auch dessen Dezimalwert an!

Zahldar-
stellung

Bei der Oktaldarstellung haben die Stellen folgende Wertigkeiten:
n = nk8k + nk−18k−1 + · · · + n383 + n282 + n181 + n080 =
= nk8k + nk−18k−1 + · · · + 512n3 + 64n2 + 8n1 + n0
342 = 64 ∗ 5 + 8 ∗ 2 + 6 = 5268
173 = 64 ∗ 2 + 8 ∗ 5 + 5 = 2558

526
−255
251


------------------------------------------------------------------------
38

1 Theoretische Informatik

Analog gilt für die Hexadezimaldarstellung:
n = nk16k + nk−116k−1 + · · · + n3163 + n2162 + n1161 + n0160 =
= nk16k + nk−116k−1 + · · · + 256n2 + 16n1 + n0
342 = 256 ∗ 1 + 16 ∗ 5 + 6 = 15616
173 = 16 ∗ 10 + 13 = AD16

1 5 6
− A D
A 9

Dezimal lautet das Ergebnis 342 − 173 = 169.

Aufgabe 4

Chomsky-
Hierarchie

Ordnen Sie die folgenden formalen Sprachen in die Chomsky-Hierarchie ein:
a)

i) {an|n ≥ 0}
ii) {anbn|n ≥ 0}
iii) {anbncn|n ≥ 0}
iv) {anbncndn|n ≥ 0}

b) Beweisen Sie Ihre Aussage für ii)! Dazu müssen Sie nachweisen, dass die

Sprache in der von Ihnen angegebenen Klasse liegt (etwa durch Angabe ei-
ner Grammatik), nicht aber in der nächstkleineren Klasse.

a)

i) Typ-3, regulär
ii) Typ-2, kontextfrei

iii) Typ-1, kontextsensitiv

iv) Typ-1, kontextsensitiv

b) Eine Typ-2-Grammatik für Lii lautet:

G = ({S}, {a, b}, P, S)
P = {S → aSb | ε}

Der Beweis, dass Lii nicht vom Typ-3 ist, erfolgt über das Pumping-Lemma.
Angenommen, Lii wäre regulär und n die Pump-Zahl. Dann ließe sich jedes
Wort x in uvw zerlegen, so dass uviw ∈ Lii. Desweiteren muss gelten |uv| ≤ n
und |v| ≥ 1.
Es wird das Wort x = anbn betrachtet. Für die Zerlegung muss nun gelten
uv ⊆ an also auch v ⊆ an. O. B. d. A. v = a, u = an−1.
∀i∈Nuviw = an−1aibn 6∈ Lii
Das Pumping-Lemma ist also nicht erfüllt und damit ist Lii nur von Typ-2
und nicht von Typ-3.


------------------------------------------------------------------------
Frühjahr 03 - Thema 2

Aufgabe 5

39

N bezeichnet die natürlichen Zahlen.
a) Deﬁnieren Sie präzise den Begriﬀ der Abzählbarkeit einer Menge und stellen
Sie ihn einer präzisen Deﬁnition des Begriﬀs der rekursiven Aufzählbarkeit
einer Menge gegenüber!

b) Skizzieren Sie den Beweis der Abzählbarkeit der Menge Nn aller Folgen mit

maximal n Elementen (für festes n)!

c) Skizzieren Sie den Beweis der überabzählbarkeit der Menge NN aller

unendlichen Folgen.

rekursiv
aufzählbar,
abzählbar

a) Deﬁnition rekursive Aufzählbarkeit: (nach [THEO], S. 116)

Eine Sprache A ⊆ Σ∗ heißt rekursiv aufzählbar, falls A = ∅ oder falls es eine
totale und berechenbare Funktion f : N → Σ∗ gibt, so dass

A = {f (0), f (1), f (2), . . . }

Dabei ist f (i) = f (j) zulässig.
Deﬁnition Abzählbarkeit: (nach [THEO], S. 117)
Eine Sprache A ⊆ Σ∗ heißt abzählbar, falls A = ∅ oder falls es eine totale
Funktion f : N → Σ∗ gibt, so dass

A = {f (0), f (1), f (2), . . . }
Bei der Abzählbarkeit wird also nicht die Berechenbarkeit der Funktion ver-
langt.

b) vgl. Herbst 01 Thema 1 Aufgabe 4 auf Seite 11

Zuerst wird die Cantorsche Paarungsfunktion deﬁniert:
(siehe http://de.wikipedia.org/wiki/Cantorsche Paarungsfunktion)

x

paarcode : N2 → N,

paarcode(x, y) =

x+yX

i=0

i + y ∀x, y, ∈ N0

Damit werden zwei natürliche Zahlen mit den Cantorschen Diagonalisie-
rungsverfahren eindeutig codiert.
Für die Erweiterung auf ein n-Tupel natürlicher Zahlen, wird paarcode re-
kursiv aufgerufen:
code : Nn → N,

code(x1, ..., xn) = paarcode(x1, code(x2, ..., xn)) + 1

wobei code(x) = x gilt, falls x ∈ N0.
Für ein n-Tupel terminiert diese Rekursion also nach n Schritten.

c) Wenn jetzt ein unendliches Tupel codiert werden soll, kann diese Rekursion
nicht mehr terminieren. In jedem Schritt wird wieder genau eine Stelle co-
diert, nachdem es aber unendlich viele Stellen sind, benötigt die Funktion
unendlich viele Rekursionsaufrufe.

(cid:28)
(cid:28)
(cid:18)

------------------------------------------------------------------------
40

1 Theoretische Informatik

Aufgabe 6

Turing-
Maschine

Ein Turing-Maschinen-Programm ist eine Folge von Quintupeln:

(Zustand, gelesenes Bandsymbol, Folgezustand, geschriebenes Bandsymbol,
Kopfbewegungsrichtung)
Geben Sie ein Programm an, das zwei beliebige positive, ganze Zahlen addiert!
Sie dürfen sich die Repräsentation der Zahlen und ihre Anordnung auf dem
Band aussuchen. Wählen Sie weise: Ihre Wahl bestimmt die Komplexität des
Programms erheblich! Beschreiben Sie die von Ihnen gewählte Darstellung und
das Programm hinreichend.

Anmerkung: In der Literatur ﬁndet sich die Beschreibung einer Turing-Maschine
meist als 7-Tupel, denn die Alphabete werden auch mit dazu genommen!

S
(F, #, R)
∅
∅

1
#
(cid:3)

F
(F, 1, R)
(F, #, R)
(F, (cid:3), N )

M = ({S, F }, {1, #}, {1, #, (cid:3)}, δ, S, {F }, (cid:3))

Die Turing-Maschine bekommt als Eingabe die zwei Zahlen in unärer Darstellung,
getrennt durch #, also a#b. Der Kopf steht zu Beginn links von der Eingabe. Im
ersten Schritt wird die erste 1 gelöscht. Danach wird nach rechts gelaufen, die #
wird durch 1 ersetzt und am Ende des zweiten Worts stehen geblieben.

Herbst 03 - Thema 1

Aufgabe 4

NEA,
DEA,
Ableitung
eines
Wortes

Gegeben sei die Grammatik G = (V, Σ P, S) mit V = {S, A, B} und der Menge
P der Produktionen:
L(G) sei die von G erzeugte Sprache!
a) Beweisen oder widerlegen Sie: 11011 ∈ L(G)
b) Beweisen oder widerlegen Sie: 11010 ∈ L(G)

S → 0|0A|1S|1B

B → 1S|1B.

A → 1|1A


------------------------------------------------------------------------
Herbst 03 - Thema 1

41

c) Konstruieren Sie direkt aus G zunächst einen nichtdeterministischen endli-
chen Automaten, der die Sprache L(G) akzeptiert, und daraus einen deter-
ministischen endlichen Automaten, der ebenfalls L(G) akzeptiert!

(rechts-)re-
guläre
Grammatik

d) Beweisen Sie: L(G) =

L(1, m)

S

m∈N0

a) S → 1B → 11S → 110A → 1101A → 11011

⇒ 11011 ∈ L(G)

Da die Grammatik rechtsregulär ist, wächst
das Wort von links nach rechts, d. h. es muss
ein Zeichen nach dem anderen erzeugt wer-
den:

An den markierten Stellen muss nach der
Grammatik zwangsläuﬁg eine 1 folgen, ob-
wohl eine 0 benötigt würde. Es gibt für 11010
folglich keinen Ableitungsbaum und damit
11010 6∈ L(G).

b)

c) nichtdeterministisch:

deterministisch:

d) L(G) =

S

m∈N0

L(1, m) → die Sprache enthält also genau die Worte, die genau

eine 0 enthalten. Der Automat zeigt, dass genau eine 0 in den Worten von
L(G) enthalten ist, denn um in den Endzustand zu gelangen muss entweder


------------------------------------------------------------------------
42

1 Theoretische Informatik

der übergang ({S}, 0) → {A, F } oder ({B, S}, 0) → {A, F } verwendet wer-
den. Diese beiden übergänge können nur einmal durchlaufen werden, da von
Endzustand kein übergang zu {S} bzw {B, S} möglich ist. Jedes Wort muss
also zwangsläuﬁg genau eine 0 enthalten und damit ist die Aussage gezeigt.

S

n∈N0

L(n, m) regulär (vom Typ 3).

Aufgabe 5

Beweisen Sie:
Für jedes m ∈ N0 ist die Sprache Lm =

reguläre
Sprache,
endlicher
Automat

Die Sprache Lm =

S

n∈N0

L(n, m) enthält genau diejenigen Worte, die genau eine

vorgegebene Anzahl von Einsen enthalten. Angelehnt an den Automaten von Teil-
aufgabe 4c) lässt sich für jedes m ∈ N0 in folgender Weise ein endlicher Automat
konstruieren, der die gewünschte Sprache erkennt:

Somit ist Lm regulär.

Aufgabe 6

NEA,
DEA,
Ableitung
eines
Wortes,
(rechts-)-
reguläre
Grammatik

Beweisen Sie, dass für beliebige n, m ∈ N0 mit n ≤ m gilt:
a) Zu jedem w = 0w0 ∈ L(n, m) gibt es k ∈ N0, v ∈ L(k, k) und v0 ∈ Σ∗

mit w = 0v1v0.

b) Zu jedem w = 0w0 ∈ L(n, n) gibt es k, j ∈ N0, v ∈ L(k, k) und v0 ∈ L(j, j)

mit w = 0v1v0.

a) Argumentative Lösung: w beginnt mit einer Null, so dass die Anzahl der
Nullen in w0 echt kleiner ist als die Anzahl der Einsen, wobei w0 nach An-
gabe mindestens eine 1 enthalten muss. Falls w0 mit einer 1 beginnt, kann
k = 0 gewählt werden. Beginnt nun w0 mit einer 0, so ﬁnden sich sicher
für k folgende Nullen noch genügend Einsen im Restwort, um die gestellte
Bedingung zu erfüllen.


------------------------------------------------------------------------
Herbst 03 - Thema 1

43

Formale(re) Lösung: 0w ⇒ n ≥ 1

Induktionsanfang:

L(0, m): Wörter w mit w = 01m

⇒ k = 0, v = ε, v0 = 1m−1
⇒ w = 0ε11m−1

Induktionsvoraussetzung: L(n − 1, m) sei gezeigt

Induktionsschritt:

(n − 1) → n
Betrachte L(n, m) mit 0w0
nach Aufgabe 2 (s. im Kapitel
”
auf Seite 134):
w0 ∈ {1w00|w00 ∈ L(n − 1, m − 1)
}

|

{z
k=0

Algorithmen und Datenstrukturen“

x

} ∪ {0w00| w00 ∈ L(n − 2, m)
}
}

{z

|

|

∃k00 :w00= v0
|{z}
k00
{z
k0=k00+1

1v

}

b) Argumentative Lösung: w beginnt mit einer Null, so dass die Anzahl der
Nullen in w0 genau um eins kleiner ist als die Anzahl der Einsen, wobei w0
nach Angabe mindestens eine 1 enthalten muss. Falls w0 mit einer 1 beginnt,
kann k = 0 gewählt werden. v0 enthält dann jeweils n − 1 Nullen und Einsen.
Beginnt nun w0 mit einer 0, so ﬁnden sich sicher für k folgende Nullen noch
genügend Einsen im Restwort, um die gestellte Bedingung zu erfüllen. v
enthält dann zum Beispiel k = p Nullen und Einsen, was dazu führt, dass v0
noch j = n − 1 − p Einsen und Nullen enthält.
Formale(re) Lösung:
nach Teilaufgabe a) gilt: w = 0w0 ∈ L(n, m)

∃k : w = 0

1v0

v|{z}
k-mal 0

v ∈ L(k, k) ⇒ v0 ∈ L(n − 1 − k, m − 1 − k)
Sei n = m ⇒ v0 ∈ L(n − 1 − k
, n − 1 − k
) = L(j, j)
}
{z
|
}
|
j

{z
j

Aufgabe 7

Die Sprache L sei deﬁniert als L =

S

n∈N0

L(n, n).

a) Beweisen Sie: L ist nicht regulär.
b) Geben Sie eine kontextfreie (d. h. Typ-2-)Grammatik an, die L erzeugt.

reguläre
Sprache,
kontextfreie
Grammatik

a) In den Worten dieser Sprache müssten also genauso viele Nullen wie Einsen
enthalten sein. Da die Grammatik aus Teilaufgabe b) (die diese Worte er-
zeugt) die Regel S → aSb enthält, die nicht durch andere zu ersetzen ist, ist
diese Sprache nicht regulär.


------------------------------------------------------------------------
44

1 Theoretische Informatik

b) Variante 1:

S → 0S1|1S0|1A|0B|(cid:15)
A → 0A1|1A0|0S|0
B → 0B1|1B0|1S|1
Variante 2:
S → 0S1S|1S0S|(cid:15)

Aufgabe 8

Turingma-
schine,
Komplexi-
tät

Geben Sie eine deterministische Turingmaschine T an mit folgenden Eigenschaf-
ten:
a) T berechnet die Funktion
f : N0 × Σ∗ → {0, 1},
(

f (n, w) =

1, falls w ∈ L(n, 1)
0, falls w /∈ L(n, 1)

in folgendem Sinne:
Angesetzt auf das Wort 1n#w (mit n ∈ N0, w ∈ Σ∗ und Trennzeichen #)
hält T nach endlicher Zeit in einer Konﬁguration an, in der f (n, w) als Er-
gebnis auf dem Arbeitsfeld steht. Geben Sie ausführliche Erläuterungen
zur Wirkungsweise Ihrer Lösung!

b) Die Anzahl der Rechenschritte von T für eine Eingabe der unter a) genann-

ten Art ist O(n2). Begründen Sie diese Aussage für Ihre Lösung!

a) T = (Z, Σ, Γ, δ, q0, #, F )

Z4

Z6

Z0

Z3
(Z4, 0, N )
(Z5, 1, R)
(Z4, 0, N )

Z5
(Z4, 0, N )
(Z4, 0, N )
(Z6, #, L)

Z1
(Z2, #, L)
(Z1, 1, R)
(Z1, #, R)

δ
0
(Z1, 0, R)
1
# (Z3, #, R)

Z2
(Z0, #, R)
(Z2, 1, L)
(Z2, #, L)
Z = {Z0, Z1, Z2, Z3, Z4, Z5, Z6}, Σ = {0, 1}, Γ = {0, 1, #}, F = {Z4, Z6}
T liest eine links vom Trennzeichen stehende 1, ersetzt sie durch eine Null
und fährt im Zustand Z1 so lange nach rechts bis eine 0 erscheint. Diese
wird gelöscht und dann im Zustand Z2 nach links gewandert, um die dort
am Anfang der Einserkette stehende 0 zu löschen. Nach Abarbeiten der n
Einsen dürfte dann rechts des Trennzeichens nur noch eine 1 stehen. Dies
wird nun mit Hilfe der restlichen Zustände überprüft. Steht nur noch eine
1 auf dem Band (also rechts daneben #), so macht T einen Schritt nach
links und bleibt unter der 1 stehen. Findet T noch eine Null, so bleibt sie
bei dieser stehen.

b) Für jede der n Einsen links des Trennzeichens macht T jeweils n + 2 Schritte
nach rechts und n + 2 Schritte nach links. Anschließend sind zur Prüfung,
was sich noch auf dem Band beﬁndet, noch maximal n + len(w) + 1 Schritte
notwendig. Insgesamt ist die Anzahl der Rechenschritte von T also O(n2).


------------------------------------------------------------------------
Herbst 03 - Thema 2

45

Herbst 03 - Thema 2

Aufgabe 1

Seien die regulären Ausdrücke α = (ab2)∗ab und β = ab(bab)∗ gegeben.
a) Zeigen Sie die äquivalenz der beiden regulären Ausdrücke, also

L(α) = L(β).

b) Geben Sie eine L(α) erzeugende Grammatik an.
c) Geben Sie einen deterministischen erkennenden Automaten an, der L(β)

vollständige
Induktion,
DEA,
Gramma-
tik,
regulärer
Ausdruck

akzeptiert.

a) zu zeigen ist: (ab2)nab = ab(bab)n für alle n ∈ N0
Induktionsvoraussetzung: n = 0 ⇒ εab = ab = abε
Induktionsannahme: (ab2)nab = ab(bab)n gelte für n
Induktionsschluss:
(ab2)(n+1)ab = ab2(ab2)nab = ab2ab(bab)n = ab(bab)(bab)n = ab(bab)(n+1)

b) G = ({S}, {a, b}, {S → abbS|ab}, S)

c)

M = (Z, Σ, δ, S, {F })
Z = {S, A, B, C, F }
Σ = {a, b}

S A B
S
∅ B ∅

a A ∅
b

Aufgabe 2

Sei L die Sprache aller Wörter über {a, b}, die aba als Teilwort enthalten.
Konstruieren Sie einen deterministischen erkennenden Automaten für L!

Sprache,DEA

M = (Z, Σ, δ, S, {Z3})
Z = {Z0, Z1, Z2, Z3}
Σ = {a, b}

Z0 Z1 Z2 Z3
a Z1 Z1 Z3 Z3
b Z0 Z2 Z0 Z3


------------------------------------------------------------------------
46

1 Theoretische Informatik

Aufgabe 3

Turing-
maschine,
charakteris-
tische
Funktion

Konstruieren Sie eine Turing-Maschine, die die Präﬁxrelation präﬁx auf Σ∗ mit
Σ = {0, 1} entscheidet, d. h. die charakteristische Funktion charpräﬁx berechnet
(x präﬁx y : ↔ x ist Anfangsstück von y).

Variante 1:
(cid:3) z1z2...zm
}
{z
x

|

(cid:3)

|

# zm+1...zk
}
{z
y

Die Turingmaschine prüft nun wie folgt, ob y mit x beginnt:
Im Zustand Z0 sucht sie das nächste (nicht gelöschte) Zeichen in x. Ist dies 0 (1),
wird es gelöscht, die Turingmaschine geht in den Zustand Z1 (Z 0
1) über und fährt
mit dem Lesekopf bis #. Nun prüft sie in Z2 (Z 0
2) das nächste Zeichen in y. Falls
dies 0 (1) ist, wird es gelöscht und der Lesekopf fährt zurück über # (Z3) zum
ersten noch nicht gelöschten Zeichen (Z4) und beginnt von vorne. Erreicht Sie
beim Fahren vom ersten Zeichen nach rechts #, so ist die Präﬁxbedingung erfüllt
und die Turingmaschine geht in den Endzustand Z5 über.

Z0
(Z1, $, R)
0
1, $, R)
(Z

δ
0
1
$
# (Z5, 1, N )
Z = {Z0, Z1, Z2, Z 0

Z1
(Z1, 0, R)
(Z1, 1, R)

(Z2, #, R)
1, Z 0

Z2
(Z3, $, L)
(F, 0, N )
(Z2, $, R)
(F, 0, N )

0
Z
1
0
1, 0, R)
0
1, 1, R)

(Z
(Z

(Z

0
2, #, R)

0
Z
2
(F, 0, N )
(Z3, $, L)
0
(Z
2, $, R)
(F, 0, N )

Z3

(Z3, $, L)
(Z4, #, L)

Z4
(Z4, 0, L)
(Z4, 1, L)
(Z0, $, R)

2, Z3, Z4, Z5, F }, Σ = {0, 1, $}, Γ = {0, 1, $, #}, F = {F }


------------------------------------------------------------------------
Herbst 03 - Thema 2

47

Variante 2:
Konstruiere Turing-Maschine M = (Z, Σ, Γ, δ, q0, #, F ):

δ
0
1
#

q0
(q1, #, R)
(q5, #, R)
(q7, 1, N )

q1
(q1, 0, R)
(q1, 1, R)
(q2, #, R)

q2
(q3, #, L)
(q8, 0, N )
(q2, #, R)

q3
(q4, 0, L)
(q4, 1, L)
(q3, #, L)

q4
(q4, 0, L)
(q4, 1, L)
(q0, #, R)

q5
(q5, 0, R)
(q5, 1, R)
(q6, #, R)

q6
(q8, 0, N )
(q3, #, L)
(q6, #, R)

Z = {q0, q1, q2, q3, q4, q5, q6, q7, q8}, Σ = {0, 1}, Γ = {0, 1, #}, F = {q7, q8}

Auf dem Band steht anfangs x#y und der Schreib/Lesekopf steht auf dem ersten
Zeichen von x. Zum Schluss steht der Schreib/Lesekopf unter der Ausgabe der
Funktion, entweder 0 oder 1.

Aufgabe 4

Zeigen Sie die Korrektheit der (aussagenlogischen) Regel
Aus A → ¬B kann man auf B → ¬A schließen“
”

Aussagen-
logik

(Auch hier wiederum der Hinweis auf [LOG] als begleitende Literatur.)
(A ⇒ B) ⇔ (B ∨ A) ⇔ (A ∨ B) ⇔ (B ⇒ A)
Zur Erläuterung die Wahrheitstabellen von X ⇒ Y und dem dazu äquivalenten
Ausdruck Y ∨ X:

X ⇒ Y
w w
w
f
f
w
w w
f
f
w
f

∨ X
Y
w w f
f
f
f
w w w
w w
f

Zu beachten ist, dass sich bei der Implikation nur dann der Wahrheitswert f ergibt,
wenn etwas Wahres etwas Falsches impliziert. Insbesondere kann etwas Falsches
korrekterweise sowohl etwas Falsches als auch etwas Wahres implizieren!

(cid:28)

------------------------------------------------------------------------
48

1 Theoretische Informatik

Frühjahr 04 - Thema 1

Aufgabe 1

NEA,DEA,
Minimali-
sierung,
Potenzmen-
genalgo-
rithmus,
regulärer
Ausdruck

Gegeben sei ein nichtdeterministischer endlicher Automat
N1 = ({q0, q1, q2, q3, q4, q5}, {a, b}, δ, q0, {q2})
wobei δ durch folgende Tabelle deﬁniert ist. Z. B. geht der Automat aus dem
Zustand q0 (Auswahl der Spalte) durch Lesen eines
a“ (Auswahl der Zeile) in
”
die Zustände q0 oder q3 über:

δ
a
b
ε

q0
{q0, q3}
{q1}
{q4}

q1
{q2}
{q5}
∅

q2
{q2}
{q5}
∅

q3
{q0}
{q1}
∅

q4
{q4}
{q1}
∅

q5
{q5}
{q5}
∅

a) Zeichnen Sie den gegebenen nichtdeterministischen endlichen Automaten.
b) Wandeln Sie den nichtdeterministischen endlichen Automaten N1 durch

Anwendung der Teilmengenkonstruktion in einen deterministischen endli-
chen Automaten D1 um. Zeichnen Sie D1.

c) Wenden Sie den Table-Filling-Algorithmus oder ein anderes Verfahren zur
Minimalisierung auf D1 an und fassen Sie alle äquivalenten Zustände zu-
sammen. Zeichnen Sie den resultierenden Automaten.

d) Welche Sprache erkennen die Automaten? Geben Sie einen möglichst kur-

zen regulären Ausdruck zur Beschreibung dieser Sprache an!

a)

b) Bevor bei dieser Aufgabe der Potenzmengenalgorithmus angewendet werden
kann, muss erst ε-Freiheit vorliegen. Auch für die Reduzierung eines endli-
chen Automaten zur Schaﬀung von ε-Freiheit gibt es einen Algorithmus:


------------------------------------------------------------------------
Frühjahr 04 - Thema 1

49

eines

ε-freien endlichen Automaten M =
0, E0):

Bestimmung
(Z, Σ, δ, z0, E) aus dem endlichen Automaten M 0 = (Z 0, Σ0, δ0, z0
(1) Setze Z = Z 0, Σ = Σ0, δ = δ0, z0 = z0
(2) Suche einen Zustandsübergang δ(z, ε) 6= ∅.
(3) Wähle einen Zustand zf ∈ δ(z, ε) aus.
(4) Setze δ(z, x) = δ(z, x) ∪ δ(zf , x) für alle x ∈ Σ ∪ {ε} und anschließend

0, E = E0.

δ(z, ε) = δ(z, ε) − {zf }.
Falls zf ∈ E, dann bilde E = E ∪ {z}.
Gehe zu (2).

(5) Der Automat M = (Z, Σ, δ, z0, E) ist ε-frei.

Der Automat M 0 aus Teilaufgabe a) besteht aus Z 0 = {q0, q1, q2, q3, q4, q5},
Σ0 = {a, b}, z0
0 = q0, E0 = {q2} und δ0 laut Aufgabenstellung. Die Anwen-
dung des Algorithmus ergibt:
(1) Setze Z = Z 0, Σ = Σ0, δ = δ0, z0 = z0
(2) In diesem Automaten gibt es nur einen ε- übergang, nämlich

0, E = E0.

δ(q0, ε) = {q4}.
(3) Wähle q4 aus.
(4) Setze δ(q0, a) = δ(q0, a) ∪ δ(q4, a) = {q0, q3, q4} und

δ(q0, b) = δ(q0, b) ∪ δ(q4, b) = {q1} sowie δ(q0, ε) = δ(q0, ε) − {q4} = ∅.
Gehe zu (2).

(5) Es gibt keinen übergang mehr mit δ(z, ε) 6= ∅ und damit ist der Algo-
rithmus beendet. Der ε-freie Automat sieht folgendermaßen aus:

Von diesem Automaten ausgehend, kann der Potenzmengenalgorithmus an-
gewendet werden, um aus dem nichtdeterministischen einen deterministischen
Automaten zu erhalten:


------------------------------------------------------------------------
50

1 Theoretische Informatik

Potenzmengenalgorithmus
Bestimmung des deterministischen endlichen Automaten M =
(Z, Σ, δ, z0, E)
=
(Z 0, Σ0, δ0, z0
0, E0)
(1) Setze Σ = Σ0, z0 = {z0
(2) Bestimme für ein z ∈ ZH für alle x ∈ Σ

0}, Z = {z0} sowie ZH = {z0} (Hilfsmenge).

endlichen Automaten M 0

dem ε-freien

aus

δ(z, x) = {

[

z0∈z

δ0(z0, x)}

setze, falls δ(z, x) ∩ Z = ∅ und δ(z, x) 6= ∅, Z = Z ∪ δ(z, x) und
ZH = ZH ∪ δ(z, x).
(3) Bilde ZH = ZH − {z}.
(4) Falls ZH 6= ∅ gehe zu (2).
(5) E = {z ∈ Z ∧ z ∩ E0 6= ∅}.

Auf die Aufgabe angewendet ergibt sich:

• Setze Σ = Σ0, z0 = {z0
• δ({q0}, a) = {q0, q3, q4} und δ({q0}, b) = {q1} daraus ergibt sich nach

0} = {q0}, Z = {z0} sowie ZH = {{q0}}.

Schritt (2)
Z = {{q0}, {q1}, {q0, q3, q4}} und ZH = {{q0}, {q0, q3, q4}, {q1}}

• Im nächsten Schritt wird {q0} aus ZH entfernt, d. h.

ZH = {{q0, q3, q4}, {q1}}.

• Da ZH noch nicht leer ist, wird wieder bei Schritt (2) begonnen.
• Betrachte {q1}: δ({q1}, a) = {q2}, δ({q1}, b) = {q5}

{q2} und {q5} werden also zu Z und ZH hinzugefügt
Z = {{q0}, {q1}, {q2}, {q5}, {q0, q3, q4}}
ZH = {{q1}, {q0, q3, q4}, {q2}, {q5}}.

• Entferne {q1} aus ZH : ZH = {{q0, q3, q4}, {q2}, {q5}}.
• Betrachte im nächsten Durchgang {q0, q3, q4}:

δ({q0, q3, q4}, a) = {q0, q3, q4}, δ({q0, q3, q4}, b) = {q1}

Diesmal werden Z und ZH keine neuen Elemente hinzugefügt, da
δ({q0, q3, q4}, x) ∩ Z 6= ∅.

• ZH = {{q2}, {q5}}
• Betrachte {q2}: δ({q2}, a) = {q2}, δ({q2}, b) = {q5}

Wiederum entstehen keine neuen Zustände.

• ZH = {{q5}}
• Die Betrachtung von {q5} liefert: δ({q5}, a) = {q5}, δ({q5}, b) = {q5}
• ZH = ∅


------------------------------------------------------------------------
Frühjahr 04 - Thema 1

51

• An dieser Stelle bricht der Algorithmus ab und es fehlt nur noch die
Bestimmung der Endzustände. Alle neuen Zustände, die mindestens
einen alten Endzustand enthalten, sind Endzustände. In diesem Fall
also alle Zustände, die q2 enthalten. ⇒ E = {{q2}}

Damit ist ein deterministischer Automat entstanden:
M = (Z, Σ, δ, z0, E) mit Z = {{q0}, {q1}, {q2}, {q5}, {q0, q3, q4}}, Σ = {a, b},
z0 = {q0}, E = {{q2}}.
δ lässt sich in den Zwischenschritten des Algorithmus ablesen.

Als Potenzmenge bezeichnet man in der Mengenlehre die Menge aller Teil-
mengen einer gegebenen Grundmenge. Die Potenzmenge ist also ein Men-
gensystem, das heißt eine Menge, deren Elemente selbst Mengen sind. Bei
diesem Algorithmus können theoretisch alle Kombinationen von Zuständen
als neue Zustände entstehen, d. h. alle Teilmengen der Zustandsmenge Z 0.
Aus diesem Grund haben die Zustände des deterministischen Automaten
Mengenklammern und die des nichtdeterministischen nicht. Bei n Zuständen
kann der deterministische Automat bis zu 2n Zustände besitzen. Dies lässt
sich mit folgender einfachen überlegung begründen: die Wahl, ob ein be-
stimmtes Element der Menge in einer Teilmenge liegen soll oder nicht, muss
hier n-mal unabhängig voneinander durchgeführt werden.

c) Es werden jetzt in einer Tabelle alle möglichen Kombinationen von zwei
verschiedenen Zuständen betrachtet. Zu Beginn beﬁnden sich in der Tabel-
le keine Einträge. Dann werden wie unten beschrieben Markierungen der
Tabellenzellen vorgenommen.

{q1}
{q2}
{q5}
{q0, q3, q4}

∗2
∗1
∗3

{q0}

∗1
∗2
∗2
{q1}

∗1
∗1
{q2}

∗3
{q5}

1) Zuerst werden alle Zellen markiert, bei denen einer der beteiligten

Zustände ein Endzustand (hier also q2) ist.


------------------------------------------------------------------------
52

1 Theoretische Informatik

2) Nun werden alle Zellen markiert, bei denen ausgehend von der Menge
der beteiligten Zustände ein Endzustand über die übergangsfunktion
erreicht werden kann.

3) Dann werden alle Zellen markiert, bei denen ausgehend von der Menge
der beteiligten Zustände eine bereits markierte Zustandsmenge erreicht
werden kann.
Der letzte Schritt wird nun so lange wiederholt, bis sich an den Markie-
rungen nichts mehr ändert (also keine neuen hinzukommen). Zustands-
mengen, die am Ende nicht markiert sind, können zu jeweils einem
neuen Zustand (hier mit Z bezeichnet) zusammengefasst werden (hier
{{q0}, {q0, q3, q4}}). Es ergibt sich dann somit folgender Automat:

d) L(D) = a∗ba+

Aufgabe 2

(nicht)
reguläre
Sprache,
Kellerau-
tomat,
kontextfreie
Gramma-
tik,
übergangs-
diagramm

Wir betrachten die Sprache
L = {ambn; m, n ∈ N0, m < n}
a) Beweisen Sie, dass diese Sprache nicht regulär ist.

Geben Sie eine kontextfreie Grammatik an, die L erzeugt.

b) Geben Sie einen Kellerautomaten an, der die Sprache erkennt, und zeich-

nen Sie sein übergangsdiagramm.

a) Das klassische Werkzeug für den Nachweis der Nicht-Regularität ist das

Pumping-Lemma:

Sei L eine reguläre Sprache. Dann gibt es eine Zahl n, so dass sich alle Wörter
x ∈ L mit | x |≥ n zerlegen lassen in x = uvw, so dass folgende Eigenschaften
erfüllt sind:

1.
2.
3.

| v |≥ 1
| uv |≤ n
∀i∈N0 uviw ∈ L


------------------------------------------------------------------------
Frühjahr 04 - Thema 1

53

Kann man also nachweisen, dass eine Zerlegung mit den genannten Eigen-
schaften nicht existiert, so steht damit fest, dass die zu Grunde liegende
Sprache nicht regulär ist.
Es sei L = {ambn; n, m ∈ N0, m < n}.
Wähle z ∈ L, z = ambn
1. Fall: v enthalte nur den Buchstaben a. −→ Irgendwann werden durch das
Pumpen mehr a als b im Wort enthalten sein und es ist somit nicht mehr in
L enthalten. Soweit ist das gut, aber es gibt noch weitere Zerlegungsmöglich-
keiten.
Da v oﬀensichtlich keine Kombination von a und b enthalten kann, gibt es
nur noch folgende Möglichkeit.
2. Fall: v enthalte nur den Buchstaben b. −→ Es muss n ≥ m + 2 gelten,
denn für n = m + 1 und v = b versagt das Pumpen mit 0. Somit kann mittels
der Zerlegung u = am, v = b, w = bm+1 gepumpt werden.
Da es aber auch Worte der Sprache gibt, für die n ≥ m + 2 nicht gilt, kann
nicht für alle Worte eine passende Zerlegung gefunden werden und somit ist
die vorliegende Sprache nicht regulär.
Außerdem wäre auch die Argumentation über die Ableitungsregeln der Gram-
matik möglich. Dann wäre es allerdings hilfreich, zuerst den zweiten Teil der
Aufgabenstellung zu beantworten.
1) S −→ Sb | Ab
2) A −→ aAb | ε
Regel 2 verletzt durch A −→ aAb die Bedingungen für eine reguläre Gram-
matik. Da es nicht möglich ist, diese Regel in mehrere äquivalente reguläre
Regeln umzuformen, ist es auch nicht möglich eine reguläre Grammatik für
L anzugeben. L ist also nicht regulär.

b) der Kellerautomat:

M = (Z, Σ, Γ, δ, S, #), Z = {S, G, F ), Γ = {A, #}
Die Zustandsübergangsfunktion sieht folgendermaßen aus:

Parameter
Zustand Eingabe Keller
a
b
a
b
b
b
ε

#
#
A
A
A
#
#

S
S
S
S
G
G
G

Funktionswert
Zustand Keller

S
G
S
G
G
G
F

A#
#
AA
ε
ε
#
ε

Anmerkung: Es ist möglich, für Kellerautomaten explizit eine Menge von
Endzuständen anzugeben oder der Automat akzeptiert mit leerem Keller.
Beide Varianten sind korrekt (und auch äquivalent). Hier wurde mit leerem
Keller gearbeitet.


------------------------------------------------------------------------
54

1 Theoretische Informatik

Frühjahr 04 - Thema 2

Aufgabe 3

Wir betrachten den folgenden endlichen Automaten:

NEA,
DEA,
Sprache,
regulärer
Ausdruck

a) Der Automat ist nichtdeterministisch. Es gibt ein Verfahren, mit dem man
einen deterministischen aus einem nichtdeterministischen Automaten ge-
winnt.

i) Beschreiben Sie das Prinzip dieses Verfahrens kurz.
ii) Wenn der nichtdeterministische Automat n Zustände hat, wieviele Zu-
stände kann der abgeleitete deterministische Automat im schlimmsten
Fall haben?

b) Wenden Sie das Konstruktionsverfahren auf den obigen Automaten an. Mi-
nimieren Sie das Ergebnis, indem Sie alle unerreichbaren Zustände durch-
streichen. Der deterministische Automat muss nur als Graﬁk angegeben
werden.

c) Beschreiben Sie mit einem regulären Ausdruck die Sprache, die diese bei-

den Automaten erkennen.

a)

i) Ausgehend vom Startzustand werden für alle Elemente des Eingabeal-
phabets die Menge der erreichbaren Zustände betrachtet. Jede dieser
Mengen ist ein neuer Zustand. Alle erreichten Zustände werden in der
neuen Zustandsmenge gesammelt, die im jeweiligen Schritt neu hin-
zugekommenen in einer Hilfsmenge
abgelegt“. Dann wird für jeden
”
neu hinzugekommenen Zustand (also jedes Element der Hilfsmenge)
wieder die Menge der erreichbaren Zustände betrachtet und eventuelle
neue Zustände behandelt wie oben. Zustände aus der Hilfsmenge, die
in dieser Weise
abgearbeitet“ worden sind, werden aus der Hilfsmenge
”
entfernt. Dies wird solange fortgesetzt bis keine neuen Zustände mehr
entstehen und die Hilfsmenge keine Elemente mehr enthält.


------------------------------------------------------------------------
Frühjahr 04 - Thema 2

55

ii) Der deterministische Automat kann bis zu 2n Zustände besitzen.

b)

Zustandsübergänge Zustandsmenge
δ({Z}, 0) = {Z, F }
δ({Z}, 1) = ∅
δ({Z, F }, 0) = {Z, F }
δ({Z, F }, 1) = {Z, F }

ZM = {{Z}, {Z, F }} ZH = {{Z, F }}

Hilfsmenge

ZM = {{Z}, {Z, F }} ZH = ∅

c) 0(0|1)∗

Aufgabe 6

Wir betrachten die folgende Sprache symmetrischer Zeichenfolgen über dem
Alphabet {0, 1}:

{x1...xnxn...x1|n > 0 ∧ (∀i:0<i≤nxi ∈ {0, 1})

a) Zu welcher Typklasse (Typ 0-3) gehört diese Sprache?
b) Wann ist eine Grammatik eindeutig?
c) Geben Sie eine eindeutige Grammatik für die Sprache an!
d) Mit welcher Art von Automaten lässt sich diese Sprache erkennen?

Grenzen Sie die Automatenart so präzise wie möglich ein!

Chomsky-
Hierarchie,
Sprache,
eindeutige
Gramma-
tik,
nichtdeter-
ministi-
scher
Keller-
automat

a) (Zur Einordnung wird Bezug auf die Grammatik aus Teilaufgabe c) genom-

men.)
Die Sprache ist vom Typ 0, da jede Sprache mindestens von Typ 0 ist.
Die Sprache gehört zu Typ 1, da es nicht möglich ist, Wörter mit den Ab-
leitungsregeln wieder zu kürzen. Die Grammatik ist also längenmonoton.
Die Sprache ist außerdem von Typ 2, da es eine Grammatik gibt, bei der auf
der linken Seite der Regeln nur einzelne Variablen stehen.
Die Sprache ist nicht regulär, da die Wörter von vorne und hinten wachsen
müssen und dies mit regulären Regeln nicht möglich ist.

b) Eine Grammatik heißt eindeutig, wenn es für alle Worte einen eindeutigen

Ableitungsbaum gibt.

c) S → 0A0 | 1A1

A → 0A0 | 1A1 | ε


------------------------------------------------------------------------
56

1 Theoretische Informatik

d) Die Sprache wird von einem nichtdeterministischen Kellerautomaten erkannt.
Dazu wird die erste Hälfte des Worts in den Keller geschrieben und dann
mit der zweiten Hälfte verglichen. Da die Mitte des Worts nicht erkennbar
ist, kann der Kellerautomat nicht deterministisch sein.

Aufgabe 7

NP-hart,
NP-voll-
ständig,
polynomiell
reduzierbar

a) Was bedeutet es für ein Problem, NP-hart zu sein?
b) Deﬁnieren Sie präzise den Begriﬀ der NP-Vollständigkeit!
c) Begründen Sie den folgenden Satz:

(A NP-vollständig ∧ A ∈ P ) ⇔ P = N P

(vgl. [DUD] Stichwort

NP“ und [THEO])

”

a) NP ist die Menge aller Probleme, die sich nichtdeterministisch in polynomi-
eller Laufzeit lösen lassen, d. h. die Menge aller Sprachen, die von einer nicht-
deterministischen Turingmaschine in polynomieller Laufzeit erkannt werden.
Sei Σ∗ ein Alphabet, L1, L2 ⊆ Σ∗ zwei Sprachen. L1 heißt polynomiell redu-
zierbar auf L2 (L1 ≤p L2), wenn es eine Abbildung f : Σ∗ → Σ∗ gibt, die in
Polynomialzeit berechnet werden kann und es gilt: ∀ω ∈ L1 ⇐⇒ F (ω) ∈ L2
Deﬁnition:
Eine Sprache L heißt NP-hart, wenn L0 ≤p L für alle L0 ∈ NP gilt.
Wenn alle Probleme aus NP auf eine Sprache L polynomiell reduzierbar
sind, dann heißt diese Sprache NP-hart.

b) Deﬁnition:

L heißt NP-vollständig, wenn L ∈ NP und L NP-hart ist.
Durch die Eigenschaft NP-hart ist noch nichts darüber ausgesagt, in welcher
Klasse die Sprache L liegt. Falls sie in NP liegt, ist sie auch NP-vollständig.

c) Eine NP-vollständige Sprache kann nur dann in P liegen, wenn P = NP gilt,
da ja dann alle Sprachen aus NP auf A reduzierbar wären. Es ist aber ein
zentrales oﬀenes Problem, ob P = NP ist. Es wird vermutet, dass P 6= NP
ist, dies ist aber noch nicht bewiesen.

Herbst 04 - Thema 1

Aufgabe 3

NEA,
DEA,
Ableitung
eines
Wortes

Gegeben sei das Alphabet Σ = {a, b} und die Grammatik G = ({S, A, B}, Σ, P, S)
mit der Menge P der Regeln
L(G) sei die von G erzeugte Sprache.
a) Geben Sie ein Ableitung von ababab in G an.

S → aB B → b|bA A → aB

(cid:27)

------------------------------------------------------------------------
Herbst 04 - Thema 1

57

b) Beweisen Sie L(G) = {(ab)n ∈ Σ∗|n ≥ 1}.
c) Konstruieren Sie direkt aus G zunächst einen nichtdeterministischen endli-
chen Automaten, der die Sprache L(G) akzeptiert, und daraus einen deter-
ministischen endlichen Automaten, der ebenfalls L(G) akzeptiert.
d) Wieviele Zustände muss jeder deterministische endliche Automat, der
L(G) akzeptiert, mindestens haben? Begründen Sie Ihre Antwort.
e) Ersetzen Sie die Regel A → aB in G durch eine kontextfreie Regel der

Form A → x mit x ∈ {S, A, B, a, b}∗, so dass die derart veränderte Sprache
{(ab)2n+1 ∈ Σ∗|n ≥ 0}
erzeugt. Begründen Sie Ihre Antwort.

f) Die Sprachen L1 und L2 seien gegeben durch:

L1 = {(ab)n(ab)n ∈ Σ∗|n ≥ 1}, L2 = {(ab)n(ba)n ∈ Σ∗|n ≥ 1}

vollständige
Induktion,
kontextfrei,
regulär

i) Ist L1 regulär?
ii) Ist L1 kontextfrei?
iii) Ist L2 regulär?
iv) Ist L2 kontextfrei?
Begründen Sie Ihre Antworten.

a) S → aB → abA → abaB → ababA → ababaB → ababab

b) Es sind hier zwei Inklusionen zu zeigen:

|

A

(ab)n ⊆ L:
Vollständige Induktion:
Induktionsverankerung: (ab) ∈ L, denn S → aB → ab
Induktionsannahme: (ab)n ∈ L
Induktionsschritt: n → n + 1
→ (ab)nab
→ (ab)naB
(abn)
| {z }
{z
}
| {z }
∈L
Regel 2
Regel 4
| {z }
Regel 3
L ⊆ (ab)n: Jedes Wort der Sprache muss wegen Regel 1 mit a beginnen. Die
einzige Regel, die ein Wort abschließt ist Regel 2 und damit endet jedes Wort
mit b. Die einzige Alternative zum direkten übergang zum Terminal ist die
Regel 3 mit übergang zu Zustand B, der NUR durch übergang in Zustand
A fortgesetzt werden kann - hierbei wird jeweils ein ab geschrieben/erzeugt.

→ (ab)n+1 ∈ L

c) nichtdeterministisch:


------------------------------------------------------------------------
58

1 Theoretische Informatik

deterministisch:

d) Um das Wort ’ab’ (das kürzeste Wort der Sprache!) zu akzeptieren benötigt
man drei Zustände: vom Startzustand einen übergang mit a in einen zweiten
Zustand und von dort einen übergang mit b in einen dritten Zustand, der
Endzustand ist. Weniger als drei Zustände sind damit nicht möglich (und
außerdem ist der Automat oben minimal).

e) Die Regel soll nur kontextfrei und nicht regulär sein. A → abaB löst die
Aufgabe: Mit den Regeln 1 und 2 bzw. 1 und 3 wird das erste ab erzeugt;
mit der neuen Regel 4 und Regel 3 bzw. 2 wird daran abab angefügt, so dass
insgesamt eine ungerade Anzahl an ab entsteht.

f)

i. Ja, L1 ist regulär.

reguläre Grammatik:
G = ({S, A, B, C}, {a, b}, P, S), wobei

P = {S → aA
A → bB
B → aC
C → bS | b}

nichtdeterministischer Automat:

ii. Ja, denn jede reguläre Sprache ist auch kontextfrei.
iii. Nein, L2 ist nicht regulär. Nachweis durch Pumping-Lemma:

Sei n die Pump-Zahl und (ab)n(ba)n ∈ L2: dann muss es eine Zerlegung
uvw geben mit |uv| ≤ n. v muss also eine Teilmenge von (ab)n sein.
Wird v nun gepumpt, so ist die Anzahl der ab-Paare nicht mehr gleich
der Anzahl der ba-Paare und damit ist das gepumpte Wort nicht mehr
Element von L2.

iv. Ja, eine kontextfreie Grammatik für L2 ist:

G = ({S, A, B}, {a, b}, P, S), wobei

P = {S → ASB | abba

A → ab
B → ba}


------------------------------------------------------------------------
Herbst 04 - Thema 2

59

Herbst 04 - Thema 2

Aufgabe 1

Es sei E die Menge aller Wörter über dem Alphabet {0, 1}, die mit 01 enden.
a) Geben Sie einen regulären Ausdruck an, der E beschreibt.
b) Geben Sie einen deterministischen endlichen Automaten an, der E akzep-

DEA,
regulärer
Ausdruck,
Sprache

tiert!

c) Beschreiben Sie die natürlichen Zahlen, deren Binärdarstellung in E liegt,

auf andere Weise.

a) (0|1)∗01

b)

c) Es sind alle natürlichen Zahlen n mit der Eigenschaft n mod 4 = 1 (n =

4 ∗ x + 1).

Aufgabe 2

Geben Sie eine kontextfreie Grammatik an, die die Sprache
A =def {uvvRwwRuR : u, v, w ∈ {a, b}∗} erzeugt.
Dabei ist (a1a2...an)R =def an...a2a1 für alle a1a2...an ∈ {a, b}.

Sprache,
kontextfreie
Grammatik

G = ({S, A, B}, {a, b}, P, S), mit

P = {S → aSa | bSb | AA
A → aAa | bAb | ε}

Mit den ersten beiden Regel wird uuR erzeugt. Analog werden vvR und wwR mit
A erzeugt.


------------------------------------------------------------------------
60

1 Theoretische Informatik

Aufgabe 3

(Einband-)-
Turing-
maschine

Man gebe eine Turingmaschine mit einem Band an, die die Funktion
f : {0, 1}∗ → {0, 1}∗ deﬁniert durch:

(

1, falls die Anzahl der Einsen in w durch 3 teilbar ist
0 sonst

f (w) =def

berechnet.

Hierfür lässt sich sogar ein deterministischer endlicher Automat einfach angeben:

Analog dazu lässt sich auch eine Turing-Maschine M = (Z, Σ, Γ, δ, q0, (cid:3), F ) kon-
struieren:

q0
δ :
(q0, 0, R)
0
1
(q1, 1, R)
(cid:3) (q0, 1, N )

q1
(q1, 0, R)
(q2, 1, R)
(q1, 0, N )

q2
(q2, 0, R)
(q0, 1, R)
(q2, 0, N )

Z = {q0, q1, q2}, Σ = {0, 1}, Γ = {0, 1, (cid:3)}, F = {q0}
Auf dem Feld, auf das der Schreib-/Lesekopf am Ende zeigt, steht der gewünschte
Ausgabewert.

Aufgabe 4

nichtdeter-
ministi-
scher
Algorith-
mus,
Partitions-
problem,
Laufzeit

Geben Sie einen nichtdeterministischen Algorithmus an, der das Partitions-
problem P ART IT ION =def {(a1, a2, ..., am) : m, a1, a2, ..., am ∈ N∧

∃I(I ⊆ {1, ..., m} ∧

ai =

ai

P

i∈I

P

i /∈I

• Sei I = {1, . . . , m}, ¯I = ∅.
• Schleifenbeginn: während

P

i∈I

ai >

P

i6∈I

ai.

• Wähle ein beliebiges i ∈ I aus.


------------------------------------------------------------------------
Herbst 04 - Thema 2

61

• Setze I = I\{i}, ¯I = ¯I ∪ {i}.
• Prüfe, ob

ai =

ai.

P

P

i∈I

i6∈I

• Falls ja, dann beende und gebe ja aus.
• Falls nein und

P

P

ai <

ai, beende und gebe nein aus.

i∈I

i6∈I

• Sonst beginne wieder mit der Schleife.

Die Schleife wird maximal m-mal durchlaufen und hat deshalb die Komplexität
O(m). Die einzelne Anweisung vor der Schleife hat Komplexität O(1) und beein-
ﬂusst dadurch die Gesamtkomplexität nicht. In der Schleife kann die Zwischensum-
me in Variablen gespeichert werden, so dass für die Prüfung nur eine Addition,
eine Subtraktion und ein Vergleich notwendig sind. Es wird hierfür insbesondere
keine Schleife benötigt. Insgesamt hat der Algorithmus eine Komplexität O(m),
ist also nur von der Anzahl der eingegebenen Objekte abhängig.

Aufgabe 6

Ein Kaﬀeeautomat wird durch 3 Knöpfe bedient. Diese können nur gedrückt
werden, falls keine Lampe blinkt. Nach dem Einschalten mit Knopf 1 wird das
Wasser aufgeheizt, Lampe 1 blinkt. Ist dieser Vorgang beendet, so leuchtet Lam-
pe 1 und durch Druck auf Knopf 2 kann das Mahlen und Ausgießen des Kaﬀees
erreicht werden. Während dieses Vorganges blinkt Lampe 2. Durch Druck auf
Knopf 3 wird Dampf bereitet, Lampe 3 blinkt. Ist diese Aufbereitung fertig
(Lampe 3 leuchtet nun), so kann durch Knopf 2 Dampf abgelassen werden.
Während dieses Vorganges blinkt Lampe 2. Durch erneuten Druck auf Knopf
3 kann zur Kaﬀee-Ausgabe zurückgeschaltet werden, wieder blinkt Lampe 3.
Knopf 1 schaltet in jedem Modus den Automat aus. Modellieren Sie diesen
Sachverhalt durch einen Zustandsautomaten.

Zustands-
automat

Je nach Interpretation der Aufgabenstellung sind hier verschiedene Modellierungen
möglich.


------------------------------------------------------------------------
62

1 Theoretische Informatik

Frühjahr 05 - Thema 1

Aufgabe 2

regulär,
kontextfrei,
Pumping-
Lemma,
Keller-
automat

a) Was ist eine reguläre Sprache und was ist eine kontextfreie Sprache? Deﬁ-
nieren Sie die beiden Begriﬀe und erklären Sie, worin sich die beiden
Sprachklassen unterscheiden. Formulieren Sie das Pumpinglemma für regu-
läre Sprachen.

b) Gegeben sei die Sprache

L = {w ∈ {a, b}∗||w|a = |w|b, und für jedes Präﬁx p von w gilt |p|b ≤ |p|a}.
Dabei bezeichnet |w|x für einen Buchstaben x die Anzahl der Vorkommen
von x in w.
b1) Welche der folgenden Worte sind in der Sprache L enthalten:

abab, baba, aaabba, aababbab?
Begründen Sie kurz Ihre Antwort.

b2) Zeigen Sie, dass L nicht regulär ist.
b3) Zeigen Sie, dass die Sprache L kontextfrei ist, indem Sie einen Keller-
automaten K = (Z, Σ, Γ, δ, z, #, ∅) ﬁnden, der L mit leerem Keller ak-
zeptiert, und erläutern Sie kurz die Funktionsweise von K, geben Sie
eine Folge von Konﬁgurationen an, die K beim Akzeptieren des
Wortes abaabbab durchläuft.

a) (Vergleiche hierzu [THEO])

Eine Typ-1-Grammatik ist vom Typ 2 oder kontextfrei, falls für alle Regeln
w1 → w2 in P gilt, dass w1 eine einzelne Variable ist, d. h. w1 ∈ V .
Eine Typ-2-Grammatik ist vom Typ 3 oder regulär, falls zusätzlich gilt:
w2 ∈ Σ ∪ ΣV , d. h. die rechten Seiten von Regeln sind entweder einzelne

(cid:27)

------------------------------------------------------------------------
Frühjahr 05 - Thema 1

63

Terminalzeichen oder ein Terminalzeichen gefolgt von einer Variablen.
Eine Sprache L ⊆ Σ∗ heißt kontextfrei (regulär), falls es eine kontextfreie
(reguläre) Grammatik G gibt, mit L(G) = L.
Bei kontextfreien Grammatik ist es möglich, dass auf der rechten Seite der
Regeln mehrere Variablen stehen. Das Wort kann also bei der Ableitung an
mehreren Stellen wachsen. Bei regulären Grammatiken wachsen die Worte
immer von links nach rechts.

Das Pumping-Lemma für reguläre Sprachen lautet: (nach [THEO])
Sei L eine reguläre Sprache. Dann gibt es eine Zahl n ∈ N, so dass sich alle
Wörter x ∈ L mit | x |≥ n zerlegen lassen in x = uvw, so dass folgende
Eigenschaften erfüllt sind:

1) | v |≥ 1
2) | uv |≤ n
3) ∀i≥0uviw ∈ L

b) b1) baba ist nicht in L enthalten, denn für das Präﬁx p = b gilt |p|b = 1
und |p|a = 0. Auch aaabba ist oﬀensichtlich nicht in L enthalten - hier
wird zwar die Präﬁxbedingung erfült, aber im Wort w selbst sind nicht
gleich viele a und b enthalten. Die beiden anderen Worte erfüllen diese
Bedingung. Bei abab besitzen alle Präﬁxe (a, ab, aba) nicht mehr b als a
- es ist also in L enthalten. Die analoge Folgerung gilt für aababbab mit
den Präﬁxen a, aa, aab, aaba, aabab, aababb, aababba.

b2) Man betrachtet ein beliebiges Wort x = anbn aus L. Es besitzt of-
fensichtlich gleich viele a wie b. Man zerlegt es nun nach den Bedin-
gungen 1) und 2) des Pumping-Lemma in der Form x = uvw, wobei
uv = an, v = a. Versucht man nun zu pumpen, so ergibt sich für i = 0
das Wort an−1bn, das nicht aus L ist. Somit ist L nicht regulär.

b3) M = ({S, E, F }, {a, b}, {A, B, E}, δ, S, #)

Das leere Wort führt zum übergang
in den Endzustand. Jedes gelesene a
wird in den Keller geschrieben. Für
jedes gelesene b wird wieder ein a
aus dem Keller gelöscht. Somit kann
der Automat nur dann in den End-
zustand übergehen, wenn das Wort
gleich viele a und b enthält. Wird
zu irgendeinem Zeitpunkt bei leerem
Keller ein b gelesen, so geht der Au-
tomat in den Fehlerzustand über. So-
mit kann auch jedes Präﬁx des Wor-
tes nur maximal so viele b wie a be-
sitzen.

(cid:28)

------------------------------------------------------------------------
64

1 Theoretische Informatik

Parameter
Zustand Eingabe Keller
a
a
b
b
ε

#
A
A
#
#

S
S
S
S
S

Funktionswert
Zustand Keller

S
S
S
F
E

A
AA
ε
ε
#

noch zu lesendes Wort
abaabbab
baabbab
aabbab
abbab
bbab
bab
ab
b
ε

Zustand Keller

S
S
S
S
S
S
S
S
S
E

#
A
#
A
AA
A
#
A
#
#

Frühjahr 05 - Thema 2

Aufgabe 1

regulärer
Ausdruck,
Gram-
matik,
DEA

Betrachten Sie die beiden regulären Ausdrücke über dem Alphabet Σ = {a, b}:
α = ab(aab)∗, β = (aba)∗ab

a) Zeigen Sie die äquivalenz der beiden Ausdrücke d. h. L(α) = L(β).
b) Geben Sie eine Grammatik an, die L(α) erzeugt.
c) Geben Sie einen deterministischen endlichen Automaten an, der L(α)

akzeptiert.

a) zu zeigen ist: ab(aab)n = (aba)nab für alle n ∈ N0
Induktionsvoraussetzung: n = 0 ⇒ abε = ab = εab
Induktionsannahme: ab(aab)n = (aba)nab gelte für n
Induktionsschluss:
ab(aab)n+1 = ab(aab)naab I.A.= (aba)nabaab = (aba)n+1ab

b) G = ({S}, {a, b}, {S → Saab|ab}, S)

c)

M = (Z, Σ, δ, S, {F })
Z = {S, A, B, C, F }
Σ = {a, b}

S A B
S
∅ B ∅

a A ∅
b


------------------------------------------------------------------------
Frühjahr 05 - Thema 2

Aufgabe 2

65

Es seien Σ = {a, b} und Γ = {a, b, c} Alphabete. Betrachten Sie die Sprachen
L = {w ∈ Σ∗; |w|ab = |w|ba} und L0 = {w ∈ Γ∗; |w|ab = |w|ba}
aller Wörter, in denen das Teilwort ab genauso oft vorkommt, wie das Teilwort
ba. (Beachten Sie: als Wortmengen sind L und L0 identisch, aber es wird auf
unterschiedliche Alphabete Bezug genommen!)
a) Zeigen Sie, dass die Sprache L ⊆ Σ∗ regulär ist, indem Sie sowohl einen re-
gulären Ausdruck als auch einen akzeptierenden endlichen Automaten für L
angeben.

b) Zeigen Sie, dass die Sprache L0 ⊆ Γ∗ nicht regulär ist, indem Sie (beispiels-

weise) nachweisen, dass L0 unendlichen Index I(L0) in Γ∗ hat.

c) Zeigen Sie, dass die Sprache L0 ⊆ Γ∗ kontextfrei ist, indem Sie einen Keller-

automaten über Γ konstruieren, der L0 akzeptiert.

reguläre
Sprache,
regulärer
Ausdruck,
endlicher
Automat,
Keller-
automat,
kontextfreie
Sprache,
Index

a) Der reguläre Ausdruck lautet (a+b+a+|b+a+b+)∗|a∗|b∗.

b) Da die Anzahl der äquivalenzklassen gleichbedeutend mit dem Index ist,
werden im Folgenden äquivalenzklassen gesucht. In einer äquivalenzklas-
se müssen alle Wörter enthalten sein, die einen Automaten in den gleichen
Zustand (beim Kellerautomaten wie hier zusätzlich mit der gleichen Keller-
belegung) überführen. Für Wörter der Form (ab)n(ba)n entsteht z. B. die
Kellerbelegung Bn bevor die ba abgearbeitet werden. Jede dieser Kellerbe-
legungen gehört zu einer eigenen äquivalenzklasse, sodass für diese Wörter
bereits unendlich viele äquivalenzklassen existieren. Der Index ist somit un-
endlich, die Sprache also nicht regulär.


------------------------------------------------------------------------
66

c)

1 Theoretische Informatik

Aufgabe 3

Minimali-
sierungs-
operation,
µ-Operator

In dieser Aufgabe bezeichne µ den Operator der Minimalisierung, der einer
(k + 1)-stelligen (partiellen) Funktion f : Nk+1 → N eine k-stellige (partielle)
Funktion µ(f ) : Nk → N zuordnet.
a) Geben Sie die Deﬁnition von µ(f ) an, wobei Sie der genauen Beschreibung
des Deﬁnitionsbereichs besondere Beachtung schenken sollten. Insbeson-
dere: welche unterschiedlichen Gründe können dafür verantwortlich sein,
dass µ(f ) für ein (x1, ..., xk) ∈ Nk nicht deﬁniert ist?




b) Es sei nun f die zweistellige (partielle) Funktion

f (x, y) =

|x − y|
y + 3
↑
Dabei steht ↑ für

falls x 6= 3 und y 6= 3
falls x = 3
falls x 6= 3 und y = 3
undeﬁniert“. Berechnen Sie µ(f ).
”



a) Sei f eine gegebene k + 1-stellige Funktion. Die durch Anwendung des µ-

Operators auf f entstehende Funktion ist µ(f ) = g : Nk → N mit

(cid:26)

(cid:27)

g(x1, ..., xk) =

n |

f (n, x1, . . . , xk) = 0 und
∀m<n ist f (m, x1, . . . , xk) deﬁniert

.


------------------------------------------------------------------------
Herbst 05 - Thema 1

67

Hierbei wird min∅ =↑ gesetzt. Das heißt durch Anwenden des µ-Operators
können tatsächlich partielle Funktionen entstehen. Ein Grund dafür kann
sein, dass f keine Nullstellen besitzt, ein anderer, dass f zwar Nullstellen
hat, aber vor diesen Nullstellen bereits (mindestens) eine Deﬁnitionslücke
liegt. (vgl. hierzu [THEO])

b) Zur besseren übersichtlichkeit zuerst ein Auszug einer Wertetabelle von

f (x, y):
HH
y

x
HHH
0
1
2
3
4
5

0

0
1
2
↑
4
5

1

1
0
1
↑
3
4

2

2
1
0
↑
2
3

3

3
4
5
6
7
8

4

4
3
3
↑
0
1

5

5
4
3
↑
1
0

Die Nullstellen von f liegen also alle auf der Diagonalen der Wertetabelle,
treten also jeweils für x = y auf. Ab x = y = 4 ist aber die zweite Bedingung
nicht mehr erfüllt, so dass sich ergibt: µ(f ) = g(y) = min{0, 1, 2} = 0

Herbst 05 - Thema 1

Aufgabe 1

Es sei Σ = {a, b}. Für Wörter w in Σ∗ bezeichne |w| die Länge von w und
|w|x die Anzahl der Vorkommen des Symbols x ∈ Σ in w. Die Sprache L ⊆ Σ∗
enthält alle Wörter w mit der folgenden Eigenschaft |w|a = |w|b und für alle
Präﬁxe (Anfangsstücke) u von w gilt ||u|a − |u|b| ≤ 1. Beim Lesen von w von
links nach rechts unterscheiden sich die Anzahlen der a und b also um nie mehr
als 1 und am Ende sind es genauso viele a wie b.
a) Geben Sie ein Wort w ∈ L mit |w| = 10 an!
b) Geben Sie einen endlichen deterministischen Automaten für L an!
c) Geben Sie einen regulären Ausdruck für L an! Begründen Sie dabei die

determinis-
tischer
Automat,
regulärer
Ausdruck,
Pumping-
Lemma,
reguläre
Sprache,
kontextfreie
Grammatik

Korrektheit des Ausdrucks!

d) Die Sprache L0 ist deﬁniert durch L0 = {w : |w|a = |w|b und für alle Präﬁxe
u von w gilt |u|a − |u|b ≤ 1}. Zeigen Sie mit Hilfe des Pumpinglemma,
dass L0 nicht regulär ist!

e) Geben Sie eine kontextfreie Grammatik für L0 an! Erklären Sie die Funk-

tionsweise Ihrer Grammatik! Ein Beweis der Korrektheit ist nicht verlangt.

a) ababababab, bababababa oder abbabaabba

(cid:28)

------------------------------------------------------------------------
68

b)

M = (Z, Σ, δ, S0, S0)
Z = {S0, S1, S2}
Σ = {a, b}

S0
S2
S1

S1
S0
∅

S2
∅
S0

a
b

1 Theoretische Informatik

c) ((ab)|(ba))∗

Begründung:
Da immer ein a und ein b gleichzeitig eingefügt werden, ist |w|a = |w|b sicher
erfüllt. Auch der Unterschied der Anzahlen der a und b kann nie größer als 1
werden, denn sobald eines der beiden Zeichen einmal mehr vorkommt, wird
auf Grund des

paarweise Einfügens“ das andere Zeichen geschrieben.
”

d) Annahme:

L0 ist regulär. Sei w = bnan. |bnan| ≥ n. w = xyz und es gilt |y| ≥ 1, |xy| ≤ 1.
Somit besteht xy nur aus b, also xy = bm und x = bk mit 1 ≤ k ≤ m < n.
|xy2z|b = n + 1 6= n = |xy2z|a ⇒ xy2z /∈ L0
Es ergibt sich ein Widerspruch. L0 ist also nicht regulär.

e) S → aAb|bSa|SS|ε

A → bAa|S

• Das leere Wort muss in L’ enthalten sein.
• Wegen |w|a = |w|b müssen a und b gleichzeitig erzeugt werden.
• Ein Wort kann mit a starten.
• Wegen |u|a − |u|b ≤ 1} muss mit jedem a im nächsten Schritt ein

b erzeugt werden.

• Regel S → SS dient zur Erzeugung von Wörtern wie baab.

Herbst 05 - Thema 2

Aufgabe 1

determinis-
tischer
Automat,
reguläre
Sprache

Sei Ln die Sprache aller Wörter über {a, b}, für die gilt la(w) + 2lb(w) = 3n (n ∈
N0), wobei lx(w) die Anzahl der Vorkommen des Symbols x im Wort w ist.
a) Geben Sie einen deterministischen erkennenden Automaten zu L3 an.
b) Zeigen Sie, dass Ln regulär ist für jedes n ∈ N


------------------------------------------------------------------------
Herbst 05 - Thema 2

69

a)

b) Nach dem gleichen Schema kann für jedes Ln ein endlicher Automat gebaut
werden. Dieser hat auf jeden Fall auch nur endlich viele Zustände, da jedes
Wort aus (3n − 2k) a’s und 2k b’s besteht. Mit dem Startzustand ergibt sich

für die Anzahl der Zustände:

3n
2P

k=0

(3n + 1 − 2k).

Aufgabe 3

Sei gn : {a, b, c}∗ → N deﬁniert durch:

• gn(leeres Wort) = 0, gn(a) = 1, gn(b) = 2, gn(c) = 3,
• gn(ws) = 3gn(w) + gn(s)

(w ∈ {a, b, c}∗, s ∈ {a, b, c})

a) Berechnen Sie gn(abc).

bijektive,
assoziative
Funktion

b) Zeigen Sie, dass gn bijektiv ist.
c) Berechnen Sie gn−1(123).

• Sei numconc die Funktion mit numconc(x, y) = z genau dann, wenn

es Wörter u, v ∈ {a, b, c}∗ gibt mit x = gn(u), y = gn(v) und
z = gn(uv).

• Sei numlength die Funktion mit numlength(x) = Länge von gn−1(x).

d) Berechnen Sie numconc(13, 123).

e) Geben Sie einen Term t(x, y) für numconc(x, y) an, der numlength enthal-

ten darf!

f) Zeigen Sie, dass numconc assoziativ ist.

a) gn(abc) = 3gn(ab) + gn(c) = 3 · 3gn(a) + 3gn(b) + gn(c) = 9 + 6 + 3 = 18.


------------------------------------------------------------------------
70

1 Theoretische Informatik

b) Bijektivität ist (unter anderem) dann gegeben, wenn die Umkehrfunktion

gn−1 existiert. Diese kann explizit angegeben werden:

gn−1(x) =






ε
a
b
c
gn−1(x ÷ 3)c
gn−1(x ÷ 3)gn−1(x mod 3)

falls x = 0
falls x = 1
falls x = 2
falls x = 3
falls x > 3 ∧ x mod 3 = 0
sonst

c)

gn−1(123) = gn−1(123 ÷ 3)gn−1(123 mod 3) = gn−1(41)c

= gn−1(41 ÷ 3)gn−1(41 mod 3)c
= gn−1(13)gn−1(2)c
= gn−1(13 ÷ 3)gn−1(13 mod 3)gn−1(2)c
= gn−1(4)gn−1(1)gn−1(2)c
= gn−1(4 ÷ 3)gn−1(4 mod 3)gn−1(1)gn−1(2)c
= gn−1(1)gn−1(1)gn−1(1)gn−1(2)c
= aaabc

d) Um numconc(13, 123) zu berechnen, werden zunächst die Wörter u und v
benötigt, mit 13 = gn(u) und 123 = gn(v). Nach Teilaufgabe c) ist u = aaa
und v = aaabc. Daraus folgt:
numconc(13, 123) = gn(gn−1(x) · gn−1(y)) = gn(aaaaaabc) = 35 · 13 + 123 =
3282

e) In Analogie zur Lösung von Teilaufgabe d) gilt

t(x, y) = 3numlength(gn

−1(y)) · x + y.

f) Es ist zu zeigen, dass

numconc(numconc(x, y), z) = numconc(x, numconc(y, z))

numconc(numconc(x, y), z) = gn(gn−1(numconc(x, y))gn−1(z))

= gn(gn−1(gn(gn−1(x)gn−1(y)))gn−1(z))
= gn((gn−1(x)gn−1(y))gn−1(z))
= gn(gn−1(x)gn−1(y)gn−1(z))
= gn(gn−1(x)(gn−1(y)gn−1(z)))
= gn(gn−1(x)gn−1(gn((gn−1(y)gn−1(z)))))
= gn(gn−1(x)gn−1(numconc(y, z)))
= numconc(x, numconc(y, z))


------------------------------------------------------------------------
Frühjahr 06 - Thema 1

71

Frühjahr 06 - Thema 1

Aufgabe 2

Gegeben sei folgende Grammatik:
G : ({S}, {+, x, y, z}, {S → S + S, S → z, S → x, S → y}, S)

1.1. Welche Sprache L wird von G erzeugt (ohne Beweis)?
1.2. Beweisen oder widerlegen Sie: Die Grammatik G ist eindeutig.
1.3. Ist die Sprache L eindeutig? Begründen Sie Ihre Antwort.

Sprache,
eindeutige
Grammatik

1.1. Es werden alle Additionsterme mit x, y, z erzeugt: ((x | y | z)+)∗(x | y | z)

1.2. Der Ausdruck x + x + x besitzt z. B. mehrere Ableitungsbäume:

1.3. Ja, die Sprache ist eindeutig, weil eine eindeutige Grammatik mit den Pro-

duktionsregeln
S → S + x | S + y | S + z
S → x | y | z
existiert.


------------------------------------------------------------------------
72

1 Theoretische Informatik

Aufgabe 2

Sprache,
Chomsky-
Hierarchie,
Pumping-
Lemma

Gegeben sei folgende Grammatik:
G : ({S, M }, {x, #}, {S → SM x, S → #, xM → M x, #M → xx#}, S)

2.1. Welchen Typ (Namen und Nummer in der Chomsky-Hierarchie) hat die

Grammatik G?

2.2. Welche Sprache L wird von G erzeugt (ohne Beweis)?
2.3. Zu welchen Sprachtypen gehört die Sprache L und zu welchen gehört sie

nicht? Zitieren Sie, soweit möglich, die Chomsky-Hierarchie. Geben Sie an
der entscheidenden Stelle eine erzeugende Grammatik an und benutzen Sie
das entsprechende Pumping-Lemma.

2.1. Bei der Regel xM → M x steht auf der linken Seite außer der Variablen ein
Terminalzeichen, also ist die Grammatik vom Typ 1 (kontextsensitiv).

2.2. Durch Ausprobieren erhält man immer Wörter, die doppelt so viele x vor #

enthalten wie danach. Alle Wörter sind also von der Form x2n#xn.

2.3. Das Pumping-Lemma für kontextfreie Sprachen lautet (nach [THEO]):
Sei L eine kontextfreie Sprache. Dann gibt es eine Zahl n ∈ N, so dass sich
alle Wörter z ∈ L mit | z |≥ n zerlegen lassen in z = uvwxy mit folgenden
Eigenschaften:
(a) | vx |≥ 1
(b) | vwx |≤ n
(c) ∀i≥0 uviwxiy ∈ L

Sei m, n ∈ N, z = uvwxy, z = x2m#xm, | z |≥ n.
Wähle nun w = #, v = xx, x = x.
=⇒| u |= 2m − 2, | y |= m − 1
z sieht also folgendermaßen aus: z = x2m−2(xx)#(x)xm−1
Da | vx |= 3, ist die erste Eigenschaft gewährleistet.
Damit die zweite Eigenschaft erfüllt ist, muss gelten | vwx |= 4 ≤ n, also
n ≥ 4.
Das

Aufpumpen“ von z führt nun zu
”

uviwxiy = x2m−2(xx)i#(x)ixm−1

= x2m−2+2i#xm−1+i
= x2(m−1+i)#xm−1+i ∈ L

=⇒ Für alle z ∈ L mit | z |≥ 4 sind alle Eigenschaften des Pumping-Lemma

erfüllt. Es ergibt sich also kein Widerspruch und somit sind keine weiteren
Aussagen möglich.

(cid:27)

------------------------------------------------------------------------
Frühjahr 06 - Thema 1

73

Eine kontextfreie Grammatik für L ist:

G0 = ({S}, {x, #}, {S → xxSx, S → #}, S)

L ist also kontextfrei, da die Sprache durch eine kontextfreie Grammatik
erzeugt werden kann.

Somit ergibt sich die Frage: Ist L sogar regulär?
Das Pumping-Lemma für reguläre Sprachen lautet (nach [THEO]):
Sei L eine reguläre Sprache. Dann gibt es eine Zahl n ∈ N, so dass sich alle
Wörter x ∈ L mit | x |≥ n zerlegen lassen in x = uvw, so dass folgende
Eigenschaften erfüllt sind:
(a) | v |≥ 1
(b) | uv |≤ n
(c) ∀i≥0 uviw ∈ L

Sei wieder m, n ∈ N, z = uvw, z = x2m#xm, | z |= 3m + 1 ≥ n.
Nun wähle n = 3m.
1. Fall: # ∈ v

| v |≥ 1 womit die erste Eigenschaft erfüllt ist; da aber jedes z ∈ L genau
eine # enthalten muss, ist uviw 6∈ L und folglich kann die dritte Eigenschaft
nie erfüllt werden.

2. Fall: v = x und u = x2m−1, w = #xm

Wieder ist | v |≥ 1; da | uv |= 2m < 3m gilt, ist auch die zweite Eigenschaft
erfüllt.
Das Aufpumpen von z ergibt: uviw = x2m−1xi#xm 6∈ L, da die Anzahl der
x vor # nicht mehr doppelt so groß ist wie nach # und damit die dritte
Eigenschaft verletzt ist.

3. Fall: v = x und u = x2m#, w = xm−1

Um die zweite Eigenschaft | uv |= 2m + 2 ≤ 3m zu erfüllen, muss m ≥ 2
sein.
Wiederum ist die dritte Eigenschaft verletzt.
uviw = x2m#xixm−1 6∈ L, da für i > 1 nach # mehr als halb so viele x
stehen wie vor #.

Auch wenn v aus mehreren x besteht, kann die dritte Eigenschaft nie erfüllt
werden (analog zu Fall 2 und 3), so dass gezeigt ist, dass es KEINE Zerlegung
von z gibt, die das Pumping-Lemma erfüllt.
Damit ist gezeigt, dass L nicht regulär ist.
Anmerkung:
Im Sinne der Aufgabenstellung hätte das Pumping-Lemma nur für den Beweis der
Nicht-Regularität durchgeführt werden müssen.

(cid:28)

------------------------------------------------------------------------
74

1 Theoretische Informatik

Aufgabe 3

Turing-
Maschine

Eine deterministische Turingmaschine ist ein Tupel (Q, Σ, Γ, δ, q0, B, F ). Dabei
ist Q die endliche Zustandsmenge, Σ das endliche Eingabealphabet, Γ das end-
liche Bandalphabet, δ : Q × Γ → Q × Γ × {L, R, N } die übergangsfunktion,
q0 ∈ Q der Startzustand, B das Blanksymbol und F ⊆ Q eine Menge von
Endzuständen. Eine solche deterministische Turingmaschine liest also in jedem
Schritt das aktuelle Zeichen unter dem Schreib-/Lesekopf, entscheidet abhängig
vom aktuellen Zustand und dem gelesenen Zeichen, welches neue Zeichen ge-
schrieben, in welchen Folgezustand übergegangen und ob dabei der Schreib-
/Lesekopf nach rechts (R), nach links (L) oder gar nicht (N ) bewegt werden
soll.
Sei nun Σ = {0, 1} und Γ = {0, 1, B}. Konstruieren Sie eine Turingmaschine,
welche eine Zahl ungleich Null in Binärdarstellung um Eins dekrementiert und
die Zahl Null ggf. unberührt lässt.
Beachten Sie dabei die folgenden Vorgaben:
Auf dem Band steht die angegebene Zahl in Binärdarstellung mit dem nieder-
wertigsten Bit ganz rechts. Führende Nullen sind zugelassen. Beispiel für die
Dezimalzahl 13: BB00001101BB. Der Schreib-/Lesekopf steht zu Beginn auf
dem ersten B links von der Eingabe und soll auch am Ende wieder dort stehen.
Schreiben Sie die übergangsfunktion δ in Tabellenform nieder, pro Zustand eine
Spalte, pro Zeile eine Bandsymbol und dann in jeder Zeile den Folgezustand,
das zu schreibende Zeichen sowie die Kopfbewegung.

q0
(q0, 0, R)
0
1
(q0, 1, R)
B (q1, B, L)

q1
(q1, 0, L)
(q2, 0, R)
(q3, B, N )

q2
(q2, 1, R)

(q3, B, L)

q3
(q3, 0, L)
(q3, 1, L)
(q3, B, N )

Hierbei ist Q = {q0, q1, q2, q3} und F = {q3}.
Die Turing-Maschine wandert im Zustand q0 ganz nach rechts bis sie zu einem B
kommt. Dort geht sie in den Zustand q1 über und läuft nach links bis sie zur ersten
1 kommt. Diese 1 wird zu 0 und alle Nullen, die rechts von dieser 1 stehen, werden
im Zustand q2 zu 1. Dadurch ist die Zahl um 1 dekrementiert. Weil der Schreib-
/Lesekopf am Ende wieder ganz links stehen soll, läuft die Maschine im Zustand
q3 zur Ausgangsposition und bleibt stehen. Falls nur Nullen auf dem Band stehen,
kommt es nicht vor, dass die TM im Zustand q1 eine 1 liest. Irgendwann erreicht
sie das linke B und bleibt stehen.


------------------------------------------------------------------------
Frühjahr 06 - Thema 1

Aufgabe 4

75

Gegeben sei folgender nichtdeterministischer, endlicher Automat Aa:
Aa = (Q, Σ, δ, q0, {q4})
Q = {q0, q1, q2, q3, q4, q5}
Σ = {a, b}
δ ⊂ (Q×Σ)×Q, δ = {((q0, a), q1), ((q0, a), q2), ((q0, b), q3), ((q2, b), q4), ((q3, a), q4),
((q4, a), q5), ((q5, a), q4), ((q1, a), q0)}

NEA,
DEA,
regulärer
Ausdruck,
Minimal-
automat

4.1. Stellen Sie den Automaten Aa graphisch dar.
4.2. Beschreiben Sie die vom Automaten Aa akzeptierte Sprache durch einen

regulären Ausdruck (ohne Beweise).

4.3. Konstruieren Sie aus Aa eine äquivalenten deterministischen, endlichen Au-

tomaten Ab und stellen Sie ihn graphisch dar.

4.4. Ist der in 4.3. konstruierte Automat minimal? Begründen Sie Ihre Ant-

wort. Ist der Automat nicht minimal, so geben Sie den Minimalautomaten
in graphischer Form an.

4.1.

4.2. (aa)∗ab(aa)∗ | (aa)∗ba(aa)∗

4.3. Initialisierung: Z = {{q0}}, ZH = {{q0}}

Z = {{q0}, {q1, q2}, {q3}} ZH = {{q1, q2}, {q3}}

Hilfsmenge

Zustandsübergänge Zustandsmenge
δ({q0}, a) = {q1, q2}
δ({q0}, b) = {q3}
δ({q3}, a) = {q4}
δ({q3}, b) = ∅
δ({q1, q2}, a) = {q0}
δ({q1, q2}, b) = {q4}
δ({q4}, a) = {q5}
δ({qb}, b) = ∅
δ({q5}, a) = {q4}
δ({q5}, b) = ∅

Z = {{q0}, {q1, q2}, {q3},
{q4}}
Z = {{q0}, {q1, q2}, {q3},
{q4}}
Z = {{q0}, {q1, q2}, {q3},
{q4}, {q5}}
Z = {{q0}, {q1, q2}, {q3},
{q4}, {q5}}

ZH = {{q1, q2}, {q4}}

ZH = {{q4}}

ZH = {{q5}}

ZH = ∅


------------------------------------------------------------------------
76

1 Theoretische Informatik

4.4.

{q0}
{q1, q2}
{q3}
{q4}

∗2
∗2

∗1
{q5}

∗2
∗2
∗1
{q0}

∗2
∗1
{q1, q2}

∗1
{q3}

q3 und q5 können also zusammengefasst werden:

Aufgabe 5

Rucksack-
problem,
Partitions-
problem,
NP-voll-
ständig

Sei RU CKSACK := {(A, g, w, G, W )|A endliche Menge, g : A → N, w : A →
N, G ∈ N, W ∈ N} und RU CKSACK + := {(A, g, w, G, W ) ∈ RU CKSACK|∃B
⊆ A :

w(a) ≥ W }.

g(a) ≤ G ∧

P

P

a∈B

a∈B

Das Rucksackproblem besteht darin für ein gegebenes Tupel x = (A, g, w, G, W ) ∈
RU CKSACK zu entscheiden, ob x ∈ RU CKSACK + gilt.
Sei T EILE := {A|A ⊂ N endlich} und T EILE+ := {A ∈ T EILE|∃B ⊆ A :
P

P

b =

b}.

b∈A\B

b∈B
Das Teileproblem besteht darin für eine gegebene Menge A ∈ T EILE zu ent-
scheiden, ob A ∈ T EILE+ gilt. Das Teileproblem ist NP-vollständig.


------------------------------------------------------------------------
Frühjahr 06 - Thema 1

77

5.1. Beschreiben Sie einen nichtdeterministischen Algorithmus zur Lösung des
Rucksackproblems in polynomieller Zeit abhängig von der Länge der Ein-
gabe.

5.2. Zeigen Sie, dass das Teileproblem polynomiell auf das Rucksack-
problem reduziert werden kann T EILE+ ≤pol RU CKSACK +.

5.3. Schließen Sie daraus formal die NP-Vollständigkeit des Rucksackproblems.

5.1. Eine etwas ausführlichere Deﬁnition des Rucksackproblems:

Gegeben ist ein Rucksack mit maximaler Tragfähigkeit m und n Gegenständen
G1≤i≤n unterschiedlichen Gewichts g1≤i≤n sowie Werten w1≤i≤n. Packe den
Rucksack so, dass der Wert maximal wird, aber die Tragfähigkeit nicht über-
schritten wird!

(1) Lese die zu untersuchenden Werte von A ein.
(2) Setze B = ∅.
(3) Schleifenbeginn:

Wähle eines der Elemente aus A und füge es B hinzu (dies ist der
Rateschritt).

(4) Prüfe, ob mit diesem B das Rucksackproblem gelöst ist.
(5) Falls JA ausgegeben wird, gib ebenfalls JA aus und halte an.
(6) Falls NEIN ausgegeben wird, gehe wieder zum Schleifenbeginn.

5.2. Im Folgenden wird der Beweis umgekehrt geführt wie in [THEO] Kap. 3.3. (cid:28)

Desweiteren wird zur Vereinfachung nur die maximale Kapazität W betrach-
tet.

Für die Reduktion wird eine Abbildung benötigt, die in diesem Fall wie folgt

aussieht (M =

wi):

kP

i=1

(w1, w2, . . . , wk, M − W + 1, W + 1) 7−→ (w1, w2, . . . , wk, W )

Die Werte auf der linken Seite sollen nun das Teileproblem lösen. D. h. die
k + 2 Werte werden in eine Menge J und eine Menge ¯J aufgespalten, deren
Summe gleich groß ist.
M − W + 1 und W + 1 können nicht in der gleichen Menge enthalten sein,
denn

(M − W + 1) + (W + 1) = M + 2 >

kX

i=1

wi = W

O.b.d.A. sei M − W + w ∈ J

J = (M − W + 1) + M1

¯J = (W + 1) + M2

wobei M1 + M2 = M


------------------------------------------------------------------------
78

1 Theoretische Informatik

Wegen der Deﬁnition des Teileproblems gilt:

(M − W + 1) + M1 = (W + 1) + M2

M + M1 − M2 = 2W
2M1 = 2W
M1 = W

Dies bedeutet, dass die Lösung J des Teileproblems ohne M − W + 1 eine
Lösung des Rucksackproblems liefert. Weil dies allgemein für ALLE Lösungen
des Teileproblems gilt, kann dadurch auf ALLE Lösungen des Rucksackpro-
blems geschlossen werden.
Der umgekehrte Fall gilt ebenso:
Sei I eine Lösung des Rucksackproblems, d. h.

wi = W .

P

i∈I

Dann ist I ∪ {k + 1} eine Lösung des Teileproblems. (Der k + 1. Eintrag im
Vektor ist M − W + 1)
X

wi + (M − W + 1) = W + (M − W + 1) = M + 1

i∈I

Dies soll nun gleich der Summe der übrigen Werte sein:

X

i6∈I

wi + (W + 1) = (M − W ) + (W + 1) = M + 1

Weil dies erfüllt ist, kann von einer Lösung des Rucksackproblems eindeutig
auf eine Lösung des Teileproblems geschlossen werden.
Auch in dieser Richtung ist die Abbildung eindeutig und es ist
TEILE+ ≤pol RUCKSACK+.
5.3. TEILE+ ist NP-vollständig.

Dies bedeutet, dass TEILE+ NP-hart ist und TEILE+ ∈ NP.
Wegen Aufgabe 5.2. gilt auch, dass RUCKSACK+ NP-hart ist:
∀L0∈N P L0 ≤pol TEILE+ ≤pol RUCKSACK+
Aus der Teilaufgabe 5.1. ist bereits ein nicht-deterministischer Algorithmus
für RUCKSACK+ bekannt und außerdem gilt:
Ein Entscheidungsproblem gehört genau dann zur Klasse NP, wenn es einen
nicht-deterministischen Algorithmus gibt, dessen Laufzeit polynomial mit der
Problemgröße n anwächst.
Demnach ist RUCKSACK+ ∈ NP und damit NP-vollständig.


------------------------------------------------------------------------
Frühjahr 06 - Thema 2

79

Frühjahr 06 - Thema 2

Aufgabe 1

Wir ﬁxieren das Alphabet Σ = {0, 1} und deﬁnieren L ⊆ Σ∗ durch
L = {w|in w kommt genau einmal das Teilwort 0010 vor}

1. Zeigen Sie, dass L regulär ist!
2. Geben Sie die äquivalenzklassen der Myhill-Nerode äquivalenz von L

durch Repräsentanten an. (Diese äquivalenz ist deﬁniert durch
x ∼L y ⇔ ∀uxu ∈ L ⇔ yu ∈ L.)

3. Zeichnen Sie den Minimalautomaten für L.

reguläre
Sprache,
Myhill-Ne-
rode,
äquivalenz-
klasse,
Minimali-
sierung von
Automaten

1. L wird von folgendem deterministischen endlichen Automaten erkannt:

2. Jeweils die Menge von Worten, die obigen Automaten bei der Abarbeitung in
einem bestimmtem Zustand enden lässt, bildet eine äquivalenzklasse. Denn
setzt man diese Worte fort, so gelangt man bei allen mit der gleichen Menge
von Worten in einen End- bzw. einen Nichtendzustand. Man erhält somit
mit folgende äquivalenzklassen (mit jeweils einem Repräsentanten):

äquivalenzklasse
Q0
Q1
Q2
Q3
Q4
Q5
Q6
Q7
Q8

Repräsentant
1111
0110
1000
001
101000010
1100101110
00100100
10111001011000001
01111000001011100101101001

Da die Anzahl der Zustände mit der Anzahl der äquivalenzklassen oﬀen-
sichtlich übereinstimmt, handelt es sich beim obigen Automaten um einen
Minimalautomaten.


------------------------------------------------------------------------
80

1 Theoretische Informatik

3. Minimalisierung mit table-ﬁlling-Algorithmus:

q0
q1
q2
q3
q4
q5
q6
q7

x5
x4
x3
x2
x1
x1
x1
x1
q8

x4
x3
x2
x1
x1
x1
x1
q0

x3
x2
x1
x1
x1
x1
q1

x2
x1
x1
x1
x1
q2

x1
x1
x1
x1
q3

x2
x2
x2
q4

x2
x2
q5

x2
q6

Das Ergebnis von Aufgabe 2 bestätigt sich: Der Automat aus Teilaufgabe 1
ist bereits minimal.

Aufgabe 2

reguläre
Sprache,
DEA,
funktionale
Program-
mierung,
Listen

Sei Σn das Alphabet {0, 1}n. Ein Buchstabe in Σn ist also ein n-Tupel von 0en
und 1en; das Alphabet Σn hat 2n Buchstaben. Ist w ∈ Σ∗
n so bezeichne w1 das
Wort über Σ, das aus den ersten Komponenten der Buchstaben in W besteht,
formal also w1 = f (w) für den durch f ((x1, ..., xn)) = x1 deﬁnierten Homomor-
phismus f .
Analog deﬁniert man w2, w3, etc. Also gilt für w = (0, 1, 1)(1, 1, 0)(0, 0, 1)(1, 1, 1),
dass w1 = 0101, w2 = 1101, w3 = 1011. Für w ∈ Σ∗
1 bezeichne num(w) ∈ N die
Bedeutung von w aufgefasst als von rechts nach links gelesene Binärdarstellung.
Inverse“ (bis auf Nullen am Ende) von num
Also num(10110000) = 13. Die
”
bezeichnen wir mit bin, also bin(19) = 11001.

1. Zeigen Sie, dass L = {w : Σ∗

3|num(w3) = num(w1) + num(w2)} regulär

ist!

n sei u, v) ∈ Σ∗

2. Für u ∈ Σ∗ und v ∈ Σ∗
|(u, v)| = max(|u|, |v|),
num((u, v)1) = num(u), num((u, v)i+1) = num(vi) eindeutig deﬁnierte
Wort. Sei L ⊆ Σ∗
sodass (bin(n), w) ∈ L} Zeigen Sie, dass L0 regulär ist.

n+1 regulär. Es sei L0 = {w ∈ Σ∗

| es existiert n ∈ N,

n+1 das durch

n

3. Programmieren Sie die vier Funktionen bin, num, w 7→ wi und

u, v 7→ (u, v) in einer funktionalen Programmiersprache Ihrer Wahl oder
Pseudocode. Zur Beachtung: Das möglicherweise erforderliche Auﬀüllen von
v mit Nullen bei der Berechnung von (u, v) beinhaltet eine gewisse
Schwierigkeit, da v ∈ Σ∗
n für beliebiges n. Es bietet sich an, die Tupel als
Listen zu implementieren. Programmieren Sie auch ein boole’schwertige
Funktion, die die Zugehörigkeit zur in 1. deﬁnierten Sprache prüft.


------------------------------------------------------------------------
Frühjahr 06 - Thema 2

81

1. Da L regulär sein soll, muss es einen DEA geben, der L akzeptiert.

2. Für Wörter w muss gelten, w ∈ Σ∗

2. Außerdem muss gelten, dass

num(bin(n)) = num((bin(n), w)3) − num((bin(n), w)2),
also n = num(w2) − num(w1). Da nur gefordert ist, dass es ein solches
n ∈ N gibt, muss nur gelten, dass num(w2) > num(w1).


------------------------------------------------------------------------
82

1 Theoretische Informatik

3. num :: [Int] → Int

num liste = numh liste 1

numh [Int] → Int → Int
numh [] a = 0
numh liste a = a* (head liste) + numh (tail liste) (2*a)

bin :: Int → [Int]
bin binhh (binh a []) []

binh :: Int → [Int] → [Int]
binh 0 liste = 0:liste
binh a liste = binh (div a 2) (mod a 2:liste)

binhh :: [Int] → [Int] → [Int]
binhh [] liste = liste
binhh liste1 liste2 = binhh (tail liste1) (head liste1:liste2)

w1 :: [[Int]] → [Int]
w1 [] = []
w1 liste = (head (head liste)):(w1 (tail liste))

w2 :: [[Int]] → [Int]
w2 [] = []
w2 liste = (head (tail (head liste))):(w2 (tail liste))

w3 :: [[Int]] → [Int]
w3 [] = []
w3 liste = (head (tail (tail (head liste)))):(w3 (tail liste))

tupellaenge :: [Int] → Int
tupellaenge [] = 0
tupellaenge liste = 1 + (tupellaenge (tail liste))

erzeugev :: Int → [Int]
erzeugev a = erzeugevh a []

erzeugevh :: Int → [Int] → [Int]
erzeugevh 0 liste = liste
erzeugevh a liste = erzeugevh (a-1) (0:liste)


------------------------------------------------------------------------
Herbst 06 - Thema 1

83

uundv :: [Int] → [[Int]] → [[Int]]
uundv u v
| (u==[] && v==[]) = []
| (u==[] && (tail v)/=[]) = (0:(head v)) : uundv [] (tail v)
| (u==[] && (tail v)==[]) = [0:(head v)]
| (tail u/=[] && tail v==[]) =

((head u):(head v)):uundv (tail u) [erzeugev (tupellaenge (head v))]

| otherwise = ((head u):(head v)) : uundv (tail u) (tail v)

istinL :: [[Int]] → Bool
istinL a

| num(w3(a)) == num(w1(a)) + num(w2(a)) = True
| otherwise = False

Herbst 06 - Thema 1

Aufgabe 1

Anmerkungen zur Notation: Sei T(A) die von einem endlichen Automaten A =
(Z, Σ, δ, S, E) erzeugte Sprache, dann wird ˆδ : P (Z) × Σ∗ → P (Z) wie folgt
induktiv deﬁniert:

ˆδ(Z 0, ε) = Z 0 für alle Z 0 ⊆ Z

ˆδ(Z 0, ax) =

ˆδ(δ(z, a), x) für alle Z 0 ⊆ Z

S

z∈Z0

Sei nun der nicht-deterministische endliche Automat (NFA)
N = ({S, B1, B2, B3}, {a, b}, γ, {S}, {S}) mit folgender überführungsfunktion
γ gegeben:

a) Bestimmen Sie die Menge Ω = ˆδ({S}, baabb). Gilt baabb ∈ T (N )?
b) Konstruieren Sie einen deterministischen endlichen Automaten (DFA) M ,

der die Bedingung T (M ) = T (N ) erfüllt!

c) Geben Sie einen regulären Ausdruck für T (N ) an!
d) Bilden Sie zu N eine reguläre Grammatik mit L(G) = T (N )!

a) Ω = ˆδ({S}, baabb) = ˆδ(δ(S, b), aabb) = ˆδ({B1}, aabb) = ˆδ(δ(B1, a), abb) =

= ˆδ({B2}, abb) = ˆδ(δ(B2, a), bb) = ˆδ({S}, bb) ∪ ˆδ({B3}, bb) =
= ˆδ(δ(S, b), b) ∪ ˆδ(δ(B3, b), b) = ˆδ({B1}, b) ∪ ˆδ({S}, b) ∪ ˆδ({B3}, b) =

regulärer
Ausdruck,
reguläre
Gramma-
tik, NEA,
DEA,
überfüh-
rungsfunk-
tion


------------------------------------------------------------------------
84

b)

1 Theoretische Informatik

= ˆδ(δ(B1, b), ε) ∪ ˆδ(δ(S, b), ε) ∪ ˆδ(δ(B3, b), ε) =
= ˆδ({B1}, ε) ∪ ˆδ({B1}, ε) ∪ ˆδ({S}, ε) ∪ ˆδ({B3}, ε) = {B1, S, B3}
Da S als akzeptierender Endzustand in Ω enthalten ist,
gilt auch baabb ∈ T (N ).

Zustandsübergänge
γ({S}, b) = {B1}
γ({B1}, a) = {B2}
γ({B1}, b) = {B1}
γ({B2}, a) = {B3, S}
γ({B2}, b) = {B2}
γ({B3, S}, a) = ∅
γ({B3, S}, b) = {B3, S, B1}
γ({B3, S, B1}, a) = {B2}
γ({B3, S, B1}, b) = {B3, S, B1}

Zustandsmenge
ZM = {{S}, {B1}}
ZM = {{S}, {B1},
{B2}}
ZM = {{S}, {B1},
{B2}, {B3, S}}
ZM = {{S}, {B1}, {B2},
{B3, S}, {B3, S, B1}}
ZM = {{S}, {B1}, {B2},
{B3, S}, {B3, S, B1}}

Hilfsmenge
ZH = {{B1}}
ZH = {{B2}}

ZH = {{B3, S}}

ZH = {{B3, S, B1}}

ZH = ∅

c) T (N ) = ε | (b+ab∗a)+ | b+ab∗ab+(ab∗ab+)∗

d) G = (V, T, P, S) mit V = {S, A, B, C, D} , T = {a, b}

P = {S → bA | ε

A → bA | aB
B → bB | aC
C → bD | ε
D → bD | aB | ε }


------------------------------------------------------------------------
Herbst 06 - Thema 1

Aufgabe 2

85

Gegeben sei eine Grammatik für bedingte Anweisungen deren Produktionsmen-
ge unter anderem Folgendes enthält:

Anweisung
if-Anweisung

::= if-Anweisung—Andere-Anweisung
::= if Bedingung then Anweisung—

if Bedingung then Anweisung else Anweisung

Syntax-
baum,
eindeutige
und mehr-
deutige
Grammatik

Terminale sind dabei unterstrichen. Die Nicht-Terminale Andere-Anweisung und
Bedingung können mit dem gegebenen Ausschnitt der Grammatik nicht weiter
abgeleitet werden. Deuten Sie daher in den Syntaxbäumen die entsprechenden
Teilbäume mit einem Dreieck an!
a) Zeigen Sie, dass die Grammatik mehrdeutig ist, indem Sie Syntaxbäume an-

geben.

b) Wählen Sie logische Ausdrücke und Anweisungen für die Syntaxbäume aus
der vorherigen Teilaufgabe so, dass die Ausführung der zugeordneten Pro-
gramme zu verschiedenen Ergebnissen führt.
c) Wie kann diese Mehrdeutigkeit aufgelöst werden?
d) Geben Sie Produktionsregeln an, die Ihre Lösung aus Aufgabenteil c) rea-

lisieren, so dass die Grammatik eindeutig wird.

a) Für eine Produktion existieren z. B. folgende verschiedene Syntaxbäume:

i f - A n w e i s u n g

i f

B e d i n g u n g

t h e n

A n w e i s u n g

e l s e

A n w e i s u n g

i f - A n w e i s u n g

A n d e r e - A n w e i s u n g

i f

B e d i n g u n g

t h e n

A n w e i s u n g

A n d e r e - A n w e i s u n g

Variante 1


------------------------------------------------------------------------
86

1 Theoretische Informatik

i f - A n w e i s u n g

i f

B e d i n g u n g

t h e n

A n w e i s u n g

i f - A n w e i s u n g

i f

B e d i n g u n g

t h e n

A n w e i s u n g

e l s e

A n w e i s u n g

A n d e r e - A n w e i s u n g

A n d e r e - A n w e i s u n g

Variante 2

b) Der Ausdruck if x > 5 then if x < 10 then x := 7 else x := 5 lässt sich

darstellen durch:

i f - A n w e i s u n g

i f

B e d i n g u n g

t h e n

A n w e i s u n g

e l s e

A n w e i s u n g

x   >   5

i f - A n w e i s u n g

A n d e r e - A n w e i s u n g

x   : =   5

i f

B e d i n g u n g

t h e n

A n w e i s u n g

x   <   1 0

Variante 1

A n d e r e - A n w e i s u n g

x   : =   7

Für x < 5 ist, ergibt Variante 1 bei der Auswertung des Ausdrucks als Er-
gebnis x := 5. Bei Variante 2 hingegen wird x unverändert gelassen.

c) Mehrdeutigkeit kann aufgelöst werden, indem die Grammatik so geändert
wird, dass Terminale jeweils nur noch an einer Stelle der Ableitungsregeln
auftreten.


------------------------------------------------------------------------
Herbst 06 - Thema 1

87

i f - A n w e i s u n g

i f

B e d i n g u n g

t h e n

A n w e i s u n g

x   >   5

i f - A n w e i s u n g

i f

B e d i n g u n g

t h e n

A n w e i s u n g

e l s e

A n w e i s u n g

x   <   1 0

Variante 2

A n d e r e - A n w e i s u n g

A n d e r e - A n w e i s u n g

x   : =   7

x   : =   5

d)

Anweisung
if-Anweisung

::= if-Anweisung | Andere-Anweisung
::= if Bedingung then Anweisung |

if-Anweisung else Andere-Anweisung

Aufgabe 3

Untersuchen Sie, ob die folgenden Mengen und Sprachen entscheidbar bzw.
semi-entscheidbar sind! Begründen Sie jeweils Ihre Antwort!
a) f −1(A) = {n ∈ N|f (n) ∈ A}, wobei A ⊆ N eine entscheidbare Menge und

f : N → N eine totale und berechenbare Funktion ist.

b) L1 \ L2, wobei L1 ⊆ N eine semi-entscheidbare und L2 ⊆ N eine

(semi-)ent-
scheidbar,
totale und
berechenba-
re
Funktion

entscheidbare Sprache ist.

a) f (n) ist berechenbar (z. B. mittels einer Turingmaschine) und A ist ent-
scheidbar. Damit ist auch entscheidbar, ob f (n) ∈ A ist. Insgesamt ergibt
sich also, dass f −1(A) entscheidbar ist.

b) Gesucht sind alle Elemente x mit x ∈ L1 und x 6∈ L2. Da bereits nur semi-
entscheidbar ist, ob x ∈ L1 gilt, nützt es nichts, dass von dieser Menge
die entscheidbare Menge L2 subtrahiert wird. Es bleibt weiterhin nur semi-
entscheidbar, ob x ∈ L1 \ L2 ist.


------------------------------------------------------------------------
kontextfreie
Gramma-
tik,
reguläre
Gramma-
tik,
Ableitungs-
regel,
Produktion

88

1 Theoretische Informatik

Herbst 06 - Thema 2

Aufgabe 1

Gegeben seien ein Variablenalphabet V = {A, B} und ein Terminalalphabet
T = {a, b}. Es sei G1 = (V, T, P1, A) die kontextfreie Grammatik mit den Pro-
duktionen

P1 = {A → aAb|bB, B → bB|aB|λ}

und G2 = (V, T, P2, A) die kontextfreie Grammatik mit den Produktionen

P2 = {A → aAb|Ba, B → bB|aB|λ},

wobei λ für das leere Wort steht.
a) Welches sind die von G1 bzw. G2 generierten Sprachen L(G1) bzw. L(G2)?

Geben Sie Beschreibungen von L(G1) und L(G2), die nicht auf die
Grammatiken G1 bzw. G2 Bezug nehmen! Beweisen Sie Ihre Behauptungen!

b) Zeigen Sie, dass die kontextfreien Sprachen L(G1) und L(G2) nicht regu-

lär sind!

c) Welches sind die Sprachen L(G1) ∪ L(G2) und L(G1) ∩ L(G2)? Welche die-

ser Sprachen ist regulär?

a) Bei L(G1) entstehen Worte der Form anb(a, b)∗bn. Am Anfang des Wortes
stehen somit genauso viele a wie am Ende b. Nach den a folgt zwangsläuﬁg
ein b und dann beliebige Kombinationen von a und b.
Ableitungsregeln:
1) A −→ aAb
2) A −→ bB
3) B −→ bB
4) B −→ aB
5) B −→ λ
Beweis:
Durch n-maliges Anwenden von Regel 1) entsteht anAbn (n ∈ N0, da die
Regel auch gar nicht angewendet werden darf). Mit Regel 2) wird das einzelne
b abgeleitet. Die Regeln 3) und 4) können beliebig oft angewendet werden
(auch abwechselnd) und produzieren (a, b)∗. Mit Regel 5) wird das Wort
abgeschlossen.
Die Worte von L(G2) werden durch an(a, b)∗abn beschrieben. Auch hier ste-
hen vorne genauso viele a wie hinten b, vor den b muss ein a stehen und
zwischen den an und abn dürfen beliebige Kombinationen von a und b ste-
hen.
Ableitungsregeln:
1) A −→ aAb
2) A −→ Ba
3) B −→ bB
4) B −→ aB
5) B −→ λ


------------------------------------------------------------------------
Herbst 06 - Thema 2

89

Beweis:
Wiederum produziert Regel 1) anAbn und die Regeln 3) bis 5) (a, b)∗. Durch
Regel 2) wird ein einzelnes a vor den bn eingefügt.

b) In beiden Fällen verletzt A −→ aAb (Regel 1) die Bedingungen für eine
reguläre Grammatik. Da es nicht möglich ist, diese Regel in mehrere äqui-
valente reguläre Regeln umzuformen, ist es auch nicht möglich eine reguläre
Grammatik für L(G1) bzw. L(G2) anzugeben.

c) L(G1) ∩ L(G2) sind alle Wörter, bei denen am Ende genauso viele b stehen
wie a am Anfang - jeweils getrennt von einem a bzw b. Sie haben also die
Form anb(a, b)∗abn. Auch hier lässt sich die Grammatikregel A −→ aAb nicht
vermeiden,
L(G1) ∩ L(G2) ist also nicht regulär.
L(G1) ∪ L(G2) enthält alle Wörter der Form an(a, b)+bn und ist ebenfalls
nicht regulär.

Aufgabe 2

Es sei Σ = {0, 1}. Das Alphabet Σ2 bestehe aus allen Paaren von Elementen
aus Σ, geschrieben als Spaltenvektoren der Länge 2 über Σ, also
(cid:19)
0
0

Σ2 =

(cid:19)(cid:27)

(cid:26)(cid:18)

1
1

0
1

1
0

(cid:19)

(cid:18)

(cid:18)

(cid:18)

(cid:19)

,

,

,
(cid:19)

(cid:18)

Ein Wort w = w1w2...wn ∈ Σn
2 mit wi =
werden als ein Paar (x, y) ∈ Σn × Σn mit x = x1x2...xn, y1y2...yn, d. h.
(cid:18)

, 1 ≤ i ≤ n, kann aufgefasst

(cid:19) (cid:18)

(cid:19)

(cid:19)

(cid:18)

(cid:18)

(cid:19)

xi
yi

w =

x
y

=

x1
y1

x2
y2

...

xn
yn

.,

wobei λ für das leere Wort steht.

Zahldar-
stellung,
reguläre
Sprache


------------------------------------------------------------------------
90

1 Theoretische Informatik

a) Jedes Wort a = a1a2...an−1 ∈ Σn stellt die natürliche Zahl

bin(a) = a1 · 2n−1 + a2 · 2n−2 + ...an−1 · 2 + an dar (binäre Zahldarstellung).
Die Sprache des Größenvergleichs ist
(cid:19)

(cid:27)

(cid:26)

(cid:18)

LEQ :=

w =

x
y

∈ Σ∗

2; bin(x) ≤ bin(y)

.

Es gilt also beispielsweise

„

„

«

«

„

„

=

=

0101
0110
0110
0101

0
0
0
0

« „

« „

1
1
1
1

« „

« „

0
1
1
0

« „

« „

«

«

1
0
0
1

∈ LEQ,

/∈ LEQ

Zeigen Sie, dass die Sprache LEQ regulär ist!
Hinweis:
Sie können - falls Ihnen das hilfreich erscheint - hier die Tatsache verwenden,
dass eine Sprache L genau dann regulär ist, wenn die gespiegelte Sprache
LR = {wR; w ∈ L} regulär ist. Dabei ist (w1w2...wn−1wn)R = wnwn−1...w2w1.

b) Zeigen Sie, dass die Sprache

(cid:26)

w =

(cid:18)

(cid:19)

x
y

(cid:27)

∈ Σ∗

2; y = xR

.

nicht regulär ist!

a) Betrachten Sie die komplementäre Sprache, die nur Wörter mit bin(x) >
bin(y) enthält. Konstruieren Sie dann einen deterministischen endlichen Au-
tomaten, der die Worte jeweils von hinten abarbeitet, also zur gespiegelten
Sprache gehört.


------------------------------------------------------------------------
Herbst 06 - Thema 2

91

M = ({S, F }, Σ2, δ, S, {F })
(cid:21)

(cid:20)

δ(S,

δ(S,

δ(S,

δ(S,

(cid:20)

1
0
(cid:20)
0
1
0
0
1
1

(cid:20)

) = F
(cid:21)

) = S

(cid:21)

(cid:21)

) = S

) = S

(cid:21)

) = F
(cid:21)

) = S

(cid:21)

) = F

(cid:21)

) = F

(cid:20)

(cid:20)

(cid:20)

(cid:20)

1
0
0
1
0
0
1
1

δ(F,

δ(F,

δ(F,

δ(F,

Damit ist gezeigt, dass ¯LR regulär ist, was dann auch für die Sprache L (die
regulären Sprachen sind unter Komplementbildung abgeschlossen, s. [THEO]
1.2.6) gilt.

b) Das klassische Werkzeug für den Nachweis der Nicht-Regularität ist das

Pumping-Lemma:

Sei L eine reguläre Sprache. Dann gibt es eine Zahl n, so dass sich alle Wörter
x ∈ L mit | x |≥ n zerlegen lassen in x = uvw, so dass folgende Eigenschaften
erfüllt sind:

1.
2.
3.

| v |≥ 1
| uv |≤ n
∀i∈N0 uviw ∈ L

Kann man also nachweisen, dass eine Zerlegung mit den genannten Eigen-
schaften nicht existiert, so steht damit fest, dass die zu Grunde liegende
Sprache nicht regulär ist.

h

i

Es sei L2 = {z =

Wähle z ∈ L, z =

x
y
(cid:20)

∈ Σ∗

2 ; y = xR}.
(cid:21)

· · · xn
x1 x2
xn xn−1 · · · x1

(cid:28)

------------------------------------------------------------------------
92

1 Theoretische Informatik

1. Fall: | z | ungerade, k = n+1
2
z lässt sich zerlegen in

z = uvw =

(cid:20)

|

· · · xk−1
x1 x2
xn xn−1 · · · xk+1
{z
u

(cid:21)

}

Das Aufpumpen von z ergibt z0 = uviw
kwx , y0 = uyxi
⇒ x0 = uxxi
ux = wR
y0 = x0R ⇒ z0 ∈ L

x und vx = vy

y , uy = wR

kwy

(cid:20)

(cid:21)

xk
xk
| {z }
v

(cid:20)

|

xk+1 · · · xn−1 xn
xk−1 · · · x2 x1
{z
w

(cid:21)

}

2. Fall: | z | gerade, k = n
2
z lässt sich zerlegen in
(cid:20)

z =

|

· · · xk−1
x1 x2
xn xn−1 · · · xk+2
{z
u

(cid:21)

(cid:20)

}

|

xk xk+1
xk+1 xk
{z
v

(cid:21)

(cid:20)

}

|

xk+2 · · · xn−1 xn
xk−1 · · · x2 x1
{z
w

(cid:21)

}

Das Aufpumpen von z ergibt wiederum z0 = uviw
⇒ x0 = ux(xkxk+1)iwx , y0 = uy(xk+1xk)iwy
ux = wR
y0 = x0R ⇒ z0 ∈ L

x und vx = vR
y

y , uy = wR

Dies führt also nicht zum gewünschten Widerspruch und damit liefert das
Pumping-Lemma in diesem Fall leider keinen Beweis für die Nicht-Regularität.
Denn aus der Regularität folgt zwar nach dem Pumping-Lemma die Existenz
einer Zerlegung, die umgekehrte Folgerung stimmt aber nicht.

Es wird hier somit ein anderes Werkzeug z. B. die Argumentation über end-
liche Automaten benötigt:
Angenommen L2 wäre regulär. Dann gäbe es einen endlichen Automaten,
der alle z ∈ L akzeptiert. Der Automat müsste
vergleichen;
dies ist aber bei endlichen Automaten nicht möglich, da der Automat nicht
die Länge des Wortes kennt und das Wort nur linear abarbeiten kann.
Da es nicht möglich ist, einen endlichen Automaten zu konstruieren, ist L2
nicht regulär.

mit

xn
x1

x1
xn

i

h

h

i


------------------------------------------------------------------------
Frühjahr 07 - Thema 1

93

Frühjahr 07 - Thema 1

Aufgabe 1

Gegeben seien das Alphabet Σ = {a, b} und die Sprache L1 = {waba|w ∈ Σ∗}.
a) Zeigen Sie, dass L1 regulär ist.
b) Geben Sie einen vollständigen deterministischen endlichen Automaten an,

der die Sprache L1 akzeptiert.

c) Konstruieren Sie einen minimalen deterministischen Automaten, der L1 ak-

zeptiert und weisen Sie dessen Minimalität nach.
Gegeben sei weiter die Sprache L2 = {wwRaba|w ∈ Σ∗}.
d) Stellen Sie eine geeignete Grammatik G auf, die die Sprache L2 erzeugt,
und geben Sie eine Ableitung der Wörter aba und aabbaaaba in G an.

e) Ist L2 regulär bzw. kontextfrei? Begründen Sie Ihre Antworten.

reguläre
Sprache,
DEA,
Minimali-
sierung von
Automaten,
kontextfreie
Gramma-
tik,
reguläre
Grammatik

a) L1 ist regulär, da die Sprache durch den regulären Ausdruck (a|b)∗aba dar-

gestellt werden kann.

b) M = (Z, Σ, δ, z0, {z3}), Z = {Z0, Z1, Z2, Z3}, Σ = {a, b}

δ Z0 Z1 Z2 Z3
a Z1 Z1 Z3 Z1
b Z0 Z2 Z0 Z0

c) Es wird der Automat aus Teilaufgabe b) betrachtet:

Dieser Automat ist bereits minimal.

{Z0}
{Z1}
{Z2}

∗1
∗1
∗1
{Z3}

∗3
∗2
{Z0}

∗2
{Z1}


------------------------------------------------------------------------
94

1 Theoretische Informatik

d) G = ({S, A}, {a, b}, P, S) wobei

P = {S → Aaba, A → aAa|bAb|ε}

Ableitungen:
S → Aaba → εaba
S → Aaba → aAaaba → aaAaaaba → aabAbaaaba → aabbaaaba

e) L2 ist kontextfrei, weil bei obiger Grammatik auf der linken Seite nur einzelne
Variablen stehen, die Grammatik also kontextfrei ist. L2 ist eine Abwand-
lung der Spiegelwortsprache und diese ist bekanntlich nicht regulär. w und
wR müssen parallel erzeugt werden und dies ist mit regulären Regeln nicht
möglich.

Frühjahr 07 - Thema 2

Aufgabe 2

reguläre
Sprache

Sei Σ endliches Alphabet. Sei L ⊆ Σ∗ eine reguläre Sprache über Σ. Die Sprache
Lrev besteht aus allen Wörtern der Form a1...an, wobei an...a1 ∈ L ist, also die
Menge aller Wörter, die, wenn von rechts nach links gelesen in L sind. Die
Sprache Lsuf bezeichnet alle Wörter w, deren Suﬃxe in L sind; für die also
gilt: wenn immer w = uv, so folgt v ∈ L. Zeigen Sie, dass auch Lrev und Lsuf
regulär sind.

1. Zuerst wird Lrev betrachtet:

Weil L regulär ist, existiert ein regulärer Ausdruck für L. Dreht man diesen
regulären Ausdruck um, d. h. liest man ihn von hinten nach vorne, so erhält
man einen regulären Ausdruck, der Lrev akzeptiert.

2. Zu Lsuf :

Suﬃxe können wegen ihrer unbegrenzten Länge mit endlichen Automaten
nicht erkannt werden, Präﬁxe hingegen schon. Liest man also wiederum al-
le Wörter aus Lsuf von rechts nach links, so gilt Lsuf = (Lprä)rev. Wegen
der Eigenschaft der Abgeschlossenheit der regulären Sprachen, ist das Pro-
dukt zweier regulärer Sprachen wieder regulär. Lprä ist regulär, denn die
Wörter w ∈ Lprä sind von der Form w = uv mit ∀u⊆wu ∈ L und diese Ei-
genschaft lässt sich mit dem zu L gehörenden deterministischen Automaten
überprüfen.


------------------------------------------------------------------------
Frühjahr 07 - Thema 2

Aufgabe 3

95

Sei Σ = {0, 1, 2, ..., t und L ⊆ Σ∗ beliebige kontextfreie Sprache. Sei Lord die
Menge der absteigend geordneten Wörter aus L, das sind diejenigen Wörter
a1...an ∈ L für die gilt a1 ≥ a2 ≥ ... ≥ an. Zeigen Sie, dass Lord kontextfrei ist.

kontextfreie
Sprache

Alle geordneten Wörter können mit folgender (regulärer) Grammatik erzeugt wer-
den:
G = ({At, ..., A2, A1, A0}, {0, 1, 2, ..., t}, P, At) wobei

P = {At

→atAt|At−1
At−1 →at−1At−1|At−2
....
A2 →a2A2|A1
A1 →a1A1|A0
A0 →a0A0|ε}

Um nun die Worte aus Lord ⊂ L zu erkennen, benötigt man zuerst den Keller-
automaten von L (dieser existiert auf Grund der Kontextfreiheit von L). Obige
Grammatik wiederum lässt sich mit einem deterministischen Automaten darstel-
len. Die Hintereinanderschaltung dieser beiden Automaten erkennt Lord. Somit ist
auch Lord kontextfrei.

Aufgabe 4

Das Partyveranstaltungsproblem ist das folgende. Gegeben ist eine Menge B
von Bekannten und eine Menge H ⊆ B × B von (Paaren von) bekannten, die
sich nicht leiden können. Es ist festzustellen, ob eine Auswahl U ⊆ B von
k Bekannten (|U | = k) existiert (die Gästeliste), sodass in dieser keine zwei
Bekannten enthalten sind, die sich nicht leiden können. Man zeige, dass das
Partyveranstaltungsproblem NP-vollständig ist.

NP-hart,
NP-voll-
ständig

Durch Reduktionen vom und auf das Independent-Set-Problem wird nun gezeigt,
dass das Partyveranstaltungsproblem dasselbe ist wie das Independent-Set-Pro-
blem.
Partyveranstaltungsproblem ≤p Independent-Set: Seien n Bekannte mit einer sym-
metrischen, zweistelligen Nicht-Leiden-Können-Relation gegeben, die sich durch
einen ungerichteten Graphen darstellen lassen. k sei die Mindestzahl von Gästen.
Jetzt gilt: Die Party kann genau dann mit k wohlwollenden Gästen starten, wenn
der zugehörige Graph ein Independent-Set der Größe mindestens k hat. Das Par-
tyveranstaltungsproblem gehört also genau wie das Independent-Set zu NP.


------------------------------------------------------------------------
96

1 Theoretische Informatik

Independent-Set ≤p Partyveranstaltungsproblem: Sei G = (V,E) ein Graph, bei
dem jeder Knoten für einen Bekannten steht und jede Kante als Indiz gewertet
dafür wird, dass sich die beiden entsprechenden Bekannten nicht leiden können.
Dieser Graph besitzt nun genau dann ein Independent-Set der Größe k, wenn es
unter den Bekannten mindestens k gibt, die nichts aneinander auszusetzen haben
und deswegen als Partygäste in Frage kommen. Da das Independent-Set-Problem
NP-hart ist, ist auch das Partyveranstaltungsproblem NP-hart.

Herbst 07 - Thema 1

Aufgabe 1

Chomsky-
Hierarchie,
reguläre,
kontext-
freie,
kontextsen-
sitive
Sprache

Ordnen Sie die folgenden Sprachen bestmöglich in die Chomsky-Hierarchie ein
und geben Sie eine ausreichende Begründung an:
a) L1 = {anbnan|n ≥ 1}
b) L2 sei die Menge aller terminierenden Java-Programme.
c) L3 sei die Menge aller vollständig und korrekt geklammerten arithmeti-

schen Ausdrücke in den Variablen a und b mit den Operatoren + und ×.
Zur Illustration: ((a + (b + a)) × a) ∈ L3, ((a + b+)a)) × b /∈ L3 (nicht kor-
rekt geklammert), a × (b + b)) /∈ L3 (nicht vollständig geklammert).

d) L4 = {w ∈ {a, b}∗|w enthält mindestens 4 Vorkommen von a}.
e) L5 = {anbn$w|n ≥ 1 und w ∈ {a, b}∗}

a) L1 ist eine Sprache vom Typ 1, da es eine kontextsensitive Grammatik gibt:

G = ({S, A, B}, {a, b}, P, S), wobei

P = {S → aSBA | aBA

AB → BA
aB → ab
bB → bb
bA → ba
aA → aa}

Mit Hilfe des Pumping-Lemmas für kontextfreie Sprachen lässt sich leicht
zeigen, dass für die Pump-Zahl n und das Wort ω = anbncn keine Zerlegung
existiert, die das Pumping-Lemma erfüllt, da im Bereich der vorderen a’s
gepumpt werden müsste. L1 ist also nur von Typ 1 und nicht von Typ 2.

b) Da die Sprachregeln für Java-Programme mit Hilfe von Syntaxdiagrammen
dargestellt werden können, die kontextsensitiven Grammatiken (z. B. muss
bei der Erstellung einer for Schleife darauf geachtet werden, dass die Schlei-
fenvariable bei Initialisierung und Update die selbe ist) entsprechen, ist L2


------------------------------------------------------------------------
Herbst 07 - Thema 1

97

kontextsensitiv also vom Typ 1. Da z. B. die Regel für die Erstellung von for-
Schleifen nicht in mehrere kontextfreie Regeln umgewandelt werden kann, ist
L2 nur von Typ 1.

c) Auch hier wird eine zugehörige Grammatik betrachtet:

G = ({A, B, C}, {a, b, +, ∗, (, )}, P, A) wobei

P = {A → B | A + B
B → C | B ∗ C
C → a | b | (A)}

Diese Grammatik ist kontextfrei aber nicht regulär. U. a. die letzte Regel
verhindert die Regularität. Da die Klammern aber immer paarweise gesetzt
werden müssen, kann hierfür keine reguläre Regel (oder mehrere reguläre
Regeln) gefunden werden.
Eine alternative Grammatik lautet:
G = ({S}, {a, b, +, ∗, (, )}, P, S) wobei

P = {S → a | b | (S + S) | (S ∗ S)}

Auch hier verhindern die Klammern eine Umformung in (eine) reguläre Re-
gel(n). L3 ist demnach von Typ 2.

d) L4 kann durch den regulären Ausdruck b∗ab∗ab∗ab∗a(a | b)∗ beschrieben

werden und somit ist L4 von Typ 3.

e) anbn kann nicht mit einem regulären Ausdruck beschrieben werden (Pump-
ing-Lemma liefert ebenfalls einen Widerspruch) und deshalb ist L5 nicht
regulär. Eine mögliche Grammatik für L5 lautet:
G = ({S, A, B}, {a, b, $ }, P, S) wobei

P = {S → A$B

A → aAC | ab
C → b
B → aB | bB | ε}

Diese Grammatik ist kontextfrei und somit ist L5 von Typ 2.


------------------------------------------------------------------------
98

1 Theoretische Informatik

Aufgabe 2

NEA,
DEA,
Minimali-
sierung von
Automaten

Geben Sie zu dem nichtdeterministischen endlichen Automaten in der Abbil-
dung einen äquivalenten deterministischen Automaten. Ist Ihr Automat mini-
mal? Falls nein, so geben Sie mindestens ein Paar von Zuständen an, die zu
einem einzigen Zustand zusammengefasst werden können. Falls ja, so geben Sie
für mindestens drei Zustandspaare Ihrer Wahl jeweils eine Begründung dafür,
dass diese nicht zusammengefasst werden können.

Abbildung: ein nichtdeterministischer Automat mit 3 Zuständen

Z = {{1}, {2}, {3}, {1, 2}} ZH = {1, 2}, {3}}

Zustandsmenge
Z = {{1}, {2}}

Initialisierung: Z = {{1}}, ZH = {{1}}
Zustandsübergänge
δ({1}, a) = {2}
δ({1}, b) = ∅
δ({2}, a) = {3}
δ({2}, b) = {1, 2}
δ({1, 2}, a) = {2, 3}
δ({1, 2}, b) = {1, 2}
δ({3}, a) = {1}
δ({3}, b) = {1, 3}
δ({2, 3}, a) = {1, 3},
δ({2, 3}, b) = {1, 2, 3}
δ({1, 3}, a) = {1, 2},
δ({1, 3}, b) = {1, 3}
δ({1, 2, 3}, a) = {1, 2, 3}, Z = {{1}, {2}, {3}, {1, 2},
δ({1, 2, 3}, b) = {1, 2, 3}

Z = {{1}, {2}, {3}, {1, 2},
{2, 3}}
Z = {{1}, {2}, {3}, {1, 2},
{2, 3}, {1, 3}}
Z = {{1}, {2}, {3}, {1, 2},
{2, 3}, {1, 3}, {1, 2, 3}}
Z = {{1}, {2}, {3}, {1, 2},
{2, 3}, {1, 3}, {1, 2, 3}}

{2, 3}, {1, 3}, {1, 2, 3}}

F = {{1}, {1, 2}, {1, 3}, {1, 2, 3}}

Hilfsmenge
ZH = {{2}}

ZH = {{3}, {2, 3}}

ZH = {{1, 3}, {2, 3}}

ZH = {{1, 3}, {1, 2, 3}}

ZH = {{1, 2, 3}}

ZH = ∅


------------------------------------------------------------------------
Herbst 07 - Thema 1

99

{2}
{3}
{1, 2}
{1, 3}
{2, 3}
{1, 2, 3}

∗1
∗1
∗3
∗2
∗1
∗2
{1}

∗2
∗1
∗1
∗2
∗1
{2}

∗1
∗1
∗3
∗1
{3}

∗2
∗1
∗2
{1, 2}

∗1
∗2
{1, 3}

∗1
{2, 3}

Der Automat ist bereits minimal.
{1} kann z. B. mit keinem anderen Zustand zusammen gefasst werden, da kein
anderer Zustand einen übergang zu {2} mit a hat.
{3} kann z. B. mit keinem anderen Zustand zusammen gefasst werden, da kein
anderer Zustand einen übergang zu {1} mit a hat.
{1, 3} kann z. B. mit keinem anderen Zustand zusammen gefasst werden, da kein
anderer Zustand einen übergang zu {1, 2} mit a hat.

Aufgabe 3

Für eine (deterministische) Turingmaschine T = (I, Σ, Q, δ, q0, F, b) und ein
Wort w ∈ Σ∗ ist die partielle Funktion T IM ET (w) deﬁniert als die Anzahl von
Arbeitsschritten, die T bei Eingabe w ausführt. Falls T bei Eingabe W nicht
hält, ist T IM ET (w) =⊥, also undeﬁniert. Im Folgenden sei Σ = {0, 1} fest; das
leere Wort wird wie üblich mit (cid:15) bezeichnet. Die Busy-Beaver Funktion BB(n)
ist deﬁniert als
BB(n) := max{T imeT ((cid:15))|Turingmaschine T hat höchstens N Zustände und
hält auf leerer Eingabe}
a) Das Halteproblem bei leerer Eingabe ist die Menge

H0 = {T |T IM ET ((cid:15)) 6=⊥}. Bekanntlich ist H0 unentscheidbar.
Geben Sie eine Reduktion des Graphen von BB, also der Menge
G{(n, b)|b = BB(n)} auf H0 an.

b) Zeigen Sie durch Widerspruch: BB(n) wächst schneller als jede berechen-
bare Funktion, d. h. für jede berechenbare Funktion f : N → N gilt:
BB(n) /∈ O(f (n)).

Turingma-
schine,
Haltepro-
blem,
Unent-
scheidbar-
keit,
berechenba-
re
Funktion

a) Interpretation: G sei die Menge der Turingmaschinen, die bei anfangs n Ein-

sen auf dem Band mit b = BB(n) Einsen anhalten.
Um die Unentscheidbarkeit eines Problems P zu zeigen, muss ein als un-
entscheidbar bekanntes Problem auf dieses Problem P reduziert werden. In
unserem Fall also H0 ≤pol G. (Beweis analog zu H ≤pol H0, also zum allge-
meinen Halteproblem, siehe [THEO], Kap. 2.6)
Man konstruiere nun eine TM T 0 die zu Beginn n Einsen auf das leere Band
schreibt und sich danach wie T verhält, also BB(n) Einsen produziert.
Damit lässt sich eine totale und berechenbare Funktion f konstruieren, die
Wörter der Form 1BB(n)#1n auf den Code der verbal beschriebenen TM
abbildet. Nun gilt:

(cid:28)

------------------------------------------------------------------------
100

1 Theoretische Informatik

1BB(n)#1n ∈ G ⇐⇒ T angesetzt auf n haelt

⇐⇒ T 0 angesetzt auf leerem Band haelt
⇐⇒ f (1BB(n)#1n) ∈ H0

Also vermittelt f die gewünschte Reduktion von G nach H0

b) Sei f eine beliebige berechenbare Funktion. Wir deﬁnieren
(f (i) + i2) = f (0) + f (1) + 1 + · · · + f (n) + n2

F (n) =

nP

i=0

Dann ist auch F berechenbar durch eine Turing-Maschine MF . Diese habe
m Zustände.
Wir betrachten nun eine Turing-Maschine M, die n Striche auf das zunächst
leere Band schreibt und dann auf dem letzten Strich stehen bleibt. Das schaﬀt
sie mit n Zuständen. Dahinter schalten wir MF , die dann F (n) Striche auf
das Band schreibt. Das kostet noch einmal m Zustände. Wir setzen MF ein
weiteres Mal auf das Band an, auf dem F (n) Striche stehen. So erhalten wir
ein Band mit insgesamt F (F (n)) Strichen. Diese Striche wurden von einer
Maschine mit n+2m Zuständen geschrieben.
Ein ﬂeißiger Biber mit n+2m Zuständen wird mindestens so viele Striche
schreiben wie unsere Maschine. Also gilt:
BB(2n + m) ≥ F (F (n))
Nun ist nach Deﬁnition F (n) = n2, außerdem gibt es ein n0 mit n2 > n + 2m
für n > n0.
Also ist F (n) > n + 2m. Da F (n) monoton ist, also für alle x > y ist
F (x) > F (y), gilt:
F (F (n)) > F (n + 2m)
Da nach Deﬁnition F (n) > f (n) gilt, erhalten wir insgesamt:
BB(n + 2m) > f (n + 2m) für n > n0
Da f (n) eine beliebige berechenbare Funktion ist, ist gezeigt, dass BB schnel-
ler wächst als jede beliebige Funktion.

Herbst 07 - Thema 2

Aufgabe 1

NEA,
DEA,
reguläre
Gramma-
tik,
regulärer
Ausdruck,

Gegeben sei der nichtdeterministische endliche Automat M mit dem Alphabet
Σ = {a, b}, der Zustandsmenge {z0, z1, z2, z3}, Anfangszustand z0, Endzustand
{z3} und der überführungsfunktion δ mit:
δ(z0, a) = {z1, z2}, δ(z1, b) = {z0, z1}, δ(z2, a) = {z2, z3}, δ(z0, b) = δ(z1, a) =
δ(z2, b) = δ(z3, a) = δ(z3, b) = ∅
L(M ) sei die von M akzeptierte Sprache.


------------------------------------------------------------------------
Herbst 07 - Thema 2

101

a) Gelten folgende Aussagen?

i) Es gibt Zeichenreihen in L(M ), die genauso viele a0s enthalten wie b0s.
ii) Jede Zeichenreihe in L(M ), die mindestens vier b0s enthält, enthält

auch mindestens vier a0s.
Begründen Sie Ihre Antworten.

b) Geben Sie eine reguläre (Typ-3-)Grammatik an, die L(M ) erzeugt.
c) Beschreiben Sie L(M ) durch einen regulären Ausdruck.
d) Konstruieren Sie aus M mit der Potenzmengen-Konstruktion (und entspre-
chender Begründung) einen deterministischen Automaten, der L(M ) ak-
zeptiert.

a) Zur besseren übersichtlichkeit wird zuerst der Automat gezeichnet.

Potenzmen-
genalgo-
rithmus

i) Jede Zeichenreihe, die mindestens ein b enthält, enthält mindestens 3
a. Durch δ(z1, b) = {z0, z1} kann die Anzahl der b erhöht werden.
Somit kann man abbbaa ∈ L(M ) erhalten.
Da durch δ(z2, a) = {z2, z3} auch beliebig viele a eingefügt werden
können, lässt sich auch abbbbaaa ∈ L(M ) erzeugen.
Die zu prüfende Aussage ist also wahr.

ii) Jede Zeichenreihe, die b’s enthält, enthält mindestens 3 a, aber nicht

zwangsläuﬁg 4 wie z. B. abbbbaa ∈ L(M ).
Die zu prüfende Aussage ist also falsch.

b) G = ({S, A, B}, {a, b}, P, S), wobei

P = {S → aA|aB, A → bA|bS, B → aB|a}

c) (ab+)∗a+a
d) Initialisierung: Z = {{Z0}}, ZH = {{Z0}}

Zustandsmenge
Z = {{Z0}, {Z1, Z2}} ZH = {{Z1, Z2}}

Hilfsmenge

Zustandsübergänge
δ({Z0}, a) = {Z1, Z2}
δ({Z0}, b) = ∅
δ({Z1, Z2}, a) = {Z2, Z3} Z = {{Z0}, {Z1, Z2},
δ({Z1, Z2}, b) = {Z0, Z1}
δ({Z0, Z1}, a) = {Z1, Z2} Z = {{Z0}, {Z1, Z2},
δ({Z0, Z1}, b) = {Z0, Z1}
δ({Z2, Z3}, a) = {Z2, Z3} Z = {{Z0}, {Z1, Z2},
δ({Z2, Z3}, b) = ∅

{Z2, Z3}, {Z0, Z1}}

{Z2, Z3}, {Z0, Z1}}

{Z2, Z3}, {Z0, Z1}}

F = {{Z2, Z3}}

ZH = {{Z2, Z3},
{Z0, Z1}}
ZH = {{Z2, Z3}}

ZH = ∅


------------------------------------------------------------------------
102

1 Theoretische Informatik

Aufgabe 2

reguläre
Sprache,
kontextfreie
Gramma-
tik,
Pumping-
Lemma,
Turingma-
schine,
Komplexi-
tät,
entscheid-
bar

Für beliebiges m ∈ N sei Lm die Sprache Lm = {aibmaibm ∈ {a, b}∗|i ∈ N}.
a) Beweisen Sie: L3 ist nicht regulär.
b) Ist Lm für jedes m ∈ N nicht regulär? Begründen Sie Ihre Antwort.
c) Geben Sie die allgemeine Form einer kontextfreien (Typ-2-)Grammatik an,

die Lm (für beliebiges m) erzeugt.

d) Ist jeder der Sprachen Lm mit einer deterministischen Turing-Maschine

mit einer Zeitkomplexität O(n2) entscheidbar (n ist die Länge der jeweili-
gen Eingabe)? Begründen Sie Ihre Antwort.

a) L3 = {aib3aib3|i ∈ N}

Anwendung des Pumping-Lemma:
Sei n die Pumpzahl und x = anb3anb3
Wegen der Bedingung, dass |uv| ≤ n muss gelten uv ⊆ an
O. B. d. A.: sei u = an−1, v = a ⇒ w = b3anb3
Das Aufpumpen führt zu an−1aib3anb3 ⇒ n − 1 + i 6= n für i 6= 1 und damit
ist die Bedingung des Pumping-Lemma, dass an−1aib3anb3 ∈ L3 nicht erfüllt.

b) 1. Variante: m ∈ N ⇔ m ≥ 1

Lm ist nie regulär, denn mit dem Pumping-Lemma müssten immer bei aus-
reichend großen Worten die a’s am Wortanfang gepumpt werden und damit
stimmt deren Anzahl nicht mehr mit den a’s in der Mitte überein. Dazu
müsste das Wort an zwei Stellen gleichzeitig gepumpt werden und das geht
nur mit dem Pumping-Lemma für kontextfreie Sprachen, nicht aber für re-
guläre Sprachen.
2. Variante: m ∈ N ⇔ m ≥ 0
Für m = 0 ist L0 regulär, denn L0 = {aiai|i ∈ N}
Eine mögliche Grammatik für L0 lautet:
G = ({S, A}, {a, b}, P, S), wobei P = {S → aA|ε, A → aS}
Damit ergibt sich der reguläre Ausdruck (aa)∗.


------------------------------------------------------------------------
Herbst 07 - Thema 2

103

c) G = ({S, A, B}, {a, b}, P, S), wobei

P = {S → BA
A → bm
B → aBa|A}

(wobei m eine f este Zahl ist)

d) Informelle Beschreibung einer Turing-Maschine:

Es werden zuerst paarweise a und dann paarweise b vom Band gelöscht.
Wenn das Band am Schluss leer ist, wird das Wort akzeptiert. (Um genau
m Paare von b’s zu Löschen benötigt man relativ viele Zustände).
|w| = n = 2 · i + 2 · m ⇒ i = n
2 − m
Zwischen jedem a der ersten Gruppe und dem zugehörigen a der zweiten
Gruppe liegen genau n
2 Zeichen. Um alle a zu löschen müssen diese Schritte
genau i-mal durchgeführt werden. Anschließend werden in m Durchgängen
die b gelöscht, die auch jeweils den Abstand n
2 Zeichen besitzen. Die Anzahl
der Arbeitsschritte bis zum erfolgreichen Erkennen (oder eben Ablehnen)
eines Wortes errechnet sich also mit n
4 ; die Turingma-
schine besitzt also die Zeitkomplexität O(n2).
Eine zusätzliche Prüfung, ob es sich um genau m Zeichen b handelt, verlängert
lediglich die Arbeitsschritte bei der Löschung der b um m Teilschritte, was
aber an der ingesamten Zeitkomplexität von O(n2) nichts ändert.

2 · (i + m) = n

2 = n

2 · n

2

Aufgabe 3

Es seien Σ ein Alphabet, L1 und L2 zwei Sprachen über Σ. (cid:15) bezeichne die leere
Zeichenreihe. Gelten folgende Aussagen? Begründen Sie Ihre Antworten.
a) Ist L1 kontext-sensitiv (Typ-1), so ist die Sprache
L = {w ∈ Σ∗|w /∈ L1 und w 6= (cid:15)} entscheidbar.

b) Wird L1 von einem linear beschränkten Automaten M mit der Zustands-
menge Z und Endzustandsmenge E akzeptiert, so akzeptiert der linear
beschränkte Automat M 0, der aus M entsteht, wenn man E durch Z \ E er-
setzt die Sprache Σ∗ \ L1.

c) Sind L1 und L2 entscheidbar, so ist auch die Sprache

L1 ◦ L2 = {w1w2 ∈ Σ∗|w1 ∈ L1, w2 ∈ L2} entscheidbar.

d) Ist L1 entscheidbar und L2 semi-entscheidbar, so ist die Funktion

(

f : Σ∗ → Σ∗ mit f (w) =

berechenbar.

(cid:15)
undeﬁniert

falls w /∈ L1 ∩ L2
sonst

e) Sind sowohl L1 als auch L2 mit einer deterministischen Turing-Maschine
mit polynomieller Zeitkomplexität entscheidbar, so gilt dies auch für
L1 \ L2.

kontextsen-
sitive,
entscheid-
bare
Sprache,
LBA, ent-
scheidbar,
semi-ent-
scheidbar,
Turingma-
schine,
Komplexi-
tät


------------------------------------------------------------------------
104

1 Theoretische Informatik

a) L1 ist kontextsensitiv ⇔ L1 ist entscheidbar ⇔ es gibt eine Turing-Maschine,

die L1 entscheidet.
Man konstruiere nun eine TM, die testet, ob es sich um das leere Wort
handelt und verwende anschließend die TM, die L1 entscheidet, und negiere
das Ergebnis.

D. h. wenn im Startzustand das Blank-Symbol gelesen wird, schreibt die TM
0 auf das Band und bleibt stehen. Wird im ersten Schritt ein Element aus Σ
gelesen, springt die TM zum Startzustand der TM von L1, bewegt den Kopf
aber noch nicht.

b) Da L1 von einem linear beschränkten Automaten akzeptiert wird, ist L1
kontextsensitiv. Nach dem Satz von Immermann/Szelepcs´enyi ist bekannt,
dass die kontextsensitiven Sprachen unter Komplementbildung abgeschlossen
sind. D. h. Σ∗\L1 = L1 ist wieder kontextsensitiv. Damit gibt es auch einen
LBA, der L1 akzeptiert.

∀x ∈ Σ∗ : x ∈ L1 ↔ M terminiert in E ↔ M 0 terminiert in Z\E ↔ x 6∈ L1
x 6∈ L1 ↔ M terminiert in Z\E ↔ M 0 terminiert in E ↔ x ∈ L1

M 0 ist also der gewünschte LBA.

c) Auch hier kann man einfach die TM, die L1 bzw L2 entscheiden, hinterein-
ander schalten. Zuerst wird mit der TM von L1 w1 geprüft und wenn diese
Prüfung ergibt, dass w1 ∈ L1 wird w2 mit der TM von L2 getestet.

d) f (w) ist genau dann berechenbar, wenn w 6∈ L1 ∩ L2 entscheidbar ist.

w 6∈ L1 ∩ L2 ⇔ w ∈ L1 ∩ L2 ⇔ w ∈ L1 ∪ L2
w ∈ L2 ist nicht entscheidbar, da L2 nur semi-entscheidbar ist. Daraus folgt,
dass f (w) nicht berechenbar ist.

e) L1\L2 = L1 ∩ L2.

Durch die polynomielle Laufzeit ist nur ausgesagt, dass die Sprachen von
Typ 0 sind. Hierbei ist der Schnitt zwar eine abgeschlossene Operation, die
Komplementbildung aber nicht. D. h. L1\L2 ist nicht unbedingt von Typ 0
und damit auch nicht entscheidbar.


------------------------------------------------------------------------
Frühjahr 08 - Thema 1

105

Frühjahr 08 - Thema 1

Aufgabe 1

Sei Σ = {a, b} ein Alphabet. Wir betrachten die Sprache L = {w1...wn ∈ Σ∗|n ≥
2 ∧ ∃1≤i<nwn = wi ∧ ∀1≤i≤nwi ∈ Σ} als die Sprache, die alle Wörter enthält,
deren letzter Buchstabe vorher bereits schon einmal im Wort vorkam.
a) Geben Sie für das Alphabet Σ = {a, b} einen nichtdeterministischen endli-

chen Automaten N1 an, der L erkennt.

b) übersetzen Sie den Automaten N1 in einen deterministischen endlichen Au-

tomaten, indem Sie die Potenzmengenkonstruktion durchführen.
c) Geben Sie eine Chomsky-Typ-3-Grammatik G an, die L erzeugt.
d) Zeigen Sie, dass G das Wort aaabab erzeugt.

reguläre
Sprache,
NEA,
DEA,
reguläre
Gramma-
tik,
Potenzmen-
genalgo-
rithmus,
Ableitung
eines
Wortes

a) M = (Z, Σ, δ, S, {F1, F2, F3}),

Z = {S, A1, A2, B1, B2, C, D, F1, F2, F3}, Σ = {a, b}
D
∅
{F3}

S
{A1, C}
{B1, D}

B1
{B2}
{B1}

A1
{A1}
{A2}

A2
{F1}
{F1}

B2
{F1}
{F1}

C
{F2}
∅

δ
a
b

F1
{F1}
{F1}

F2
{F2}
∅

F3
∅
{F3}


------------------------------------------------------------------------
106

1 Theoretische Informatik

b) Initialisierung: Z = {{S}}, ZH = {{S}}
Zustandsmenge
Z = {{S}, {A1, C}, {B1, D}}

Zustandsübergänge
δ({S}, a) = {A1, C}
δ({S}, b) = {B1, D}
δ({A1, C}, a) = {A1, F2}
δ({A1, C}, b) = {A2}
δ({B1, D}, a) = {B2}
δ({B1, D}, b) = {B1, F3}
δ({A1, F2}, a) = {A1, F2}
δ({A1, F2}, b) = {A2}
δ({A2}, a) = {F1}
δ({A2}, b) = {F1}

Z = {{S}, {A1, C}, {B1, D},
{A2}, {A1, F2}}
Z = {{S}, {A1, C}, {B1, D},
{A2}, {A1, F2}, {B2}, {B1, F3}}
Z = {{S}, {A1, C}, {B1, D},
{A2}, {A1, F2}, {B2}, {B1, F3}}
Z = {{S}, {A1, C}, {B1, D},
{A2}, {A1, F2}, {B2}, {B1, F3},
{F1}}
Z = {{S}, {A1, C}, {B1, D},
{A2}, {A1, F2}, {B2}, {B1, F3},
{F1}}
Z = {{S}, {A1, C}, {B1, D},
{A2}, {A1, F2}, {B2}, {B1, F3},
{F1}}
Z = {{S}, {A1, C}, {B1, D},
{A2}, {A1, F2}, {B2}, {B1, F3},
{F1}}
F = {{F1}, {B1, F3}, {A1, F2}}

δ({B1, F3}, a) = {B2}
δ({B1, F3}, b) = {B1, F3}

δ({B2}, a) = {F1}
δ({B2}, b) = {F1}

δ({F1}, a) = {F1}
δ({F1}, b) = {F1}

Hilfsmenge
ZH = {{A1, C},
{B1, D}}
ZH = {{B1, D},
{A1, F2}, {A2}}
ZH = {{A1, F2}, {A2},
{B2}, {B1, F3}}
ZH = {{A2}, {B2},
{B1, F3}}
ZH = {{B2}, {B1, F3},
{F1}}

ZH = {{B1, F3}, {F1}}

ZH = {{F1}}

ZH = ∅

c) G = ({S, A, B, C}, {a, b}, P, S) wobei

P = {S → aA|bB

A → aA|bC|a
B → bB|aC|b
C → aC|bC|a|b}

d) S → aA → aaA → aaaA → aaabC → aaabaC → aaabab


------------------------------------------------------------------------
Frühjahr 08 - Thema 1

Aufgabe 2

107

Zeigen Sie, dass die Sprache L = {anbm|n > m} genau eine Chomsky-Tpy-2
Sprache ist!

kontextfreie
Sprache

Annahme: m ≥ 0, also n ≥ 1
G = ({S, A}, {a, b}, P, S), wobei

P = {S → aS|aA
A → aAb|ε}

Diese Grammatik ist kontextfrei und erzeugt L.
Es bleibt noch zu zeigen, dass L nicht regulär ist. Falls L regulär wäre, gäbe es
eine Pumpzahl k, so dass alle Wörter mit einer Länge > k das Pumping-Lemma
erfüllen. Das Wort an+1bn mit k ≤ n + 1 muss in den a gepumpt werden. Aber
für i = 0 ergibt sich anaibn = anbn 6∈ L. Somit ist L nicht regulär aber kontextfrei.

Aufgabe 3

Sei Σ = {a, b, c} ein endliches Alphabet. Wir betrachten die Sprache L = {w ∈
Σ ∗ |∀s∈Σ\{a}|w|s < |w|a}, also die Menge aller Wörter, in denen a echt häuﬁger
als die anderen Buchstaben vorkommt.
a) Geben Sie eine deterministische Turingmaschine an, die L für das Alphabet

Turingma-
schine,
Komplexi-
tät,
O-Notation

Σ entscheidet. Die Maschine soll dabei wie folgt verfahren:

• Das Arbeitsalphabet Γ soll zusätzliche Zeichen (cid:3) und ♦ enthalten.
• Das Wort steht initial als (cid:3)w(cid:3) auf dem Band der Turingmaschine.
• Die Turingmaschine sucht nach jeweils einem a, b und c und über-

schreibt das jeweils erste gefundene Zeichen mit ♦.

• Wird dabei kein a gefunden, ist das Wort zu verwerfen. Wird ein a ge-
funden, aber weder b noch c, wird das Wort akzeptiert. Beachten Sie,
dass es dabei möglich ist, ein a und c, aber kein b, oder ein a und b,
aber kein c zu ﬁnden.

• Nach einem solchen Durchgang fährt die Turingmaschine nach links

und beginnt von vorne.

Beschreiben Sie dabei die Bedeutung der Zustände q ∈ Q Ihrer Turingma-
schine informell.

b) Geben Sie den Ablauf Ihrer Turingmaschine über dem Wort aba an.
c) Geben Sie Laufzeit- und Speicherplatzkomplexität Ihrer Turingmaschine

M in O-Notation an. Kann die Laufzeitkomplexität durch die Verwendung
einer Mehrband-Turingmaschine verbessert werden? Begründen Sie Ihre
Antworten.


------------------------------------------------------------------------
108

1 Theoretische Informatik

a) Entweder es wird zuerst ein a gelesen oder ein b oder c. Dementsprechend
wird in die Zustände q1 bzw. q3 gewechselt. Dort wird ein b (c) bzw. ein a
gesucht. Ist dies gefunden, wird in den Zustand q2 bzw. q4 übergegangen und
wieder zurück zum Wortanfang gelaufen. Wenn dieser gefunden ist, wird in
q0 ein neuer Durchgang gestartet. Die Turingmaschine akzeptiert das Wort
dann, wenn ein a gefunden wurde und bis zum Wortende kein b oder c mehr
auf dem Band vorhanden sind.

b)

(cid:3)
4

(cid:3)

a

b

a (cid:3)

q0

b

a (cid:3)

a
4

(cid:3)

♦

q1

b
4

q2

a (cid:3)

(cid:3)

♦
4

♦

a (cid:3)

q0


------------------------------------------------------------------------
Frühjahr 08 - Thema 2

109

(cid:3) ♦ ♦

a
4

q1

(cid:3) ♦ ♦

♦

qE

(cid:3)

(cid:3)
4

c) Auf dem Band beﬁndet sich nur das Wort der Länge n und es wird nichts
jenseits der Grenzen des Wortes auf das Band geschrieben. Die Speicher-
platzkomplexität beträgt also O(n).
Für jeweils zwei Buchstaben muss die Turingmaschine das Wort einmal nach
rechts und einmal nach links ablaufen. Dies sind jeweils n Schritte. Für n
Buchstaben mit jeweils n Schritten beträgt die Laufzeitkomplexität demnach
O(n2).
Bei der Verwendung einer 3-Band-Turingmaschine wäre folgendes denkbar:
Auf dem ersten Band steht die Eingabe. Nun fährt der erste Kopf die Eingabe
ab und schreibt alle a auf Band 2 und alle b und c auf Band 3, danach beﬁnden
sich die Köpfe rechts der (Teil-)Worte. Anschließend fahren der zweite und
der dritte Kopf parallel ihre Bänder ab. Je nachdem ob Kopf 2 oder Kopf 3
zuerst (cid:3) liest, ist das Wort in L oder nicht. Für das Verteilen der Eingabe
auf die anderen Bänder sind n Schritte nötig. Danach werden diese Bänder
nur einmal von rechts nach links abgefahren, was im worst-case wiederum n
Schritte sind. Die Laufzeitkomplexität beträgt also O(2 ∗ n) = O(n).

Frühjahr 08 - Thema 2

Aufgabe 2

a) Konstruieren Sie einen deterministischen endlichen Automaten, der die

Sprache akzeptiert, die durch den regulären Ausdruck
(a + b)∗ · a · (a + b) · (a + b) · (a + b) beschrieben ist.
Hinweis: Konstruieren Sie zuerst einen nichtdeterministischen endlichen Au-
tomaten, und wandeln Sie diesen anschließend in einen deterministischen
endlichen Automaten um!

b) Geben Sie einen nichtdeterministischen endlichen Automaten (NEA) mit
maximal 4 Zuständen an, der die folgende reguläre Sprache akzeptiert:
L = {xy|x, y ∈ {a, b}∗ x endet mit b und die Anzahl der Zeichen a in y

ist durch 3 teilbar}

Ein Wort w ist somit in L, falls das Zeichen b so in w vorkommt, dass die
Zahl der Zeichen a, die nach diesem b stehen, durch 3 teilbar ist.

NEA,
DEA,
regulärer
Ausdruck,
reguläre
Sprache,
Minimali-
sierung von
Automaten


------------------------------------------------------------------------
110

1 Theoretische Informatik

c) Im Gegensatz zu deterministischen endlichen Automaten ist kein einfacher
Minimierungsalgorithmus für nichtdeterministische endliche Automaten be-
kannt. Sie sollen hier dennoch nachweisen, dass jeder nichtdeterministische
endliche Automat, der die in Teilaufgabe b) beschriebene Sprache L akzep-
tiert, mindestens 4 Zustände besitzt.
Betrachten Sie eine Zerlegung des Wortes w = baaa in die folgenden Paare:
(x1, y1) = ((cid:15), baaa), (x2, y2) = (ba, aa), (x3, y3) = (baa, a),
(x4, y4) = (baaa, (cid:15)).
Sei A ein (unbekannter) endlicher Automat, der L akzeptiert. Da w vom
Automaten A akzeptiert wird, gibt es für jedes Paar (xi, yi) einen Zustand
qi, so dass einer der Berechnungspfade den Automaten vom Startzustand
aus auf Eingabe xi in den Zustand qi führt, und von qi ausgehend auf der
Eingabe yi in einen der - möglicherweise mehreren - Endzustände. Führen
Sie nun die Annahme zum Widerspruch, dass A drei Zustände besitzt
und zugleich keine Wörter akzeptiert, die nicht in L sind.

a) In einer anderen üblichen Schreibweise lautet der reguläre Ausdruck:

(a|b)∗a(a|b)(a|b)(a|b)

M = (Z, Σ, δ, Z0, {ZF }), Z = {Z0, Z1, Z2, Z3, ZF }, Σ = {a, b}

δ
a
b

Z0
{Z0, Z1}
{Z0}

ZF
∅
∅
Initialisierung: Z = {{Z0}}, ZH = {{Z0}}

Z3
{ZF }
{ZF }

Z1
{Z2}
{Z2}

Z2
{Z3}
{Z3}

Zustandsübergänge
δ({Z0 }, a) = {Z0, Z1 }
δ({Z0 }, b) = {Z0}
δ({Z0 , Z1 }, a) = {Z0, Z1 , Z2}
δ({Z0 , Z1 }, b) = {Z0, Z2 }
δ({Z0 , Z1 , Z2 }, a) = {Z0, Z1, Z2, Z3 }
δ({Z0 , Z1 , Z2 }, b) = {Z0, Z2 , Z3}
δ({Z0 , Z2 }, a) = {Z0, Z1 , Z3}
δ({Z0 , Z2 }, b) = {Z0, Z3 }

δ({Z0 , Z1 , Z2 , Z3}, a) = {Z0, Z1, Z2 , Z3 , ZF }
δ({Z0 , Z1 , Z2 , Z3}, b) = {Z0 , Z2, Z3, ZF }

δ({Z0 , Z2 , Z3 }, a) = {Z0, Z1, Z3, ZF }
δ({Z0 , Z2 , Z3 }, b) = {Z0, Z3 , ZF }

δ({Z0 , Z1 , Z3 }, a) = {Z0, Z1, Z2, ZF }
δ({Z0 , Z1 , Z3 }, b) = {Z0, Z2 , ZF }

δ({Z0 , Z3 }, a) = {Z0, Z1 , ZF }
δ({Z0 , Z3 }, b) = {Z0, ZF }

Zustandsmenge
Z = {{Z0}, {Z0, Z1 }}

Z = {{Z0}, {Z0, Z1 }, {Z0, Z1, Z2 },
{Z0, Z2 }}
Z = {{Z0}, {Z0, Z1 }, {Z0, Z1, Z2 },
{Z0, Z2 }, {Z0, Z1, Z2 , Z3 }, {Z0 , Z2, Z3}}
Z = {{Z0}, {Z0, Z1 }, {Z0, Z1, Z2 },
{Z0, Z2 }, {Z0, Z1, Z2 , Z3 }, {Z0 , Z2, Z3},
{Z0, Z1 , Z3}, {Z0, Z3 }}
Z = {{Z0}, {Z0, Z1 }, {Z0, Z1, Z2 }, {Z0, Z2 },
{Z0, Z1 , Z2, Z3 }, {Z0, Z2 , Z3}, {Z0, Z1, Z3 },
{Z0, Z3 }, {Z0, Z1, Z2 , Z3 , ZF },
{Z0, Z2 , Z3, ZF }}
Z = {{Z0}, {Z0, Z1 }, {Z0, Z1, Z2 }, {Z0, Z2 },
{Z0, Z1 , Z2, Z3 }, {Z0, Z2 , Z3}, {Z0, Z1, Z3 }, {Z0, Z3},
{Z0, Z1 , Z2, Z3 , ZF }, {Z0, Z2, Z3, ZF },
{Z0, Z1 , Z3, ZF }, {Z0, Z3 , ZF }}
Z = {{Z0}, {Z0, Z1 }, {Z0, Z1, Z2 }, {Z0, Z2 },
{Z0, Z1 , Z2, Z3 }, {Z0, Z2 , Z3}, {Z0, Z1, Z3 }, {Z0, Z3},
{Z0, Z1 , Z2, Z3 , ZF }, {Z0, Z2, Z3, ZF },
{Z0, Z1 , Z3, ZF }, {Z0, Z3 , ZF }, {Z0, Z1 , Z2 , ZF },
{Z0, Z2 , ZF }}
Z = {{Z0}, {Z0, Z1 }, {Z0, Z1, Z2 }, {Z0, Z2 },
{Z0, Z1 , Z2, Z3 }, {Z0, Z2 , Z3}, {Z0, Z1, Z3 }, {Z0, Z3},
{Z0, Z1 , Z2, Z3 , ZF }, {Z0, Z2, Z3, ZF },
{Z0, Z1 , Z3, ZF }, {Z0, Z3 , ZF }, {Z0, Z1 , Z2 , ZF },
{Z0, Z2 , ZF }, {Z0, Z1 , ZF }, {Z0, ZF }}


------------------------------------------------------------------------
Frühjahr 08 - Thema 2

111

δ({Z0 , Z1, Z2 , Z3 , ZF }, a) = {Z0 , Z1, Z2, Z3 , ZF }
δ({Z0 , Z1, Z2 , Z3 , ZF }, b) = {Z0, Z2, Z3, ZF }

δ({Z0 , Z2, Z3 , ZF }, a) = {Z0, Z1 , Z3, ZF }
δ({Z0 , Z2, Z3 , ZF }, b) = {Z0, Z3 , ZF }

δ({Z0 , Z1, Z3 , ZF }, a) = {Z0, Z1 , Z2, ZF }
δ({Z0 , Z1, Z3 , ZF }, b) = {Z0, Z2 , ZF }

δ({Z0 , Z3, ZF }, a) = {Z0, Z1 , ZF }
δ({Z0 , Z3, ZF }, b) = {Z0, ZF }

δ({Z0 , Z1, Z2 , ZF }, a) = {Z0, Z1 , Z2, Z3}
δ({Z0 , Z1, Z2 , ZF }, b) = {Z0, Z2 , Z3}

δ({Z0 , Z2, ZF }, a) = {Z0, Z1 , Z3 }
δ({Z0 , Z2, ZF }, b) = {Z0, Z3 }

δ({Z0 , Z1, ZF }, a) = {Z0, Z1 , Z2 }
δ({Z0 , Z1, ZF }, b) = {Z0, Z2 }

δ({Z0 , ZF }, a) = {Z0, Z1}
δ({Z0 , ZF }, b) = {Z0}

Z = {{Z0}, {Z0, Z1 }, {Z0, Z1 , Z2}, {Z0, Z2 },
{Z0, Z1 , Z2 , Z3}, {Z0, Z2, Z3 }, {Z0, Z1 , Z3}, {Z0, Z3 },
{Z0, Z1 , Z2 , Z3, ZF }, {Z0, Z2 , Z3 , ZF },
{Z0, Z1 , Z3 , ZF }, {Z0, Z3, ZF }, {Z0, Z1, Z2, ZF },
{Z0, Z2 , ZF }, {Z0 , Z1, ZF }, {Z0, ZF }}
Z = {{Z0}, {Z0, Z1 }, {Z0, Z1 , Z2}, {Z0, Z2 },
{Z0, Z1 , Z2 , Z3}, {Z0, Z2, Z3 }, {Z0, Z1 , Z3}, {Z0, Z3 },
{Z0, Z1 , Z2 , Z3, ZF }, {Z0, Z2 , Z3 , ZF },
{Z0, Z1 , Z3 , ZF }, {Z0, Z3, ZF }, {Z0, Z1, Z2, ZF },
{Z0, Z2 , ZF }, {Z0 , Z1, ZF }, {Z0, ZF }}
Z = {{Z0}, {Z0, Z1 }, {Z0, Z1 , Z2}, {Z0, Z2 },
{Z0, Z1 , Z2 , Z3}, {Z0, Z2, Z3 }, {Z0, Z1 , Z3}, {Z0, Z3 },
{Z0, Z1 , Z2 , Z3, ZF }, {Z0, Z2 , Z3 , ZF },
{Z0, Z1 , Z3 , ZF }, {Z0, Z3, ZF }, {Z0, Z1, Z2, ZF },
{Z0, Z2 , ZF }, {Z0 , Z1, ZF }, {Z0, ZF }}
Z = {{Z0}, {Z0, Z1 }, {Z0, Z1 , Z2}, {Z0, Z2 },
{Z0, Z1 , Z2 , Z3}, {Z0, Z2, Z3 }, {Z0, Z1 , Z3}, {Z0, Z3 },
{Z0, Z1 , Z2 , Z3, ZF }, {Z0, Z2 , Z3 , ZF },
{Z0, Z1 , Z3 , ZF }, {Z0, Z3, ZF }, {Z0, Z1, Z2, ZF },
{Z0, Z2 , ZF }, {Z0 , Z1, ZF }, {Z0, ZF }}
Z = {{Z0}, {Z0, Z1 }, {Z0, Z1 , Z2}, {Z0, Z2 },
{Z0, Z1 , Z2 , Z3}, {Z0, Z2, Z3 }, {Z0, Z1 , Z3}, {Z0, Z3 },
{Z0, Z1 , Z2 , Z3, ZF }, {Z0, Z2 , Z3 , ZF },
{Z0, Z1 , Z3 , ZF }, {Z0, Z3, ZF }, {Z0, Z1, Z2, ZF },
{Z0, Z2 , ZF }, {Z0 , Z1, ZF }, {Z0, ZF }}
Z = {{Z0}, {Z0, Z1 }, {Z0, Z1 , Z2}, {Z0, Z2 },
{Z0, Z1 , Z2 , Z3}, {Z0, Z2, Z3 }, {Z0, Z1 , Z3}, {Z0, Z3 },
{Z0, Z1 , Z2 , Z3, ZF }, {Z0, Z2 , Z3 , ZF },
{Z0, Z1 , Z3 , ZF }, {Z0, Z3, ZF }, {Z0, Z1, Z2, ZF },
{Z0, Z2 , ZF }, {Z0 , Z1, ZF }, {Z0, ZF }}
Z = {{Z0}, {Z0, Z1 }, {Z0, Z1 , Z2}, {Z0, Z2 },
{Z0, Z1 , Z2 , Z3}, {Z0, Z2, Z3 }, {Z0, Z1 , Z3}, {Z0, Z3 },
{Z0, Z1 , Z2 , Z3, ZF }, {Z0, Z2 , Z3 , ZF },
{Z0, Z1 , Z3 , ZF }, {Z0, Z3, ZF }, {Z0, Z1, Z2, ZF },
{Z0, Z2 , ZF }, {Z0 , Z1, ZF }, {Z0, ZF }}
Z = {{Z0}, {Z0, Z1 }, {Z0, Z1 , Z2}, {Z0, Z2 },
{Z0, Z1 , Z2 , Z3}, {Z0, Z2, Z3 }, {Z0, Z1 , Z3}, {Z0, Z3 },
{Z0, Z1 , Z2 , Z3, ZF }, {Z0, Z2 , Z3 , ZF },
{Z0, Z1 , Z3 , ZF }, {Z0, Z3, ZF }, {Z0, Z1, Z2, ZF },
{Z0, Z2 , ZF }, {Z0 , Z1, ZF }, {Z0, ZF }}

F = {{Z0, Z1, Z2, Z3, ZF }, {Z0, Z2, Z3, ZF }, {Z0, Z1, Z3, ZF },

{Z0, Z3, ZF }, {Z0, Z1, Z2, ZF }, {Z0, Z2, ZF }, {Z0, Z1, ZF }, {Z0, ZF }}
Anmerkung: Die Spalte mit der Hilfesmenge wurde hier weggelassen, um den
Rest der Tabelle noch darstellen zu können!)
Im weiteren werden folgende Zustandsbezeichnungen verwendet:
F1 = {Z0, Z1, Z2, Z3, ZF }
F2 = {Z0, Z2, Z3, ZF }
F3 = {Z0, Z1, Z3, ZF }
F4 = {Z0, Z3, ZF }
F5 = {Z0, Z1, Z2, ZF }
F6 = {Z0, Z2, ZF }
F7 = {Z0, Z1, ZF }
F8 = {Z0, ZF }
S0 = {Z0}
S1 = {Z0, Z1}
S2 = {Z0, Z1, Z2}
S3 = {Z0, Z2}
S4 = {Z0, Z1, Z2, Z3}
S5 = {Z0, Z2, Z3}
S6 = {Z0, Z1, Z3}
S7 = {Z0, Z3}


------------------------------------------------------------------------
112

1 Theoretische Informatik

b)

c) A bestehe aus den Zuständen q0, q1 und q2. Es muss mindestens einen Start-
und einen Endzustand geben. Diese können nicht identisch sein, da jedes
Wort ∈ L mindestens ein b enthält, also ε 6∈ L. O. B. d. A. sei q0 der
Startzustand und q2 ein Endzustand.
Um sicherzustellen, dass ein b enthalten ist, muss es einen übergang von
einem Startzustand in einen anderen Zustand geben. Dieser ist bereits der
Endzustand, da b ∈ L ist, die Anzahl der a beträgt 0.


------------------------------------------------------------------------
Frühjahr 08 - Thema 2

113

Desweiteren kann es vom Startzustand keinen übergang mit a in einen an-
deren Zustand geben, da sonst nicht zwangsläuﬁg ein b im Wort enthalten
sein muss (ein übergang δ(q0, a) = q0 wäre möglich)
Nach der Abarbeitung von x2 beﬁndet sich der Automat weder im Start-
noch im Endzustand, also im verbleibenden Zustand q1. Nach der Abarbei-
tung von y2 beﬁndet er sich in q2, da das Wort akzeptiert wird.

Gleiches gilt für (x3, y3):

Demnach müsste der Automat auch (x2, y3) und (x3, y2) akzeptieren. Da
diese nicht in L enthalten sind, kann die Abarbeitung von x2 und x3 nicht in
denselben Zustand führen; der Automat besitzt also mehr als drei Zustände.

Aufgabe 3

Gegeben sei die Sprache L = {ww|w ∈ Σ∗} über dem Alphabet Σ = {a, b}.
a) Beweisen Sie mit Hilfe des Pumping Lemma für kontextfreie Sprachen, dass

die Sprache nicht kontextfrei ist.
Hinweis: Gehen Sie hierzu von einem Wort der Form ww = anbnanbn aus,
bei geeigneter Wahl von n.
Hinweis: Das Pumping Lemma für kontextfreie Sprachen lautet wie folgt:
Ist L kontextfrei, so existiert n ≥ 0 sodass für alle z ∈ L eine Zerlegung
der Form z = uvwxy existiert, derart, dass |vx| ≥ 1 und |vwx| ≤ n
und uviwxiy ∈ L für alle i ≥ 0.

b) Begründen Sie, dass für jedes Wort z ∈ Σ∗, das nicht in L ist, einer der fol-

genden drei Fälle zutriﬀt:

kontextfreie
Sprache,
Pumping-
Lemma

• z hat ungerade Länge, oder
• z kann in der Form z = uavbw geschrieben werden mit |u| = m,

|w| = n, |v| = m + n für geeignete m, n ≥ 0, oder

• z kann in der Form z = ubvaw geschrieben werden mit |u| = m,

|w| = n, |v| = m + n für geeignete m, n ≥ 0.

Zum Beispiel ist aabababbab /∈ L und es passt der zweite Fall mit
u = a, v = baba, w = bab , also m = 1, n = 3.

c) Begründen Sie nun, dass das Komplement Σ∗ \ L kontextfrei ist.


------------------------------------------------------------------------
114

1 Theoretische Informatik

a) Um die Anzahl der vorderen und hinteren a gleich zu halten, muss a oder b
sowohl in v als auch in x enthalten sein ((a ⊆ v ∧ a ⊆ x) ∨ (b ⊆ v ∧ b ⊆ x)),
um anschließend korrekt pumpen zu können.
Für vwx gilt demnach: vwx = abna ∨ vwx = banb. In beiden Fällen ist
|vwx| = n + 2 > n und damit ist das Pumping-Lemma in der zweiten Be-
dingung nicht erfüllt. Die Sprache ist also nicht kontextfrei.

b) Für die Wörter z ∈ L gilt, dass |z| = |ww| = 2|w|, also sind alle Wörter

ungerader Länge nicht in L.
Für die Wörter mit gerader Länge gilt, dass z von der Form z1z2 mit |z1| =
|z2| = m + n + 1 ist, wobei an der Stelle i z1i 6= z2i. D. h. es gibt eine
Position an der die erste und die zweite Worthälfte nicht übereinstimmen, es
ist also entweder z1i = a und z2i = b oder z1i = b und z2i = a. Diese Wörter
lassen sich zerlegen als z1 = uav1, z2 = v2bw bzw. z1 = ubv1, z2 = v2aw mit
|u| = |v2| = m, |v1| = |w| = n.

c) Wir geben eine kontextfreie Grammatik an, die Σ∗ \ L erzeugt:

S → AB|BA|C
A → DAD|a
B → DBD|b
C → DDC|D
D → a|b
Durch hintereinander ausgeführte (ggf. wiederholte) Anwendung der Regeln
3, 8, 9, 10 bzw. 11 erhält man die Wörter aus dem ersten in Teilaufgabe
b) beschriebenen Fall. Die Regeln 1, 4 bzw. 5 und 10 bzw. 11 führen zu
den Wörtern des zweiten Falls. Die Wörter des dritten Falls werden durch
Anwendung der Regeln 2, 6 bzw. 7 und 10 bzw. 11 erreicht.


------------------------------------------------------------------------
2

Algorithmen und
Datenstrukturen

Frühjahr 01 - Thema 1

Aufgabe 4

Beweisen Sie mit Hilfe der Zusicherungsmethode, dass das folgende Programm
bezüglich der eingefügten Zusicherungen partiell korrekt ist.
{n ≥ 0}

x := n; z := 1;
{x ≥ ∧z = 2n−x}

WHILE x > 0 DO

z := 2 ∗ z; x := x − 1;

END;
{z = 2n}

partiell
korrekt,
Schleifenin-
variante,
Hoare-Kal-
kül

Der Beweis der partiellen Korrektheit wird am Ende des Programmstücks begon-
nen.
Weil die letzte Anweisung eine WHILE-Schleife ist, muss zuerst die Schleifeninva-
riante gefunden werden. Diese lautet {z = 2n−x ∧ x ≥ 0}.

Bevor mit dem Beweis der WHILE-Schleife begonnen werden kann, muss gezeigt
werden, dass die Schleifeninvariante auch die Nachbedingung impliziert:
{z = 2n−x ∧ x ≥ 0}z = 2n

Wenn die Schleife beendet ist, gilt auf jeden Fall x = 0 und damit
z = 2n−x = 2n−0 = 2n.

Es muss nun gezeigt werden, dass gilt:
{z = 2n−x ∧ x ≥ 0 ∧ x > 0}z := 2 ∗ z; x := x − 1; {z = 2n−x ∧ x ≥ 0}

Dies wird durch Einsetzen erreicht:
{z = 2n−x ∧ x > 0}z := 2 ∗ z; {z = 2n−(x−1) ∧ x − 1 ≥ 0}
{z = 2n−x ∧ x > 0}{2 ∗ z = 2n−(x−1) ∧ x − 1 ≥ 0}
Daraus wird: (z = 2n−x ∧ x > 0) ⇒ (2 ∗ z = 2n−(x−1) ∧ x − 1 ≥ 0).


------------------------------------------------------------------------
116

2 Algorithmen und Datenstrukturen

Dies gilt, denn aus x > 0 folgt x − 1 ≥ 0
und z = 2(n−x) führt zu 2 ∗ z = 2 ∗ 2n−x = 2n−x+1 = 2n−(x−1).
Nachweis der Nachbedingung:
(z = 2n−x ∧ x ≥ 0 ∧ (x > 0)) ⇒ z = 2n, dies ist erfüllt, da x = 0.
Für die restlichen Anweisungen ist nun zu zeigen, dass
{n ≥ 0}x := n; z := 1; {z = 2n−x ∧ x ≥ 0}.

Dies erreicht man wieder durch zweimaliges Anwenden der Regel für Sequenzen:
{n ≥ 0}x := n; {1 = 2n−x ∧ x ≥ 0}
{n ≥ 0}{1 = 2n−n ∧ n ≥ 0}
Auch hierbei ergibt sich kein Widerspruch, da 2n−n = 20 = 1 ist.
Desweiteren terminiert dieses Programm immer, da zu Beginn gilt x ≥ 0 und x
innerhalb der Schleife reduziert wird; somit ist die Bedingung für die Schleife nach
n Durchläufen nicht mehr erfüllt.
Also ist die partielle Korrektheit bewiesen.

Aufgabe 5

binärer
Baum

Die folgenden Aufgaben können in Pascal, Modula-2, C, C++ oder Java gelöst
werden.
a) Deﬁnieren Sie einen Datentyp (oder eine Klasse) mit Namen

Darstellung binärer Bäume mit ganzen Zahlen als Knotenmarkierungen.
b) Ein binärer Baum t ist sortiert wenn t leer ist, oder wenn seine Wurzel n

BinTree“ zur
”

größer als alle im linken Teilbaum l von t vorkommenden Knoten und klei-
ner gleich als alle im rechten Teilbaum r von t vorkommenden Knoten ist
und wenn l und t ebenfalls sortiert sind. Implementieren Sie eine Opera-
tion mit Namen
isSorted“, die für einen gegebenen binären Baum fest-
”
stellt, ob er sortiert ist.

c) Implementieren Sie eine Operation mit Namen

insert“, die eine ganze Zahl
”

x so in einen binären Baum einfügt, dass dieser nach Ausführung der
Operation wieder sortiert ist.

a) Bemerkung: Zur besseren Lesbarkeit wurden die Bezeichnungen anders ge-

wählt als in der Aufgabenstellung vorgegeben.

public class BinTree
{

public int wurzel;
public BinTree links, rechts;

public BinTree(int wurzel){
this.wurzel =wurzel;

}

}


------------------------------------------------------------------------
Frühjahr 01 - Thema 2

117

b) public boolean isSorted() {

if (links == null) {

if (rechts == null) { return true;}
else {

if (wurzel <= rechts.wurzel)

{ return rechts.isSorted();}

else { return false;}

if (wurzel > links.wurzel) { return links.isSorted();}
else { return false;}

}

}
else {

}

}

c) public void insert(int i) {
if (i<= wurzel) {

if (links == null) {

links = new BinTree(i);
return;

}
else { links.insert(i);}

}
if (i > wurzel) {

if (rechts == null) {

rechts = new BinTree(i);
return;

}
else { rechts.insert(i);}

}

}

Frühjahr 01 - Thema 2

Aufgabe 1

Für eine nicht-leere Menge von Personen sei gegeben, wer mit wem
• eng verwandt,
• weitläuﬁg verwandt,
• bekannt (aber nicht verwandt),
• weder verwandt noch bekannt
ist. Davon ausgehend sollen folgende Aufgaben gelöst werden:

zweidimen-
sionales
Feld


------------------------------------------------------------------------
118

2 Algorithmen und Datenstrukturen

a) Für eine beliebige Person soll bestimmt werden, mit wie vielen anderen

Personen sie eng verwandt ist.

b) Es soll(en) diejenige(n) Person(en) mit den meisten Bekannten und

weitläuﬁg Verwandten bestimmt werden.

c) Es soll festgestellt werden, ob es drei Personen gibt, die untereinander

weder verwandt noch bekannt sind.

Geben Sie einen geeigneten Datentyp zur Darstellung der gegebenen Personen-
beziehungen sowie Algorithmen zur Lösung der Aufgaben a), b) und c) an.

a) Deﬁnition des Datentyps:

Die Personen werden nummeriert (0,...,n) und der Grad der Verwandschaft
kodiert mit:
0 = eng verwandt
1 = weitläuﬁg verwandt
2 = bekannt (aber nicht verwandt)
3 = weder verwandt noch bekannt

Es wird ein zweidimensionales Array mit n+1 Spalten und Zeilen erzeugt.

public class Verwandtschaft {
int[][] feld = new int[n+1][n+1];
}

Dieses Feld wird dann mit den Ziﬀern 0-3 für die jeweilige Verwandschafts-
/Bekanntschaftsbeziehung zwischen den Personen und NULL(leerer Eintrag)
auf der Diagonale (niemand ist mit sich selbst verwandt) gefüllt.

i) public int anzahl(int n) {

//die Nummer der Person wird als Parameter übergeben

int zaehler = 0;
for(int i = 0; i <= n; i++) {

if (feld[i][n]==0) { zaehler +=1; }

}
return zaehler;
}

ii) public int[] maxAnzahl() {

int maxAnz = 0;
int k = 0;
int[] anzPerson = int[n+1];
int[] erg = int[n+1];
for (int j = 0; j <= n; j++) {

int Anz = 0;
for(int i = 0; i <= n; i++) {

if (feld[i][j] = 2 || feld[i][j] = 3){

Anz +=1;
}

}


------------------------------------------------------------------------
Frühjahr 01 - Thema 2

119

if (Anz > maxAnz) { maxAnz = Anz; }
anzPerson[j] = Anz;

}
for (int j = 0; j <= n; j++) {

if (anzPerson[j] = maxAnz) {

erg[k] = j;
k +=1;

}

}
return erg;
}

iii) public boolean unbekannt(){

for (int j = 0; j <= n; j++) {

int p1 = n+2;
int p2 = n+2;
for(int i = 0; i <= n; i++) {
if (feld[j][i] = 3) {

p1 = i;
break;}

}
for (int k = i; k <= n; k++) {
if (feld[j][k] == 3) {

p2 = k;
break;}

}

if (feld[p1][p2] == 3) { return true;}
}
}

Aufgabe 3

Durch den rekursiven Algorithmus
F ≡ f unctionf (n, m : nat)nat :

if n < m then n else f (n − m, m ∗ 1) endif

ist eine Funktion f : N0 × N0 → N0 deﬁniert.
a) Bestimmen Sie den Wert von f (31, 3).
b) Beweisen Sie: Der Algorithmus F terminiert für alle n, m ∈ N0.
c) Geben Sie einen iterativen Algorithmus an, der f (n, m) für beliebige

n, m ∈ N0 berechnet.

d) Beweisen Sie: Zu jedem Paar n, m ∈ N0 × N gibt es k ∈ N mit k ∗ m < n

und 2 ∗ f (n, m) + k2 + k ∗ (2 ∗ m − 1) = 2 ∗ n.

terminie-
render,
iterativer
Algorith-
mus,
primitiv
rekursiv,
Komple-
xität


------------------------------------------------------------------------
120

2 Algorithmen und Datenstrukturen

e) Welche der drei folgenden Aussagen ist richtig?
e1) Die Zeitkomplexität von F ist O(n).
e2) Die Zeitkomplexität von F ist O(m).
e3) Die Zeitkomplexität von F ist O(n/m).
Begründen Sie Ihre Antworten.

f) Ist die Funktion f primitiv-rekursiv? Begründen Sie Ihre Antwort.

a) f (31, 3) = f (28, 4) = f (24, 5) = f (19, 6) = f (13, 7) = f (6, 8) = 6

b) Es wird eine Abstiegsfunktion g : N × N → N deﬁniert, mit g(n, m) = n − m.

Laut rekursiver Funktionsdeﬁnition (n, m) → (n − m, m + 1) ist
g(n0, m0) < g(n, m)
g(n − m, m + 1) < g(n, m)
und damit
(n − m) − m < n − m
−m < 0 wahr.
Damit ist nachgewiesen, dass der Wert für g in jedem Schritt sinkt und somit
der Algorithmus F terminiert.

y

(zum Thema Abstiegsfunktion siehe auch Frühjahr 2004 - Thema II)

c) function f(n, m:nat):nat
while n < m do

n := n - m;
m := m + 1

end while

return n;

d) Nach Teilaufgabe a) gilt:

f (n, m) = f (n − m, m + 1) = f (n − m − (m + 1), m + 2) =
= f (n − m − (m + 1) − (m + 2), m + 3) =
= f (n − 3m − 3, m + 3) =
= f (n − 3m − 3 − (m + 3), m + 4) =
= f (n − 4m − 6, m + 4) = ...

= f (n − k ∗ m −

k−1X

i=1

i, m + k) =

= f (n − k ∗ m − k ∗ (k − 1)
= n − k ∗ m − k ∗ (k − 1)

2

2

, m + k) =

Hierbei gibt k die Anzahl der rekursiven Aufrufe an.

(diese Formel gilt aber nur für k > 1)


------------------------------------------------------------------------
Frühjahr 01 - Thema 2

121

1. Fall: k = 0
Wenn k = 0 wird die Funktion 0-mal rekursiv aufgerufen, d. h. sie terminiert
im ersten Durchlauf. Dies wiederum bedeutet, dass n < m ist.
Für die Bedingungen der Aufgabe gilt dann:
0 ∗ m ≤ n
ist erfüllt und
2 ∗ f (n, m) + k2 + k ∗ (2 ∗ m − 1) = 2 ∗ n + 02 + 0 ∗ (2 ∗ m − 1) = 2 ∗ n
ist auch erfüllt.
2. Fall: k = 1
⇒ die Funktion terminiert nach einem rekursiven Aufruf,
d. h. f (n, m) = f (n − m, m + 1) = n − m
Es gilt also n > m, also auch k ∗ m = 1 ∗ m < n.
Das bedeutet für die zweite Bedingung:
2 ∗ f (n, m) + k2 + k ∗ (2 ∗ m − 1) = 2 ∗ f (n − m, m + 1) + 12 + 1 ∗ (2 ∗ m − 1) =
2 ∗ (n − m) + 1 + 2 ∗ m − 1 = 2 ∗ n
3. Fall: k > 1
Es kann nun also die obige Formel angewendet werden:
f (n, m) = f (n − k ∗ m − k∗(k−1)
Da f nur für Werte in N0 deﬁniert ist, gilt
n − k ∗ m − k∗(k−1)
≥ 0
und damit n − k ∗ m > 0 bzw. k ∗ m < n.
Einsetzen in die zweite Bedingung ergibt:
2∗f (n, m)+k2 +k ∗(2∗m−1) = 2∗(n−k ∗m− k∗(k−1)
2 ∗ n − 2 ∗ k ∗ m − k ∗ (k − 1) + k2 + 2 ∗ k ∗ m − k = 2 ∗ n

, m + k) = n − k ∗ m − k∗(k−1)

)+k2 +k ∗(2∗m−1) =

2

2

2

2

m . Somit

e) Laut Teilaufgabe d) gilt für die Anzahl der Rekursionsschritte k ≤ n

m ).

ergibt sich für die Komplexität F ∈ O( n
Eine andere Möglichkeit der Argumentation ist:
Die Zeitkomplexität von F ist weder O(n) noch O(m), da die Komplexität
von beiden Parametern abhängt. Wäre die Komplexität O(n), dann müssten
die Funktionsaufrufe f (31, 3) und f (31, 32) die gleiche Komplexität besitzen.
Dies ist aber nicht der Fall, da bei f (31, 3) 6 rekursive Aufrufe stattﬁnden
und f (31, 32) bereits im ersten Durchlauf terminiert. Gleiches gilt für O(m):
Die Funktionsaufrufe f (154, 15) und f (13, 15) haben unterschiedliche Kom-
plexität und damit kann nicht gelten F ∈ O(m). Die Komplexität von F ist
allerdings direkt proportional zu n, denn bei festem m und wachsendem n
steigt auch die Komplexität. Umgekehrt sinkt die Komplexität bei festem n
und wachsendem m, hier liegt also indirekte Proportionalität vor. Da es keine
weiteren Faktoren gibt, die die Komplexität beeinﬂussen, gilt F ∈ O( n
f) f (n, m) = f (n − m, m + 1) = f (sub(n, m), s(m)), wobei sub(n, m) und s(m)

m ).

die in Frühjahr 2001 Thema 1 Aufgabe 3 (siehe Seite 4) erwähnten primitiv x
rekursiven Funktionen sind. f ist somit als Komposition primitiv rekursiver
Funktionen selbst auch primitiv rekursiv.


------------------------------------------------------------------------
Algorith-
mus,
Baum

122

2 Algorithmen und Datenstrukturen

Herbst 01 - Thema 2

Aufgabe 1

Für eine Klasse N von
Nimm-Spielen“ gelten folgende gemeinsame Spielregeln:
”
Jedes Spiel wird von 2 Spielern A und B mit Spielsteinen auf einem Spielbrett
gespielt und beginnt in einer Anfangsstellung, in der n > 0 Spielsteine auf dem
Brett stehen. A und B machen der Reihe nach abwechselnd jeweils einen Spiel-
zug, wodurch sich eine Folge von Nachfolge-Stellungen als Spielablauf ergibt. A
macht den ersten Spielzug. In jeder Stellung stehen jedem Spieler höchstens 3
verschiedene Spielzüge zur Verfügung. Jeder Spielzug verringert die Anzahl der
Spielsteine auf dem Brett. Jede Stellung ist charakterisiert durch die Angaben,
• welcher Spieler am Zug ist,
• wieviele Spielsteine auf dem Brett stehen,
• ob A oder B gewonnen hat oder ob noch kein Spieler gewonnen hat.
Ein Spielablauf endet, wenn ein Spieler gewonnen hat oder wenn keine Spielstei-
ne mehr auf dem Brett stehen. Die Länge eines Spielablaufs ist die Anzahl der
dabei durchgeführten Spielzüge. Jedes Spiel der Klasse N deﬁniert durch seine
zusätzlichen Regeln (über Art der Spielzüge, Art der Gewinnstellungen u. a.)
eine Menge S aller seiner möglichen Spielabläufe. Geben Sie einen geeigneten
Datentyp zur Darstellung derartiger Mengen S sowie Algorithmen an, die für
eine derartige Darstellung eines Spiels folgende Aufgaben lösen:
a) Bestimmung der maximal auftretenden Länge eines Spielablaufs.
b) Bestimmung der Anzahl der Spielabläufe, in denen der Spieler A gewinnt.
c) Klärung der Frage, ob es einen Spielablauf gibt, in dem eine Stellung er-
reicht wird, in der alle möglichen Spielfortsetzungen irgendwann zum Ge-
winn des Spielers führen, der gerade nicht am Zug ist.

Zuerst der Datentyp:

S p i e l z u g

- a n z a h l S p i e l s t e i n e
- a k t u e l l e r S p i e l e r
- g e w i n n e r

0 . . 3

f o l g e Z u s t a n d

Jeder Spielzug hat bis zu drei Folgespielzüge.
D. h. im Objektdiagramm entsteht hier ein
Baum, bei dem jeder Knoten keine, ein, zwei
oder drei Kinder hat. Blätter sind diejeni-
gen Spielzüge, in denen einer der Spieler
gewonnen hat bzw. keine Spielsteine mehr
zur Verfügung stehen. Die Menge S sind al-
le möglichen Pfade durch diesen Baum.

public class Spielzug {

private int anzahlSpielsteine;
private int aktuellerSpieler:
//1 = Spieler A ist an der Reihe, 2 = Spieler B ist an der Reihe
private int gewinner;


------------------------------------------------------------------------
Herbst 01 - Thema 2

123

//0 = kein Gewinner, 1 = A gewinnt, 2 = B gewinnt
private Spielzug[] folgeSpielzug = new Spielzug[3]; }

a) Hier muss man den längsten Pfad im Baum ermitteln:

public int maxLaenge(Spielzug x) {

//die Wurzel des (Teil-)Baums wird übergeben
if (gewinner>0 || anzahlSpielsteine==0) {return 0;}
else {
return 1+ max(maxLaenge(folgeSpielzug[0]),
maxLaenge(folgeSpielzug[1]),
maxLaenge(folgeSpielzug[2]));}

} //max gibt das Maximum der übergebenen Parameter zurück

b) Es werden alle Blätter gezählt, bei denen A gewinnt:

public int gewinnA(Spielzug x) {

//die Wurzel des (Teil-)Baums wird übergeben
if (x.gewinner == 1) {return 1}
else if (x.gewinner==2 || anzahlSpielsteine==0) {return 0;}
else {
return gewinnA(x.folgespielzug[0])

+ gewinnA(x.folgespielzug[1])
+ gewinnA(x.folgespielzug[2]);}

//eine Abfrage, ob ein Spielzug NULL ist, wurde weggelassen}

c) public boolean sichererGewinner(Spielzug x) {
//die Wurzel des Baums wird übergeben
boolean erg = false;
erg = sichererGewinn(x, x.aktuellerSpieler);
while (erg == false && x.gewinner == 0

&& anzahlSpielsteine > 0) {

erg = sichererGewinner(x.folgespielzug[0])

|| sichererGewinner(x.folgespielzug[1])
|| sichererGewinner(x.folgespielzug[2]);

}

return erg;

}

public boolean sichererGewinn(Spielzug x, int aktSpieler) {
//die Wurzel des (Teil-)Baums und der anfänglich aktuelle

Spieler werden übergeben

if (x.gewinner == 0) {

return sichererGewinn(x.folgespielzug[0], aktSpieler) &&

if (x.folgespielzug[1] != NULL) {

sichererGewinn(x.folgespielzug[1], aktSpieler)} &&


------------------------------------------------------------------------
124

2 Algorithmen und Datenstrukturen

if (x.folgespielzug[2] != NULL) {

sichererGewinn(x.folgespielzug[2], aktSpieler)} ;}

else if (x.gewinner != aktSpieler) {return true;}

else {return false;}

}

Frühjahr 02 - Thema 1

Aufgabe 4

rekursiv
deﬁnierte
Funktion,
vollständige
Induktion

Man gebe explizite Darstellungen der folgenden über den ganzen Zahlen rekursiv
deﬁnierten Funktionen an:

f(x): if x < 4 then f(f(x + 2)) else x - 1 end
f(x): if x ≥ 4 then f(f(x - 2)) else x - 1 end

Hinweis: Man mache eine Fallunterscheidung für verschiedene Wertebereiche für
x und beweise die einzelnen Teilaussagen mit vollständiger Induktion!

(

• f (x) =

x − 1
f (f (x + 2))

f alls x ≥ 4
f alls x < 4

Induktionsverankerung:

f (3) = f (f (3 + 2)) = f (f (5)) = f (4) = 3
f (2) = f (f (2 + 2)) = f (f (4)) = f (3) = 3
f (1) = f (f (1 + 2)) = f (f (3)) = f (3) = 3
f (0) = f (f (0 + 2)) = f (f (2)) = f (3) = 3

Induktionsannahme:
Sei f (−n) = 3 mit n ∈ N0 bereits gezeigt. Somit gilt f (z) = 3 für −n ≤ z < 4,
z ∈ Z.
Induktionsschluss (von n auf n + 1):
f (−(n + 1)) = f (−n − 1) = f (f (−n + 2)) = f (3) = 3
Insgesamt ergibt sich also:
x − 1
3

f alls x ≥ 4
f alls x < 4

f (x) =

(

(

• f (x) =

x − 1
f (f (x − 2))

f alls x < 4
f alls x ≥ 4


------------------------------------------------------------------------
Herbst 02 - Thema 2

125

Induktionsverankerung:

f (4) = f (f (4 − 2)) = f (f (2)) = f (1) = 0
f (5) = f (f (5 − 2)) = f (f (3)) = f (2) = 1
f (6) = f (f (6 − 2)) = f (f (4)) = f (0) = −1
f (7) = f (f (7 − 2)) = f (f (5)) = f (1) = 0
f (8) = f (f (8 − 2)) = f (f (6)) = f (−1) = −2
f (9) = f (f (9 − 2)) = f (f (7)) = f (0) = −1

Es ergeben sich oﬀensichtlich zwei verschiedene Zahlenreihen für gerade und
ungerade n.

– n gerade:

2 bereits gezeigt.

Induktionsannahme:
2 = 4−n
Sei f (n) = 2 − n
Induktionsschluss (von n auf n + 2):
f (n + 2) = f (f (n + 2 − 2)) = f (f (n)) = f ( 4−n
4−(n+1)
2
– n ungerade:

2 ) = 4−n

2 − 1 = 4−n−2

2 =

2 = 7−n

Induktionsannahme:
Sei f (n) = 4 − n+1
Induktionsschluss (von n auf n + 2):
f (n + 2) = f (f (n + 2 − 2)) = f (f (n)) = f ( 7−n
7−(n+1)
2

2 bereits gezeigt.

2 ) = 7−n

2 − 1 = 7−n−2

2 =




Insgesamt ergibt sich also:
x − 1
4−n
2
7−n
2

f (x) =



f alls x < 4
f alls x ≥ 4 und x gerade
f alls x ≥ 4 und x ungerade

Herbst 02 - Thema 2

Aufgabe 2

Die Fibonaccizahlen sind nach (F ) deﬁniert

(F )

f0 = 1
f1 = 1
fi+2 = fi+1 + fi für i ≥ 0

a) Geben Sie einen funktionalen, rekursiven Algorithmus an, der die Formel

(F ) direkt umsetzt.

b) Bestimmen Sie die Komplexität dieses Algorithmus gemessen an der Zahl

der Additionen zur Berechnung von fn!

imperative,
rekursive,
funktionale
Program-
mierung,
Komple-
xität


------------------------------------------------------------------------
126

2 Algorithmen und Datenstrukturen

c) Geben Sie einen funktionalen Algorithmus an, der mit n Additionen F

berechnet.

d) Implementieren Sie diesen Algorithmus in Java.
e) Implementieren Sie einen imperativen Algorithmus in Java, der fn mit

n − 1 Additionen berechnet!

a) fibonacci :: Int -> Int

fibonacci n

| n==0 = 1
| n==1 = 1
| otherwise = fibonacci (n-1) + fibonacci (n-2)

b) Die Zahl der notwendigen Additionen AZn berechnet sich durch

AZn = AZn−1 + AZn−2 + 1. Somit wächst ihr rekursiver Berechnungsauf-
wand genau wie die Fibonacci-Zahlen selbst schneller als jede polynomielle
Funktion, er wächst exponentiell. Es gilt: O(2n)
Bemerkung: Das exponentielle Wachstum der Fibonacci-Zahlen lässt sich
einfach zeigen unter Berücksichtigung der Tatsache, dass durch die Deﬁ-
nition festgelegt wird, dass jede Fibonacci-Zahl als Summe einer positiven
Zahl und der Vorgängerzahl größer ist als die vorhergehende Fibonacci-Zahl.
fn = fn−1 + fn−2 ≤ 2fn−1 ⇒ fn ≤ 2 · 2n−1 = 2n
n−2
fn = fn−1 + fn−2 ≥ 2fn−2 ⇒ fn ≥ 2 · 2
2 = 2
⇒ (
Damit wachsen die Fibonacci-Zahlen auf jeden Fall exponentiell.

2)n−1 ≤ fn ≤ 2n

n−1
2 = (

2)n−1

√

√

c) fibonacci :: Int -> Int

fibonacci n = fibonaccih n 1 1

fibonaccih :: Int -> Int -> Int -> Int
fibonaccih n x y
| n<=1 = y
| otherwise = fibonaccih (n-1) y (x+y)

d) int fibonacci(int n) {

return fibonaccih(n, 1, 1)}

int fibonaccih(int n, int x, int y) {
if (n<=1)

return y;

else

return fibonaccih (n-1, y, x+y)

}

e) int fibonacci(int n) {

int x = 1;
int y = 1;


------------------------------------------------------------------------
Herbst 02 - Thema 2

127

if (n<=1)

return x;

else

while (n >= 2) {

int hilf = y;
y = x+y;
x = hilf;
n--;

}
return y

}

Aufgabe 3

a) Erzeugen Sie aus der gegebenen Folge einen 2-3-4 Baum:

2-3-4 Baum

22; 10; 19; 1; 13; 12; 7; 8; 5; 42; 33; 21

Fügen Sie dazu die einzelnen Elemente in gegebener Reihenfolge in einen
anfangs leeren 2-3-4 Baum ein! Stellen Sie für jeden Wert die entsprechen-
den Zwischenergebnisse und die angewendeten Operationen als Bäume dar!
b) In dem Ergebnisbaum suchen wir nun den Wert 17. Stellen Sie den Ablauf

des Suchalgorithmus an einer eigenen Zeichnung graﬁsch dar!

c) Löschen Sie nun, unter Anwendung des Algorithmus

Löschen mit Vor-
”

schau“ die Elemente mit den Werten 5, 22, 10 in der gegebenen Reihenfolge.
Stellen Sie für jeden Wert die entsprechenden Zwischenergebnisse und die
angewendeten Operationen als Bäume dar.

a)

Einfügen der
ersten
Zahlen bis zur kom-
pletten Füllung der
Wurzel

in

Aufspalten
2
Teilbäume — über-
nehmen des mittleren
Elements (19) in die
Wurzel

Einfügen von 1 und 13
in den entsprechenden
inneren Knoten

Einfügen der 12 nicht
möglich, also wieder
Aufspaltung

10 als mittleres Ele-
ment wird nach oben
geschrieben

Einfügen von 7 und 8


------------------------------------------------------------------------
128

2 Algorithmen und Datenstrukturen

Einfügen von 5 nicht
möglich, deshalb Auf-
spaltung

7 als mittleres Element
wird nach oben ge-
schrieben

Einfügen von 42 und
33

Einfügen von 21

y

(zu dieser Aufgabenstellung siehe auch Herbst 2005 - Thema II - Aufgabe 6
auf Seite 175)

b) Von der Wurzel ausgehend, wird der Baum durchsucht:

17 ist in diesem Baum nicht enthalten.

c) Die Werte 5 und 22 beﬁnden sich jeweils in einem Blatt und sind dort auch
nicht das einzige Element, weshalb beide einfach gelöscht werden können.

Die 10 steht nicht in einem Blatt. Deshalb tauscht man sie mit ihrem Nach-
folgewert (kleinstes Element des rechten Teilbaums, also der 12) aus und
löscht die 10 (nicht das einzige Element dieses Blattes!) dann im Blatt.


------------------------------------------------------------------------
Herbst 02 - Thema 2

129

Aufgabe 4

In einem Sackbahnhof mit drei Gleisen beﬁnden sich in den Gleisen Sl und S2
zwei Züge jeweils mit Waggons für Zielbahnhof A und B. Gleis S3 ist leer. Stel-
len Sie die Züge zusammen, die nur Waggons für einen Zielbahnhof enthalten!
Betrachten Sie Sl, S2 und S3 als Stapel und entwerfen Sie einen Algorithmus,
der die Züge so umordnet, dass anschließend alle Waggons für A in Sl und alle
Waggons für B in S2 stehen!

stack,
Stackopera-
tionen

Alternative 1:

Annahme:
Auf Gleis S1 und S2 sind insgesamt n Waggons vorhanden, jeder Waggon mit einer
Markierung A oder B.

Algorithmus:
Solange S1 ist nicht leer
Fahre mit dem Zug den Waggon von S1 nach S3
Ende Solange

Solange S2 ist nicht leer
Fahre mit dem Zug den Waggon von S2 nach S3
Ende Solange

Solange S3 ist nicht leer
Wenn vorderster Waggon ist mit A markiert

Fahre mit dem Zug den Waggon nach S1

Sonst

Fahre mit dem Zug den Waggon nach S2

Ende Solange

Alternative 2:

procedure umordnen(stack g1, g2, g3)
begin

// Gleis 1 leermachen und nach G3 umschichten
while(!(g1.isempty()) do
g3.push(g1.top());
g1.pop();

od;
// Gleis 2 schichten und gleich sortieren


------------------------------------------------------------------------
130

2 Algorithmen und Datenstrukturen

while (!(g2.isempty()) do

if (g2.top() = ’A’) then
g1.push(g2.top());

else

g3.push(g2.top());

g2.pop();

od;
// Gleis 3 aufteilen
while (!(g3.isempty()) do

if (g3.top() = ’A’) then
g1.push(g3.top());

else

g2.push(g3.top());

g3.pop();

od;

end;

Alternative 3:

procedure sortieren (stack S1,S2,S3)
begin

while not isempty(S1) do

if top(S1)=’B’ then push(S3, top(S1))
else push(S2, top(S1))
endif
pop(S1);

endwhile

while not isempty(S2) do

if top(S2)=’A’ then push(S1, top(S2))
else push(S3, top(S2))
endif
pop(S2);

endwhile

while not isemtpy(S3) do
push(S2, top(S3));
pop(S3);

endwhile

end


------------------------------------------------------------------------
Frühjahr 03 - Thema 1

131

Frühjahr 03 - Thema 1

Aufgabe 4

Geben Sie ein WHILE- oder LOOP-Programm für die Fakultätsfunktion an!
Makros für x := y + z und x := y · z können Sie benutzen.

WHILE,
LOOP

y := x;
y := y − 1;
WHILE y 6= 0 DO
x := x ∗ y;
y := y − 1;

END

Frühjahr 03 - Thema 2

Aufgabe 2

Betrachten Sie folgende Darstellungen von integer-wertigen Mengen:
i) eine einfach verkettete Liste ohne Mehrfachvorkommen von Elementen,
ii) ein balancierter binärer Suchbaum.

Bearbeiten Sie nun folgende Teilaufgaben:
a) Programmieren Sie für beide Darstellungen in einer funktionalen

Programmiersprache Ihrer Wahl die Suche nach einem Element! Für ii)
müssen Sie dazu einen Datentyp für einen Binärbaum deﬁnieren.

b) Ausgehend von Ihren Lösungen zu a): welche worst-case-Komplexität (in

der Elementezahl der Menge) haben Ihre beiden Suchprogramme?
c) Kennen Sie eine weitere Darstellungsweise mit einer noch besseren

Suchkomplexität? Wenn ja, beschreiben Sie diese kurz!

d) ln welcher der beiden Darstellungen i) und ii) ist das Einfügen eines Ele-

ments rechnerisch aufwändiger und warum?

einfach
verkettete
Liste,
balancierter
binärer
Suchbaum,
Komplexi-
tät

a) Konstruktor für binären Baum: (siehe dazu auch Frühjahr 04 - Thema 2) x
data BTree = EmptyTree | Tree Int BTree BTree deriving (Show)

Hierbei bezeichnet der Konstruktor EmptyTree einen leeren Baum und
Tree i l r einen Baum, dessen Wurzel mit einer ganzen Zahl i markiert
ist und der den linken Unterbaum l und den rechten Unterbaum r hat.

suche int -> BTree -> bool
suche x EmptyTree = false


------------------------------------------------------------------------
132

2 Algorithmen und Datenstrukturen

| x==i = true
| x<i = suche x l
otherwise suche x r

Suche in der linearen Liste:
suche int -> [int] -> bool
suche x [] = false

| x==(head liste) = true
otherwise suche x (tail liste)

b) Bei der linearen Liste tritt der worst case dann auf, wenn das gesuchte Ele-
ment entweder das letzte Element der Liste ist oder gar nicht vorhanden. In
diesem Fall wird die Funktion suche so oft rekursiv aufgerufen, wie die Liste
lang ist, d. h. die Komplexität beträgt O(n).
Ein Baum mit n Elementen hat eine Tiefe von log n. Beim Suchen tritt der
worst case auf, wenn sich das gesuchte Element in einem Blatt beﬁndet bzw.
nicht vorhanden ist. Dann muss der Baum einmal von der Wurzel bis zu
einem bestimmten Blatt durchlaufen werden. Wegen der Tiefe des Baumes
beträgt die Komplexität hierfür O(log n).

c) Eine bessere Komplexität als O(log n) gibt es nicht und deshalb ist der binäre

Suchbaum bereits eine optimale Lösung.

d) In der linearen Liste können Elemente prinzipiell an jeder beliebigen Stelle
eingefügt werden, da die Liste nicht sortiert ist. Der Einfachheit halber kann
das Element ganz vorne angehängt werden. Vorher muss allerdings einmal
die Funktion suche ausgeführt werden, um zu verhindern, dass das Element
bereits vorhanden ist. Die Komplexität beträgt also auch beim Einfügen
O(n).
Beim binären Suchbaum wird mit der Komplexität O(log n) die Stelle gefun-
den, an der das neue Blatt mit dem Element eingefügt werden muss. Zum
Einfügen bzw. Erzeugen des neuen Blatts werden nur einige wenige Anwei-
sungen benötigt. Anschließend muss der Baum aber wieder ausbalanciert
werden. Dies geschieht auch im worst case mit der Komplexität O(log n).
Damit beträgt der Aufwand beim Einfügen eines Elements beim binären
Suchbaum 2 ∗ O(log n) = O(log n) und ist damit geringer als bei der linearen
Liste.

Aufgabe 3

partiell
korrekt,
total
korrekt,
Abstiegs-
funktion

Betrachten Sie die folgende Schleife: WHILE i 6= 100 D0 i := i + 1.
a) Beweisen Sie die partielle Korrektheit der Schleife bezüglich der Vorbedin-

gung true und der Nachbedingung i = 100!

b) Totale Korrektheit ist nicht gegeben. Wie lautet die schwächste Vorbedin-

gung, für die totale Korrektheit besteht?


------------------------------------------------------------------------
Herbst 03 - Thema 1

133

c) Die von Ihnen in b) vorgeschlagene Veränderung der Vorbedingung erfordert
einen neuen Beweis der partiellen Korrektheit. Führen Sie diesen durch, und
geben Sie auch eine Abstiegsfunktion zur Termination des Programms an!
Weisen Sie die geforderten Eigenschaften der Abstiegsfunktion explizit nach!

a) Hier muss zuerst die Schleifeninvariante gefunden werden.

Diese lautet i ≤ 100.
{P = true}
{I = (i ≤ 100)}
WHILE i 6= 100 DO i := i + 1
{Q = (i = 100)}
Es ist nun zuerst zu zeigen, dass {(i ≤ 100) ∧ ¬(i 6= 100)}i := i + 1{i = 100}
{(i ≤ 100) ∧ (i = 100)}i := i + 1{i = 100}
{(i ≤ 100)}i := i + 1{i = 100}
{(i ≤ 100)}{i + 1 = 100}
{(i ≤ 100)}{i = 99}
Weil 99 < 100 ist, ist dies erfüllt.
Weiterhin ist zu zeigen: {true}{(i ≤ 100)}
Auch dies ist immer erfüllt und damit ist die Schleife korrekt.

b) Falls zu Beginn i > 100 ist, so terminiert das Programm nicht, sondern es
entsteht eine Endlosschleife. Die Abbruchbedingung wird nie erreicht, da i →
∞ läuft. Die schwächste Vorbedingung, so dass die Endlosschleife vermieden
wird, lautet i ≤ 100.

c) Am 1. Teil des Beweises ändert sich nichts. Im 2. Teil ist dann zu zeigen,
dass {(i ≤ 100)}{(i ≤ 100)} und auch dieser Ausdruck ist immer wahr.
Da die Schleife genau nach 100 − i Durchläufen terminiert, lautet die Ab-
stiegsfunktion f (x) = 100 − x wobei f : ] − ∞; 100] → N0.
Nun muss gelten, dass f (x0) < f (x) für x0 = x + 1 > x.
f (x + 1) = 100 − (x + 1) = 100 − x − 1 = f (x) − 1 < f (x)

Herbst 03 - Thema 1

Aufgabe 1

Für das Alphabet Σ = {0, 1}und n, m ∈ N0 sei L(n, m) ⊆ Σ∗ wie folgt deﬁniert:
L(n, m) = {w ∈ Σ∗|w enthält genau n Zeichen 0 und m Zeichen 1}.

Sprache

Geben Sie alle Elemente von L(3, 2) an!

Geben Sie ausführliche Erläuterungen zu Ihren Lösungen an!

Da man 3 der 3+2=5 Stellen für die Position der 3 Nullen auswählen muss, ergeben
sich insgesamt
1·2 = 10 verschiedene Möglichkeiten:
L(3, 2) = {00011, 00101, 01001, 10001, 00110, 01010, 10010, 01100, 10100, 11000}

= 5·4

5
3

(cid:1)

(cid:0)


------------------------------------------------------------------------
134

2 Algorithmen und Datenstrukturen

Aufgabe 2

vollständige
Induktion

Für das Alphabet Σ = {0, 1}und n, m ∈ N0 sei L(n, m) ⊆ Σ∗ wie folgt deﬁniert:
L(n, m) = {w ∈ Σ∗|w enthält genau n Zeichen 0 und m Zeichen 1}.
Beweisen Sie: Für alle n, m ∈ N0 mit n > 0 und m > 0 gilt:
L(n, m) = {0w|w ∈ L(n − 1, m)} ∪ L(n, m) = {1w|w ∈ L(n, m − 1)}.

Geben Sie ausführliche Erläuterungen zu Ihren Lösungen an!

Induktionsverankerung:
L(1, 1) = {01, 10} = {01} ∪ {10} = {0w|w ∈ {1}} ∪ {1w|w ∈ {0}} =
= {0w|w ∈ L(0, 1)} ∪ {1w|w ∈ L(1, 0)}

Induktionsannahme:
L(n, m) = {0w|w ∈ L(n − 1, m)} ∪ {1w|w ∈ L(n, m − 1)}

Induktionsschluss:
n → n + 1
L(n + 1, m) = {0w|w ∈ L(n, m)} ∪ {1w|w ∈ L(n + 1, m − 1)} =
= {0w|w ∈ L((n + 1) − 1, m)} ∪ {1w|w ∈ L((n + 1), m − 1)}
m → m + 1
L(n, m + 1) = {0w|w ∈ L(n − 1, m + 1)} ∪ {1w|w ∈ L(n, m)} =
= {0w|w ∈ L(n − 1, (m + 1))} ∪ {1w|w ∈ L(n, (m + 1) − 1)}

Aufgabe 3

Algorith-
mus,
(funktio-
nale)
Program-
mierung,
Liste

Für das Alphabet Σ = {0, 1} und n, m ∈ N0 sei L(n, m) ⊆ Σ∗ wie folgt deﬁniert:
L(n, m) = {w ∈ Σ∗|w enthält genau n Zeichen 0 und m Zeichen 1}.

In dieser Teilaufgabe soll ein Algorithmus entwickelt werden, der zu gegebenen
n, m ∈ N0 die Menge L(n, m) bestimmt. Verwenden Sie dazu eine gängige hö-
here Programmiersprache oder einen entsprechenden Pseudocode. Nehmen Sie
dabei an, dass die gewählte Sprache die Datentypen char (für Zeichen), nat
(für N0) sowie für jeden Datentyp d einen Datentyp sequ d der Listen (Sequen-
zen) von Elementen vom Typ d zur Verfügung stellt. Für Listen seien die Kon-
stante empty (leere Liste) und folgende Funktionen verfügbar:

isempty(x)
ﬁrst(x)
rest(x)
preﬁx(a,x)

(Test, ob die Liste x leer ist)
(erstes Element der Liste x)
(Liste x ohne ihr erstes Element)
(Anfügen des Elements a als neues erstes Element an die Liste x)

Zeichenketten seien als Listen von Zeichen und Mengen von Zeichenketten als
Listen von Zeichenketten repräsentiert. (Dabei sollen die Elemente einer Menge
in der Liste nicht mehrfach vorkommen.)


------------------------------------------------------------------------
Herbst 03 - Thema 1

135

1. Geben Sie einen Algorithmus an, der für ein Zeichen z und n ∈ N0 die

Zeichenkette zk (d. i. zz...z mit k Zeichen z) als Ergebnis hat!

2. Geben Sie einen Algorithmus an, der für zwei Mengen von Zeichenketten

die Vereinigung dieser Mengen als Ergebnis hat!

3. Geben Sie einen Algorithmus an, der für eine Menge M von Zeichenketten

und ein Zeichen z die Menge {zw|w ∈ M } als Egebnis hat!

4. Geben Sie (unter Verwendung von Teilaufgabe 2 und der Algorithmen un-
ter a), b) und c)) einen Algorithmus an, der für beliebige n, m ∈ N0 die
Menge L(n, m) als Ergebnis hat!

Geben Sie ausführliche Erläuterungen zu Ihren Lösungen an!

1. Anmerkung: In der Angabe muss es statt n hier k heißen!

public sequ char zHOCHk (char z, int k) {

sequ char liste = empty;
for (int i = 0; i < k; i++) {

prefix(z, liste);
}

}

return liste;
}

Im Folgenden eine funktionale Lösung in Haskell:

zeichen k mal :: Char -> Int -> [Char]
zeichen k mal z n = hzeichen k mal z [] n -- eine leere Liste uebergeben

hzeichen k mal :: Char -> [Char] -> Int -> [Char]
hzeichen k mal z string 0 = string
hzeichen k mal z string n = z:(hzeichen k mal z string (n-1))

2. public sequ char vereinigung (sequ sequ char a, sequ sequ char b) {

sequ char liste = empty;
return vereinigungH (a, b, liste)

}
public sequ char vereinigungH (sequ char a, sequ char b, sequ char c) {

while (!isempty(a)) {

prefix(first(a), c);
a = rest(a); }
while (!isempty(b)) {

prefix(first(b), c);
b = rest(b); }

return c;

}

Im Folgenden eine funktionale Lösung in Haskell:

vereinigen :: [[Char]] -> [[Char]] -> [[Char]]
vereinigen liste [] = liste
vereinigen liste1 liste2 =

= vereinigen (head(liste2):liste1) (tail(liste2))


------------------------------------------------------------------------
136

2 Algorithmen und Datenstrukturen

Wobei sequ string gleichbedeutend ist mit sequ sequ char.

3. public sequ string zM (char z, sequ string m) {

sequ string liste = new sequ string;
while (!isempty(m)) {

prefix(prefix(z, first(m)), liste);
m = rest(m)

}

return liste;
}

Im Folgenden eine funktionale Lösung in Haskell:

zeichen voranstellen :: [[Char]] -> Char -> [[Char]]
zeichen voranstellen liste z = hzeichen voranstellen liste z []
hzeichen voranstellen :: [[Char]] -> Char -> [[Char]] -> [[Char]]
hzeichen voranstellen [] z liste = liste
hzeichen voranstellen liste1 z liste2 =

= hzeichen voranstellen (tail(liste1)) z ((z:head(liste1)):liste2)

4. public sequ string Lnm (int n, int m) {

if ((n == 0) && (m == 0)) {

return empty}

else if (n == 0) return zHOCHk(1, m);
else if (m == 0) return zHOCHk(0, n);

return vereinigung (zM(0, Lnm(n-1, m)), zM(1, Lnm(n, m-1)));
}

Im Folgenden eine funktionale Lösung in Haskell:

l n m :: Int -> Int -> [[Char]]
l n m 0 m = [zeichen k mal ’1’ m]
l n m n 0 = [zeichen k mal ’0’ n]
l n m n m = vereinigen (zeichen voranstellen (l n m (n-1) m) ’0’)
(zeichen voranstellen (l n m n (m-1)) ’1’)

Herbst 03 - Thema 2

Aufgabe 5

funktionale
Program-
mierung,
vollständige
Induktion,
Terminie-
rung,
partiell
korrekt

a) Zeigen Sie mit Hilfe vollständiger Induktion, dass das folgende Programm
bzgl. der Vorbedingung x > 0 und der Nachbedingung (drei hochx) = 3x
partiell korrekt ist!
(define (drei hoch x)
(cond ((= x 0) 1)

(e1se (* 3 (drei hoch (- x 1) ) ) )

)

)


------------------------------------------------------------------------
Herbst 03 - Thema 2

137

b) Zeigen Sie, dass die gegebene Funktion(drei hoch x) unter der Vorbedingung
x ∈ N0 terminiert, indem Sie eine geeignete Terminierungsfunktion angeben
und begründen Sie, warum die von Ihnen angegebene Funktion das Ge-
wünschte leistet!

a) Induktionsverankerung: drei hoch 0 = 1 = 30

Induktionsannahme: drei hoch x = 3x
Induktionsschritt x → x + 1:
drei hoch (x+1) = 3·(drei hoch x)= 3 · 3x = 3x+1

b) Zum Beweis wird eine Abstiegsfunktion h : N → N mit h(x) = x verwendet.

h(x0) = h(x − 1) = x − 1 < x = h(x)
Damit sinkt der Wert der Abstiegsfunktion mit jedem rekursiven Aufruf und
es ist sicher, dass drei hoch terminiert.

Aufgabe 6

Gegeben sind die drei folgenden Prozeduren zur Multiplikation zweier natürli-
cher Zahlen:
(define (mult n m)

(cond ((= n 0) 0)

(e1se (+ n (mult (- n 1) m) ) )

)

)

(define (mult2 n m)

(cond ((= n 0) 0)

((even? n) (* 2 (mult2 (/ n 2) m) ) )
(e1se (+ m (mult2 (- n 1) m) ) )

)

)

(define (mult3 n m)

(define (mult-iter counter m sum)
(cond ((= counter 0) sum)

(e1se (mult-iter (- counter 1) m (+ m sum) ) )

)

)
(mult-iter n m 0) )

Geben Sie für jede dieser Prozeduren an, welchen Speicherbedarf und welchen
Zeitbedarf die jeweils erzeugten Prozesse haben! Formulieren Sie die Ergebnisse
in der O(f (n))-Notation!

Funktion
mult
mult2
mult3

Zeitkomplexität
O(n)
2*O(log (n)) = O(log (n))
O(n)

Speicherkomplexität
O(n)
O(log (n))
O(1)

funktionale
Program-
mierung,
rekursiv,
iterativ,
Komplexi-
tät,
O-Notation


------------------------------------------------------------------------
138

2 Algorithmen und Datenstrukturen

Anmerkung: Bei mult2 entsteht durch die fortgesetzte Halbierung (für gerade Wer-
te) die Zeitkomplexität O(log(n)). Im ungünstigsten Fall erhält man nach jeder
Halbierung eine ungerade Zahl, muss also einen weiteren Schritt durchführen, um
wieder bei einer geraden Zahl anzukommen. Somit entsteht hier 2*O(log (n)). Da
bei geraden Zahlen - im Gegensatz zum beim else-Teil - keine Zwischenspeicherung
notwendig ist, beträgt die Speicherkomplexität hier nur O(log(n)).

Aufgabe 7

funktionale
Program-
mierung,
Liste

Anmerkung: Da mit dem in der Originalangabe verwendeten Begriﬀ
bruch“ oﬀensichtlich
gabe hier entsprechend umgestaltet.

Ketten-
periodischer Dezimalbruch“ gemeint war, wurde die An-

”

”

Schreiben Sie in einer funktionalen Programmiersprache folgende Prozeduren:
a) Die Prozedur mymod(x,y) berechnet den Rest bei der Division von natürli-
chen Zahlen. Falls die Division aufgeht, wird der Divisor ausgegeben. Die
Parameter genügen der Vorbedingung x > 0 und y > 0.
mymod : (zahl, zahl) -> zahl

Beispiel: mymod(34, 7) = 6 wegen 34 : 7 = 4 Rest 6
mymod(12, 4) = 4 wegen 12 : 4 = 3 Rest 0

b) Die Prozedur len(x) berechnet die Anzahl der Elemente in einer Liste.

len : (liste) -> zahl

Beispiel: len([1,2,1,1,4]) = 5

c) In einer Liste werden periodische Dezimalbrüche implementiert. Sie haben

folgende Eigenschaften:

• Die Periode beginnt stets beim zweiten Eintrag der Liste und reicht
bis zu deren Ende: [2, 1, 5, 4] bedeutet dann: 2, 154 = 2, 154154154...
• falls n ≤ len(liste) ist die n. Stelle des Dezimalbruchs das n. Element

der Liste.
Beispiel: 3. Stelle ([2, 1, 5, 4])= 5

• falls n > len(liste) wird die Zählung der Periode stets am Beginn

der Periode fortgesetzt.
Beispiel: 5. Stelle ([2, 1, 5, 4]) = 1;
7. Stelle ([2, 1, 5, 4]) = 4;
8. Stelle ([2, 1, 5, 4]) = 1;
usw.

Die Prozedur n te stelle berechnet die n. Stelle des periodischen Dezi-
malbruchs.

n te stelle (liste, zahl) -> zahl

Beispiel: n te stelle([2, 1, 5, 4], 3) = 5


------------------------------------------------------------------------
Herbst 03 - Thema 2

139

d) Der Wert eines periodischen Dezimalbruchs lässt sich näherungsweise durch
die Einbeziehung seiner ersten Stellen berechnen. Sein Wert wird umso ge-
nauer, je mehr Stellen für die Berechnung verwendet werden. Sei s(n) die
n. Stelle des periodischen Dezimalbruchs und k(n) der Näherungswert des
periodischen Dezimalbruchs unter Einbeziehung der ersten n Stellen des
periodischen Dezimalbruchs, dann gilt folgende rekursive Deﬁnition:








A(n) =

0
1
s(n) ∗ A(n − 1) + A(n − 2)

B(n) =



1
0
s(n) ∗ B(n − 1) + B(n − 2)

falls n = −1
falls n = 0
falls n ≥ −1

falls n = −1
falls n = 0
falls n ≥ −1

k(n) = A(n)/B(n)

Schreiben Sie eine Prozedur, die den Näherungswert k(n) nach obigen For-
meln berechnet!

a) mymod :: Int -> Int -> Int

mymod x y

| x==y = y
| x<y = x
| otherwise mymod (x-y) y

b) len :: [Int] -> Int

len [] = 0
len x = 1 + len(tail(x))

c) n-te-stelle :: ([Int], Int) -> Int

n-te-stelle(x,1) = head(x)
n-te-stelle(x,y) = if len(x) < y

then n-te-stelle(tail(x),

mymod(y-len(x),len(tail(x))))

else n-te-stelle(tail(x), y-1)

d) perdezbruch :: [Int] -> Int -> Float

perdezbruch bruch n = (Zaehler bruch n )/(Nenner bruch n)

Zaehler :: [Int] -> Int -> Int
Zaehler bruch -1 = 0
= 1
Zaehler bruch 0
= (n-te-stelle(bruch, n))
Zaehler bruch n
*(Zaehler bruch (n-1))
+ (Zaehler bruch (n-2))

Nenner :: [Int] -> Int -> Int
Nenner bruch -1 = 1


------------------------------------------------------------------------
140

2 Algorithmen und Datenstrukturen

Nenner bruch 0
Nenner bruch n

= 0
= (n-te-stelle(bruch, n))*(Nenner bruch (n-1))

+ (Nenner bruch (n-1))

Lösung in Scheme:

(define (fa n)

(cond ((= n (-1) 0)

((= n 0) 1)
(else (+ (* (n-te-stelle li, n) (fa (n-1))) (fa (n-2))))))

(define (fb n)

(cond ((= n -1) 1)

((= n 0) 0)
(else (+ (* (n-te-stelle li, n) (fb (n-1))) (fb (n-2))))))

(define (fk n)

(/ (fa n) (fb n)))

Aufgabe 8

objekt-
orientierte
Program-
mierung,
binärer
Suchbaum

a) Implementieren Sie in einer objektorientierten Sprache einen binären

Suchbaum für ganze Zahlen! Dazu gehören Methoden zum Setzen und Aus-
geben der Attribute zahl, linker teilbaum und rechter teilbaum.

b) Schreiben Sie die Methode fuege ein(...), die eine Zahl in den Baum ein-

fügt.

c) Schreiben Sie die Methode post order( ), die die Zahlen in der Reihen-

folge postorder ausgibt!

d) Ergänzen Sie Ihr Programm um die rekursiv implementierte Methode

summe(...), die die Summe der Zahlen des Unterbaums, dessen Wurzel
der Knoten x ist, zurückgibt! Falls der Unterbaum leer ist, ist der Rückga-
bewert 0! int summe(Knoten x) {...}

e) Schreiben Sie ein Folge von Anweisungen, die einen Baum mit Namen

BinBaum erzeugt und nacheinander die Zahlen 5 und 7 einfügt! In den binä-
ren Suchbaum werden noch die Zahlen 4, 11, 6 und 2 eingefügt. Zeichnen
Sie den Baum, den Sie danach erhalten haben, und schreiben Sie die
eingefügten Zahlen in der Reihenfolge der Traversierungsmöglichkeit
postorder auf.

a) class Knoten {

private int zahl;
private Knoten l, r;
void setZahl (int z) {
zahl = z;

}


------------------------------------------------------------------------
Herbst 03 - Thema 2

141

void setZahl (int z) {
zahl = z;

}
int getZahl () {
return zahl;

}
Knoten getL () {
return l;

}
Knoten getR () {
return r;

}
void setL (Knoten k) {

l = k;

}
void setR (Knoten k) {

r = k;

}

}
class Baum {

Knoten wurzel = null; ...

b) ...

void fuege ein (int z) {

Knoten k = new Knoten();
Knoten test = wurzel;
k.setZahl(z);
if(wurzel==null) {

wurzel =k;

} else {

while(test.getZahl() != k.getZahl()) {
if(test.getZahl() < k.getZahl()) {

if(test.getL() == null) {

test.setL(k);

} else {

test test.getL();

}
} else {

if(test.getR() == null) {

test.setR(k);

} else {

test = test.getR();

}

}

} }

} }

c) void post order() {

Knoten test = wurzel;
if (wurzel==null) {


------------------------------------------------------------------------
142

2 Algorithmen und Datenstrukturen

Nichts zu drucken!“);
System.out.println(
”

} else {

if (test.getL() != null) {

test.getL().post order();

}
if (test.getR() != null) {

test.getR().post order();

}
System.out.println(test.getZahl());

} }

d) int summe(Knoten k) {

Knoten test = x;
int erg = 0;
if (test.getL()!= null) {

erg = erg + test.getL().getZahl() + summe(test.getL());

}
if (test.getR() != null) {

erg = erg + test.getR().getZahl() + summe(test.getR());

}
return erg;

}

e) Baum BinBaum = new Baum();

BinBaum.fuege ein(5);
BinBaum.fuege ein(7);

Postorder-Traversierung (l r w): 2 4 6 11 7 5


------------------------------------------------------------------------
Frühjahr 04 - Thema 1

143

Frühjahr 04 - Thema 1

Aufgabe 4

a) Erläutern Sie informell wie man mit Hilfe einer 1-Band-Turingmaschine

eine k-Band-Turingmaschine simulieren kann.

b) Begründen Sie, warum WHILE-Programme mächtiger als LOOP-Program-
me sind. (Die Begriﬀe LOOP-Programm und FOR-Programm werden in
der Literatur synonym gebraucht.)

c) Erläutern Sie, wie mit Hilfe des Reduktionsprinzips die Unentscheidbarkeit

eines Problems gezeigt werden kann.

(Mehr-
band-)Tu-
ringmaschi-
ne,
WHILE,
LOOP,
Reduktions-
prinzip,
Unent-
scheidbar-
keit

a) Die Mehrbandturingmaschine ist ein zu Turingmaschinen äquivalentes Be-
rechnungsmodell. Der Maschine steht hier nicht nur ein Band zur Verfügung,
sondern mehrere Bänder mit eigenen Schreib-Leseköpfen.

• Es stehen k (k > 0) Bänder zur Verfügung mit k unabhängigen Köpfen.
• übergangsfunktion:

δ : Z × Γk → Z × Γk × {L, R, N }k
(Zustand z, k Bandsymbole, k Bewegungen)

• Die Ein- und Ausgabe stehen jeweils auf dem ersten Band. Alle anderen

Bänder sind zu Beginn leer!

(s. [THEO], S. 97)

Satz:
Zu jeder Mehrband-Turingmaschine M gibt es eine (Einband-)Tu-
ringmaschine M’, die dieselbe Sprache akzeptiert bzw. dieselbe Funktion
berechnet.

Beweisidee:

Zunächst eine typische Konﬁguration einer Mehrband-TM:

(cid:28)

------------------------------------------------------------------------
144

2 Algorithmen und Datenstrukturen

Die Simulation durch die Einband-TM wird durch die Erweiterung des Al-
phabetes ermöglicht. Die übereinanderliegenden Bandeinträge werden zu ei-
nem Feld zusammen gefasst.

Das entstehende neue Bandalphabet: Γ0 = Γ ∪ (Γ ∪ {∗, (cid:5)})2k
Erklärung:

• Darstellung der Eingabe durch Symbole von Γ. In einem ersten Durch-

lauf wird diese in die

Mehrband-Kodierung“ umgewandelt.
”

• Ein Alphabetsymbol hat die Form: (a, ∗, b, (cid:5), c, ∗, ...) ∈ (Γ ∪ {∗, (cid:5)})2k

mit der Bedeutung:
Entsprechende Felder sind mit a; b; c; ... belegt, 1. und 3. Kopf sind
anwesend. (∗: Kopf anwesend, (cid:5) : Kopf nicht anwesend)

Problem:

Der (Einband-)TM steht nur ein Kopf zur Verfügung, der nur an einer Stelle
stehen kann. → Simulation eines übergangs der Mehrband-TM in mehreren
Schritten:

• Darstellung der Eingabe durch Symbole von Γ. In einem ersten Durch-

lauf wird diese in die

Mehrband-Kodierung“ umgewandelt.
”

• Anfangs steht der Kopf der Einband-TM M’ links von allen *-Markie-

rungen.

• Nun wandert der Kopf nach rechts, überschreibt alle *-Markierungen
und merkt sich die jeweils anzuwendenden Fälle der δ-Funktion. (Dazu
werden viele Zustände benötigt!)

• Beim

Rückweg“ nach links werden nun alle notwendigen änderungen
”
durchgeführt.


------------------------------------------------------------------------
Frühjahr 04 - Thema 1

145

b)

Die Menge der LOOP-berechenbaren Funk-
tionen ist eine echte Teilmenge der WHILE-
der
berechenbaren Funktionen. Die Klasse
primitiv rekursiven Funktionen stimmt genau mit
der Klasse der LOOP-berechenbaren Funktionen
überein, während mit WHILE-Programmen alle
µ-berechenbaren Funktionen darstellbar sind.

c) Deﬁnition (vgl. [THEO], S. 48 ﬀ):

Seien S ein Alphabet, L1, L2 ⊆ Σ∗ zwei Sprachen. L1 heißt reduzierbar auf
L2, wenn es eine totale berechenbare Funktion f : Σ∗ → Σ∗ gibt, so dass für
alle ω ∈ Σ∗ gilt:

ω ∈ L1 ⇔ f (ω) ∈ L2
(Schreibweise: L1 ≤ L2 oder auch f : L1 ≤ L2.)
Ist L2 entscheidbar und gilt L1 ≤ L2, dann ist auch L1 entscheidbar.
Umgekehrt bedeutet dies, um von einer Sprache L nachzuweisen, dass sie
unentscheidbar ist, genügt es zu zeigen, dass L0 ≤ L für eine bereits als
unentscheidbar bekannte Sprache L0. Häuﬁg werden dazu das Halteproblem
oder das Selbstanwendungsproblem verwendet.

Aufgabe 5

Ein wichtiges Problem im Bereich der Graphalgorithmen ist die Berechnung
kürzester Wege. Gegeben sei der folgende Graph, in dem Städte durch Kanten
verbunden sind. Die Kantengewichte geben Fahrzeiten an. Außer den durch
Pfeile als nur in eine Richtung befahrbar gekennzeichneten Straßen sind alle
Straßen in beiden Richtungen befahrbar.

Adjazenz-
matrix,
Dijkstra-
Algorith-
mus

a) Geben Sie zum obigen Graphen zunächst eine Darstellung als Adjazenz-

matrix an.

b) Berechnen Sie nun mit Hilfe des Algorithmus von Dijkstra die kürzesten

Wege vom Knoten A zu allen anderen Knoten.

(cid:28)

------------------------------------------------------------------------
146

2 Algorithmen und Datenstrukturen

a) Adjazenzmatrix:

b)

S
{}

{A}

{A, B}

{A, B, G}

{A, B, G, E}

{A, B, G, E, H}

{A, B, G, E, H, C}

{A, B, G, E, H, C, D}

{A, B, G, E, H, C, D, F }














0 10 70 ∞ 40 ∞ ∞ ∞
10 0 50 90 ∞ ∞ 20 90
∞ 50 0 ∞ ∞ ∞ 20 ∞
∞ 90 ∞ 0 ∞ 80 75 ∞
40 ∞ ∞ ∞ 0 ∞ ∞ 5
∞ ∞ ∞ 80 ∞ 0 ∞ 10
∞ 20 20 75 ∞ ∞ 0 ∞
∞ 90 ∞ 10 5 10 ∞ 0














A
0

0

0

0

dis
from null
dis
from null
dis
from null
dis
from null
dis
from null
dis
from null
dis
from null
dis
from null
dis
from null

0

0

0

0

0

F

C

D

G

null

null

null

B
H
E
∞ ∞ ∞ ∞ ∞ ∞ ∞
null
null
null
null
70 ∞ 40 ∞ ∞ ∞
10
null
A
A
100
60
10
B
B
A
100
50
10
B
G
A
45
50
10
E
G
A
45
50
10
E
G
A
45
50
10
E
G
A
45
50
10
E
G
A
45
50
10
E
G
A

A
null
null
40 ∞ 30
A
B
null
40 ∞ 30
A
B
null
40 ∞ 30
B
null
A
30
55
40
B
H
A
30
55
40
B
H
A
30
55
40
B
H
A
30
55
40
B
H
A

null
100
B
100
B
100
B
55
H
55
H
55
H
55
H

Aufgabe 6

Hashing,
binärer
Suchbaum

Hashtabellen bilden eine eﬃziente Datenstruktur für das so genannte Wörter-
buchproblem, bei dem auf einer Menge von Objekten die Operationen insert,
delete und member benötigt werden.

a) Skizzieren Sie die drei üblichen Vorschläge für Behandlung von Kollisionen
beim geschlossenen Hashing. Welche Probleme bringen die einzelnen Vor-
schläge mit sich und weshalb entstehen manche Probleme bei den
elaborierteren Vorschlägen nicht?

b) Beschreiben Sie, wie Löschoperationen in Hashtabellen realisiert werden

können. Was ist hierbei zu beachten?


------------------------------------------------------------------------
Frühjahr 04 - Thema 1

147

c) Beschreiben Sie eine Hashfunktion für den Fall, dass die Schlüssel der zu
verwaltenden Objekte Zeichenketten sind (d. h. die Hashfunktion soll aus
der Menge der Zeichenketten in die Menge der Zellenadressen abbilden).
Begründen Sie die Wahl Ihrer Funktion.

d) Eine Alternative zu Hashverfahren bilden binäre Suchbäume. Diese können
jedoch unausgeglichen werden. Deshalb wurden verschiedene Ansätze für
balancierte Bäume entwickelt. Stellen Sie eine Art von balancierten Bäu-
men vor. Geben Sie hierzu die Struktureigenschaften der balancierten Bäu-
me möglichst präzise an und skizzieren Sie knapp, wie diese Struktureigen-
schaften bei Einfügeoperationen erhalten bleiben.

a) Kollisionen treten dann auf, wenn die Hashfunktion zwei Einträgen den glei-
chen Platz zuweisen würde. Geschlossenes Hashing bedeutet, dass nur ein
Array mit einer bestimmten Länge zur Verfügung steht.
(Bemerkung: Die Begriﬀe oﬀenes und geschlossenes Hashing werden teilweise
genau umgekehrt verwendet. Da es aber bei der Verkettung von Listen keine
drei Kollisionsbehandlungsstrategien gibt, ist die Interpretation der Aufgabe
hier eindeutig.)
Mögliche Verfahren zur Kollisionsbehandlung sind (m ist die Länge der Hash-
tabelle, m Primzahl, 0 ≤ i ≤ m − 1):

• lineares Sondieren: es wird mit einem Faktor c zyklisch nach einer
Lücke gesucht. Hierbei können Sekundärkollisionen auftreten, wenn ein
rechtmäßiges Element seinen Tabelleneintrag durch ein überlaufele-
ment besetzt vorﬁndet.

hi(x) = (h(x) + i · c)mod m

• quadratisches Sondieren: es wird nicht mit einer konstanten Schrittwei-
te c nach einem freien Platz gesucht, sondern mit einer quadratisch
wachsenden Schrittweite. Damit vermeidet man Ballungen.

hi(x) = (h(x) + i2)mod m

• doppelte Streuadressierung, Doppel-Hashing: Bei einer Kollision an einer
Stelle i wird eine zweite Streuadresse h2(x) berechnet. Nun wird in
Schrittweiten h2(x) nach freien Stellen in der Tabelle gesucht.

hi(x) = (h(x) + h2(x) · i)mod m

b) Das Löschen von Elementen erfolgt in mehreren Schritten:

• Der entsprechende Eintrag wird gesucht.
• Das Element wird entfernt und die Zelle als gelöscht markiert. Dies
ist notwendig da evtl. bereits hinter dem gelöschten Element andere
Elemente durch Sondieren eingefügt wurden. (In diesem Fall muss beim
Suchen über den freien Behälter hinweg sondiert werden).


------------------------------------------------------------------------
148

2 Algorithmen und Datenstrukturen

• Als gelöscht markierte Elemente dürfen wieder überschrieben werden.

c) Für die Kodierung von Zeichenfolgen addiere man die ASCII-Nummern der
einzelnen Zeichen der Zeichenfolge und wende auf den resultierenden int-
Wert die Streufunktion h(x) = x mod m an.

d) Eine Art von binären Suchbäumen ist der AVL-Baum, der auch ausgegliche-
ner Baum heißt. Bei einem AVL-Baum unterscheiden sich in jedem Knoten
die Höhen der Teilbäume höchstens um 1. Außerdem besitzt ein AVL-Baum
die Eigenschaften eines binären Suchbaum, d. h. jeder Knoten hat maximal
zwei Kinder und die Knoten sind so geordnet, dass sie bei einem Inorder-
Durchlauf aufsteigend ausgegeben werden. Wenn ein neues Element eingefügt
werden soll, wird zuerst die passende Stelle im Baum gesucht und das Ele-
ment eingefügt. Dadurch kann es vorkommen, dass der Baum nicht mehr
ausgeglichen ist.

1. Fall: Der Wert der Balancierung des Sohnes des Knotens, an dem die Ba-
lancierung verletzt ist, hat das selbe Vorzeichen wie der Wert der Balancie-
rung dieses Knotens. Dann ist nur eine einfache Links- bzw. Rechtsrotation
nötig, um die Balance wiederherzustellen. Das Vorzeichen des Wertes der
Balancierung entscheidet über die Rotationsrichtung.
2. Fall: Der Wert der Balancierung des Sohnes des Knotens, an dem die Ba-
lancierung verletzt ist, hat ein unterschiedliches Vorzeichen wie der Wert
der Balancierung dieses Knotens. Dann ist eine Links-Rechts- bzw. Rechts-
Links-Rotation (Doppelrotation) nötig. Dabei wird erst eine Linksrotation
direkt unter dem Knoten mit der verletzten Balance durchgeführt und an-
schließend eine Rechtsrotation an diesem Knoten (oder genau umgekehrt je
nach Vorzeichen des Werts der Balancierung).

der Knoten 11 wurde eingefügt -
an Knoten 13 ist die Balance
verletzt und es wird unterhalb
eine Linksrotation durchgeführt

an Knoten 13 wird eine
Rechtsrotation ausgeführt

der Baum ist wieder
ausgeglichen


------------------------------------------------------------------------
Frühjahr 04 - Thema 2

149

Frühjahr 04 - Thema 2

Aufgabe 1

a) Schreiben Sie eine Methode in Java oder einer anderen imperativen Pro-
grammiersprache, die als Parameter ein Integer-Array (beliebiger Länge)
erwartet und als Wert die Summe der Array-Elemente zurück gibt. Es
wird nicht nur die Korrektheit des Programms, sondern auch der Pro-
grammierstil bewertet!

b) Geben Sie die Schleifeninvariante an, die man für einen Korrektheitsbeweis

des Programms im Hoare-Kalkül benutzen würde.

c) An welchen Stellen im Programm muss die Schleifeninvariante gelten?

Feld,
Methode,
imperative
Program-
mierung,
Schleifenin-
variante,
Hoare-
Kalkül,
Korrektheit

a) int arsum (int[] feld) {
int sum = 0;
for (int i = 0; i < feld.length; i++) {

sum = sum + feld[i];

}
return sum;

}

b) sum +

f eld.lengthP

j=i

f eld[j] ==

f eld.lengthP

0

f eld[j]

c) Beim Korrektheitsbeweis für einen Algorithmus mittels einer Schleifeninva-
riante ist zu zeigen, dass die Schleifeninvariante bei Initialisierung, Aufrecht-
erhaltung und Beendigung der Schleife eingehalten wird; d. h. die Invariante
muss direkt vor, während und direkt nach dem Schleifendurchlauf gültig sein.

Aufgabe 2

Benutzen Sie eine funktionale Programmiersprache Ihrer Wahl.
a) Deﬁnieren Sie einen Datentyp für einen Binärbaum, dessen Knoten mit In-

tegerwerten behaftet sind.

b) Programmieren Sie eine Funktion, die einen solchen Binärbaum als Para-

meter erwartet und seine Knotenwerte in einer Liste in Breitenordnung zu-
rück gibt. Es wird nicht nur die Korrektheit des Programms, sondern auch
der Programmierstil bewertet!

funktionale
Program-
mierung,
binärer
Baum,
Breiten-
suche,
Korrektheit

a) data BTree = EmptyTree | Tree Int BTree BTree deriving (Show)
Hierbei bezeichnet der Konstruktor EmptyTree einen leeren Baum und
Tree i l r einen Baum, dessen Wurzel mit einer ganzen Zahl i markiert
ist und der den linken Unterbaum l und den rechten Unterbaum r hat.


------------------------------------------------------------------------
150

2 Algorithmen und Datenstrukturen

b) bslin::BTree->[Int]
bslin t = bslinh [t]

bslinh::[BTree]->[Int]
bslinh [] = []
bslinh (EmptyTree:li) = bslinh li
bslinh ((Tree i l r):li) = i:(bslinh(li++[l,r]))

bslin::BTree->[Int] ist eine HASKELL-Funktion, die alle Markierungen
eines Binärbaumes in der Linearisierung entsprechend der Breitensuche als
Liste anordnet. Dazu wird zunächst die Hilfsfunktion bslinh mit einer Liste
aufgerufen, die als Argument eine Liste von Binärbäumen erhält. Aus dieser
Liste wird jeweils die Markierung der Wurzel des ersten Elements in die
Ergebnisliste geschrieben und die Unterbäume an die Argumentliste hinten
angehängt.

Aufgabe 4

funktionale
Program-
mierung,
Abstiegs-
funktion,
Terminie-
rung

Hier ist eine Funktion (in Haskell kodiert), die angibt, ob die ihr übergebene
ganze Zahl gerade oder ungerade ist:
even :: Int -> Bool
even x = if x < O then even (-x)

else if x==O then True

else if x==1 then False

else even (x-2)

Geben Sie eine Abstiegsfunktion h an, die die Terminierung von even für alle
Eingabewerte belegt:
a) Geben Sie die Funktionsvorschrift von h an.
b) Zeigen Sie, dass h die Eigenschaften einer Abstiegsfunktion erfüllt!

a) Eine Abstiegsfunktion ist eine Funktion, mit der nachgewiesen werden kann,
dass eine Rekursion terminiert. Ihre Werte müssen sich bei jedem Aufruf
verringern und es muss sicher gestellt sein, dass es ein Minimum für die
Werte der Abstiegsfunktion gibt.
Eine mögliche Funktionsvorschrift für h lautet: h : N → N, h(x) = x − 1

b) Laut rekursiver Funktionsdeﬁnition x0 = x − 2 ist

h(x0) < h(x)
h(x − 2) < h(x)
und damit
(x − 2) − 1 < x − 1
x − 3 < x − 1
−3 < −1 wahr.
Damit ist nachgewiesen, dass der Wert von h(x) mit jedem Rekursionsschritt
sinkt; da er in N aber nicht endlos sinken kann, terminiert die Rekursion.


------------------------------------------------------------------------
Frühjahr 04 - Thema 2

Aufgabe 5

151

In dieser Frage betrachten wir Verfahren zum Sortieren eines Arrays von Werten
aus einer total geordneten Menge.
a) Wie ist präzise deﬁniert, dass eine Funktion g in O(f (n)) ist?
b) Beim Heapsort-Verfahren bringt eine Funktion heapify das Eingabe-Array

in eine bestimmte Form. Beschreiben Sie diese
und präzise.

Heap-Eigenschaft“ kurz
”

c) Zu welcher O-Klasse gehören die folgenden beiden Sortierverfahren? Bitte

Sortieralgo-
rithmus,
Heapsort,
Quicksort,
Feld, Kom-
plexität,
O-Notation

eine kurze Begründung angeben.

i) Quicksort
ii) Heapsort

a) Die exakte Deﬁnition des Landau-Symbols lautet folgendermaßen:

g ist von der Ordnung f genau dann, wenn es Zahlen c, n0 gibt, so dass für
alle n ∈ N , mit n > n0 gilt: 0 ≤ g(n) ≤ c · f (n)

O(f (n)) = {g : ∃c > 0, ∃n0 ∀n ∈ N, n > n0 : 0 ≤ g(n) ≤ c · f (n)}

b) Ein Heap ist ein binärer Baum mit zwei Eigenschaften:

• Der Baum ist vollständig ausgeglichen, d. h. alle Teilbäume unterschei-

den sich im Niveau um maximal 1.

• Jeder Knoten enthält ein Element aus einer geordneten Menge und für
jeden Knoten gilt, dass sein Element größer oder gleich den Elementen
seiner Söhne ist.

Wenn ein Heap aus einem n-elementigen Array aufgebaut werden soll, dann
werden die Elemente schichtweise in einen binären Baum mit n Knoten ein-
getragen. Anschließend werden die Knoteninhalte so vertauscht, dass sich
das größte Element jedes Teilbaums in dessen Wurzel beﬁndet. Das größte
Element des Arrays steht dann also in der Wurzel des Heaps.

c)

i) Quicksort hat im worst case eine Laufzeit von O(n2), wenn nämlich stets
das größte bzw. kleinste Element der zu sortierenden Folge als Pivotele-
ment ausgewählt wird. Hierbei entsteht bei der Aufspaltung in Teilfel-
der stets ein Teilfeld der Länge 1 und Quicksort arbeitet nicht eﬀektiv.
Im best case, wenn also stets das mittlere Element als Pivotelement
gewählt wird, hat Quicksort eine Laufzeitkomplexität von O(n log n),
da die Aufteilung in Teilfelder stets optimal ist.

ii) Heapsort hat auch im worst case eine Laufzeit von O(n log(n)). Auch
wenn stets das kleinste Element des Heaps gesucht wird, wird dieses
in log n Schritten gefunden, da ein Baum mit n Knoten die Höhe log n
besitzt. Heapsort besitzt also eine stabile Laufzeit.


------------------------------------------------------------------------
152

2 Algorithmen und Datenstrukturen

Herbst 04 - Thema 1

Aufgabe 1

Algorith-
mus,
Feld

Jede Karte in einem Kartenspiel hat eine Farbe Kreuz, Pik, Herz oder Karo und
einen Wert. Mögliche Werte sind die Zahlenwerte 2 bis 10, die Bildwerte Bube,
Dame, König sowie der Wert As. Eine Kartenverteilung besteht aus 12 Karten.
Geben Sie einen geeigneten Datentyp zur Darstellung von Kartenverteilungen
sowie Algorithmen an, die für eine derartige Darstellung Folgendes leisten:
a) Für eine Kartenverteilung v und eine Karte k soll festgestellt werden, ob

k in v enthalten ist.

b) Für eine Kartenverteilung v soll die Anzahl der in v enthaltenen Karten k
mit folgender Eigenschaft bestimmt werden: k hat einen Bildwert, und v
enthält kein As von gleicher Farbe.

Zuerst einmal der Datentyp:

K a r t e n v e r t e i l u n g

1 2

K a r t e

- f a r b e   =   ( p i k ,   k r e u z ,   k a r o ,   h e r z )

        h a t

1

W e r t

+ i s t B i l d ( ) :   b o o l e a n

Z a h l e n w e r t

B i l d w e r t

- W e r t :   i n t   =   ( 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 1 0 )
+ g i b W e r t ( ) :   i n t

- W e r t :   S t r i n g   =   ( " B u b e " ,   " D a m e " ,   " K ö n i g " ,   " A s " )
+ g i b W e r t ( ) :   i n t

a) boolean searchK (k: Karte, v: Kartenverteilung){

for (int i == 0; i < 12; i++){

if ((v[i].farbe == k.farbe) &&

(v[i].gibWert() == k.gibWert()))
{return true;}

}
return false;

}

b) int anzahl(v: kartenverteilung) {

int anz = 0;
Karte k;
k.wert = ’As’;


------------------------------------------------------------------------
Herbst 04 - Thema 1

153

for (int i == 0; i < 12; i++) {

if (v[i].istBild() &&

(v[i].gibWert() <> k.gibWert())) {
k.farbe = v[i].farbe;
if (searchK (k,v) == false) {anz++;}
}
return anz;
}

}

Aufgabe 2

Gegeben sei die Funktionsvereinbarung (in Pseudocode-Notation)
function f (x, y:integer)integer:

if x < −y then x − y else f (x + 2, y − 3) endif

a) Bestimmen Sie den Wert von f (−5, 8).
b) Beweisen Sie: f terminiert für alle integer-Zahlen x, y.
c) Geben Sie einen iterativen Algorithmus an, der f (x, y) für beliebige

integer-Zahlen x, y berechnet.

iterativer
Algorith-
mus,
Abstiegs-
funktion,
terminieren

a) f (−5, 8) = f (−3, 5) = f (−1, 2) = f (1, −1) = f (3, −4) = 3 − (−4) = 7

b) Zum Beweis wird eine Abstiegsfunktion h : N → N mit h(x, y) = x + y

verwendet.
h(x0, y0) < h(x)
h(x + 2, y − 3) < h(x)
Es gilt:
(x + 2) + (y − 3) = x + y − 1 < x + y
Damit sinkt der Wert der Abstiegsfunktion mit jedem rekursiven Aufruf und
es ist sicher, dass f terminiert.

c) function f(x, y: integer): integer

begin

while (x ≥ -y)
begin

x = x + 2;
y = y - 3;

end;
f = x - y;

end;


------------------------------------------------------------------------
154

2 Algorithmen und Datenstrukturen

Aufgabe 4

AVL-
Baum,
Rotation,
Laufzeit

a) Deﬁnieren Sie in Pseudocode oder einer höheren Programmiersprache

eine geeignete Datenstruktur zur Repräsentation von AVL-Bäumen. Schrei-
ben Sie sodann eine Funktion, die überprüft, ob ein beliebiges Element die-
ser Datenstruktur tatsächlich ein AVL-Baum ist. Zu Ihrer Information:
Solch eine Funktion kann zu Testzwecken sinnvoll sein, spielt aber bei der
regulären Verwendung von AVL-Bäumen keine Rolle. Beachten Sie, dass ein
AVL-Baum insbesondere auch ein binärer Suchbaum ist.

b) Schreiben Sie eine Funktion, die eine Linksrotation der Wurzel eines AVL-
Baumes durchführt. Beschreiben Sie detailliert, welche Form der Balan-
cierungsstörung durch diese Rotation behoben werden kann und in wel-
chen Situationen (Einfügen, Löschen) es zu ihr kommen kann. Geben Sie
die Laufzeit ihrer Implementierung mit Hilfe der O-Notation an.

a) /* Knoten fuer AVL Baum */

class AVLNode {
int content; // Inhalt, hier integer
byte balance; // fuer Werte -2, -1, 0, 1, +2
AVLNode left; // linker Nachfolger
AVLNode right; // rechter Nachfolger

AVLNode (int c) { // Konstruktor fuer neuen Knoten

content = c; // uebergebener Inhalt
balance = 0; // Balance ausgeglichen
left = right = null; // erst mal keine Nachfolger
}

}

class AVL Tree {
AVLNode root; // Die Wurzel des Baumes
AVLTree () { // Konstruktor fuer leeren Baum

root = null; // Wurzel erst mal leer

}

überprüfung, ob ein Baum ein AVL-Baum ist:
Es sind zwei Eigenschaften zu überprüfen - einerseits die Ordnung des binären
Suchbaums und andererseits die Höhenbalanciertheit des AVL-Baums.
Hier nur die überprüfung der AVL-Eigenschaft:

boolean pruefe(t : AVLNode) { //es wird direkt ein Knoten bzw.
die Wurzel übergeben

if ((t.balance < -1) || (t.balance > 1)) {

return false;}


------------------------------------------------------------------------
Herbst 04 - Thema 1

155

else {

}

if (t.left != null) {pruefe(t.left);}
else if (t.right != null) {pruefe(t.right);}
else {return true;}

b) void links(t : AVLNode) {

//es wird wieder direkt die Wurzel übergeben

AVLNode help = t; //Hilfsknoten mit gleichen Zweigen wie t
help.right = t.right.left; //der umgehaengte Zweig

//an der linken Seite der Wurzel
//aendert sich nichts

t.right.left = help; //umhaengen des neuen linken Teilbaums
t = t.right;

}

Die Laufzeit ist unabhängig von der Größe des Baums, es werden immer 4
Anweisungen ausgeführt. Es liegt also konstante Laufzeit O(1) vor. Dieser
Algorithmus wird immer dann aufgerufen, wenn die Balance an einer Stelle
+2 beträgt.
Graﬁsche Veranschaulichung des Algorithmus:


------------------------------------------------------------------------
156

2 Algorithmen und Datenstrukturen

Herbst 04 - Thema 2

Aufgabe 7

Adjazenz-
matrix,
Dijkstra-
Algorith-
mus,
Prioritäts-
warte-
schlange,
Heap

Ein gerichteter Distanzgraph sei durch seine Adjazenzmatrix gegeben. (In einer
Zeile stehen die Längen der von dem Zeilenkopf ausgehenden Wege.)

M A P R N
M − 5 10 − −
A − − 3 9 1
P − 2 − 1 −
R − − − − 4
N 7 − − 6 −

a) Stellen Sie den Graph in der üblichen Form dar.
b) Bestimmen Sie mit dem Algorithmus von Dijkstra ausgehend von M kür-

zeste Wege zu allen anderen Knoten.

c) Beschreiben Sie wie ein Heap als Prioritätswarteschlange in diesem Algo-

rithmus verwendet werden kann.

d) Geben Sie die Operation:

entfernen des Minimums“ für einen Heap an.
”

Dazu gehört selbstverständlich die Restrukturierung des Heaps.

a)


------------------------------------------------------------------------
Herbst 04 - Thema 2

157

b)

S
∅

S
M

S
M, A

M
0

dis
from null

P

R

A
N
∞ ∞ ∞ ∞
null
null

null

null

A
M
dis
5
0
from null M

P
N
R
10 ∞ ∞
null
M null

A
M
dis
5
0
from null M

P
8
A

R
14
A

N
7
A

S
M, A, N

S
M, A, N, P

S
M, A, N, P, R

M A P R N
dis
7
8
0
5
from null M A N A

13

M A P R N
dis
7
8
0
5
from null M A P A

9

M A P R N
dis
7
8
0
5
from null M A P A

9

c) zu Prioritätswarteschlagen:

Eine Datenstruktur, in der Elemente verwaltet werden, die durch Prioritäts-
ordnung verwaltet sind (veralg. FIFO). In dieser Aufgabe wird davon ausge-
gangen, dass das kleinste Element die höchste Priorität besitzt.
Operationen: insert, delete, deleteMin, ﬁndMin, decreaseKey, merge

zu Heaps:
Ein Heap ist ein vollständiger Binärbaum. Jeder Schlüssel eines Knotens ist
kleiner (in unserem Fall größer) oder gleich den Schlüsseln der vorhandenen
Kinderknoten.

Der Heap wird willkürlich als vollständiger Binärbaum aufgebaut und danach
ausgeglichen bis ein Heap entsteht. Danach das kleinste Element (= Element
mit der höchsten Priorität) herausnehmen → Baum ausgleichen bis wieder
ein Heap entsteht. Anschließend die Knoten des Heaps nach dem Algorithmus
aktualisieren. → Minimum löschen → usw.


------------------------------------------------------------------------
158

d)

2 Algorithmen und Datenstrukturen

Heap aus Aufga-
be b)

Entfernen
Wurzel

der

neuer Heap

des
Versickern
Elements
ganz
rechts auf der
untersten Ebene

Frühjahr 05 - Thema 1

Aufgabe 1

Klasse,
Methode,
doppelt
verkettete
Liste

Betrachten Sie folgendes Klassendiagramm, das doppelt-verkettete Listen spe-
ziﬁziert. Die Assoziation head zeigt auf das erste Element der Liste. Die Asso-
ziationen previous und next zeigen auf das vorherige bzw. folgende Element.

D o u b l y L i n k e d L i s t

h e a d

1

L i s t E l e m

  p r e v i o u s
1

  i n s e r t ( i : I n t e g e r )
  c h e c k ( ) :   B o o l e a n

  d a t a :   I n t e g e r

  i n s e r t ( i : I n t e g e r )

  n e x t
1

Implementieren Sie die doppelt-verketteten Listen in einer geeigneten objekt-
orientierten Sprache (z. B. Java oder C++), das heißt:
a) Implementieren Sie die Klasse ListElem. Die Methode insert ordnet eine
ganze Zahl i in eine aufsteigend geordnete doppelt-verkettete Liste l an
die korrekte Stelle ein. Sei z. B. das Objekt l eine Repräsentation der Liste
< 0, 2, 2, 6, 8 >; dann liefert l.insert(3) eine Repräsentation der Liste
< 0, 2, 2, 3, 6, 8 >.



------------------------------------------------------------------------
Frühjahr 05 - Thema 1

159

a) Implementieren Sie die Klasse DoublyLinkedList, wobei die Methode

insert eine Zahl i in eine aufsteigend geordnete Liste einordnet. Die Me-
thode check überprüft, ob eine Liste korrekt verkettet ist, d. h. ob für je-
des ListElem-Objekt o, das über den head der Liste erreichbar ist, der Vor-
gänger des Nachfolgers von o gleich o ist.

a) public class ListElem{
private int data;
private ListElem previous;
private ListElem next;

public ListElem(int i)
{data = i;}

public ListElem()
{}

public void insert(int i) {

ListElem hilf = new ListElem(i);
if (i <= data) {

if (previous != null) {
hilf.next = this;
hilf.previous = previous;
previous.next = hilf;
previous = hilf;

} else {

hilf.next = this;
previous = hilf;

}

}
else {

if (next != null) {
next.insert(i);

} else {

hilf.previous = this;
next = hilf;

}

}

}
public ListElem getPrevious() {return previous;}
public ListElem getNext()) {return next;}
public int getData() {return data;}

}

b) public class DoublyLinkedList{

private ListElem head;

public DoublyLinkedList()
{ }


------------------------------------------------------------------------
160

2 Algorithmen und Datenstrukturen

public void insert(int i) {
if (head != null) {
head.insert(i);
if (i < head.getData()) {head = head.getPrevious();}

}
else {head = new ListElem(i);}

}

public boolean check() {

ListElem aktElem = head;
while(aktElem.getNext() != null){

if (aktElem.getNext().getPrevious() != aktElem) {

return false;}

else {aktElem = aktElem.getNext();}

}
return true;

}

}

Aufgabe 3

Klasse,
Methode,
terminie-
rende
Methode,
call by
value, call
by reference

a) Erläutern Sie den Begriﬀ der dynamischen Bindung bei Methodenaufrufen

in objekt-orientierten Sprachen.

b) Die folgenden Java-Klassen sollen Daten über Personen speichern. Die Me-
thode getSalary in der Klasse Person soll das Gehalt einer Person als Er-
gebnis liefern. Die Methode getSalary in der Klasse Manager soll die Sum-
me aus dem Managerzuschlag und dem Personen-Gehalt als Ergebnis liefern.
class Person {
String name;
double salary;
public double getSalary() {

return salary;}}
class Manager extends Person {

double extraSalary;
public double getSalary() {

return (extraSalary + getSalary());}
public static void main (String[] args) {

Person p = new Manager();
p.salary = 5000;
p.getSalary();}}

Terminiert die Methode main? Begründen Sie Ihre Antwort. Wie kann man
die Implementation verbessern?

c) Erklären Sie die Parameterübergabemechanismen call by value und

call by reference.


------------------------------------------------------------------------
Frühjahr 05 - Thema 1

161

d) Welche Ausgabewerte liefert die folgende Methode main? Erklären Sie
insbesondere die letzte Ausgabezeile. Begründen Sie Ihre Antwort.
class CallBy {

static int changei(int i) {

return (++i);}

public static void main (String[] args) {

int i = 2;
System.out.println(,,i ist vorher’’ + i);
int i return = changei(i);
System.out.println(,,changei lieferte’’ + i return + ,,zurueck’’);
System.out.println(,,i ist nachher’’ + i);}}

a) In objektorientierten Programmiersprachen können innerhalb von Klassen-
hierarchien (Oberklassen mit Unterklassen) bestimmte Methoden einer Ober-
klasse innerhalb einer Unterklasse
überschrieben“ (d. h. mit gleichem Na-
”
men neu deﬁniert) werden. Ruft man nun für das in einer Variablen ge-
speicherte Objekt eine bestimmte Methode auf, gibt es für die Methoden-
ausführung zwei Kandidaten:
1. Die Methode der Oberklasse
2. Die überschriebene Version der Unterklasse
Von dynamischer Bindung spricht man in diesem Zusammenhang dann, wenn
erst zur Laufzeit in Abhängigkeit von der Tatsache, ob das Objekt eine In-
stanz der Ober- oder einer Unterklasse ist, entschieden wird, welche Version
der jeweiligen Methode aufgerufen wird. Bei der Verwendung von dynami-
scher Bindung ist also zum Zeitpunkt der Compilierung noch nicht klar, ob
später die Methode der Oberklasse oder einer Unterklasse ausgeführt wird.
Es ist auch möglich, dass die Methode nur in mehreren Subklassen imple-
mentiert ist, und zur Laufzeit entschieden wird, zu welcher Subklasse das
Objekt gehört.
Soll stattdessen immer die Methode einer Oberklasse genutzt werden, so
spricht man von statischer Bindung. Viele objektorientierte Programmier-
sprachen erlauben, für jede Methode einzeln festzulegen, ob statische oder
dynamische Bindung anzuwenden ist.
Die dynamische Bindung ist von enormer Bedeutung für die objektorientier-
te Programmierung, da die Flexibilität des Vererbungsprinzips nur durch
dynamische Bindung zum Tragen kommt.

b) In der main-Methode wird zuerst ein Objekt der (Unter-)Klasse Manager
erzeugt und dessen (von der Klasse Person geerbtes) Attribut salary auf
den Wert 5000 gesetzt. Nun wird die Methode getSalary() aufgerufen. Da
diese in der (Ober-) Klasse Person deﬁnierte Methode in der (Unter-)Klasse
Manager überschrieben wird, wird nun extraSalary + getSalary() aus-
geführt. Innerhalb dieser Programmzeile kommt es zum erneuten Aufruf der
Methode getSalary(), was sich dann rekursiv fortsetzt; die main-Methode
terminiert also nicht.
Man kann die Methode getSalary() umbenennen in z. B. calcSalary().


------------------------------------------------------------------------
162

2 Algorithmen und Datenstrukturen

Die letzte Zeile der main-Methode lautet dann p.calcSalary();. Somit ﬁn-
det kein rekursiver Aufruf mehr statt und die main-Methode terminiert.

c) call by reference: gängige Parameterübergabe in imperativen Programmier-
sprachen, wobei die Prozedur unmittelbar mit den aktuellen Parametern
arbeitet und nicht nur mit Kopien der Werte. Wird für einen Parameter in
einer Prozedur die übergabeart call by reference angegeben, so wird beim
Prozeduraufruf nur die Adresse des aktuellen Parameters, unter welcher der
Ausdruck im Speicher steht, übergeben.
call by value: übergabeart für Parameter einer Prozedur, bei der beim Pro-
zeduraufruf nur der Wert des aktuellen Parameters übergeben wird, nicht
jedoch der Name oder die Adresse, unter welcher der Ausdruck im Speicher
steht.
(s. [DUD], Stichworte

call by value“ und

call by reference“)

”

”

d) Die Ausgabe lautet:

i ist vorher 2
changei lieferte 3 zurueck
i ist nachher 2

Da die Methode changei(int i) nur eine Kopie des Wertes der übernimmt,
damit arbeitet und dann das Ergebnis der Berechnungen wieder als Wert
zurückgibt (call by reference), bleibt der Wert der in der main-Methode auf
2 gesetzten Variablen i erhalten.

Aufgabe 4

Hoare-
Kalkül,
Veriﬁka-
tion,
Vorbe-
dingung,
Nachbe-
dingung,
Schleifenin-
variante,
Zusiche-
rung,
Termina-
tion

a) Erläutern Sie die auf Floyd und Hoare zurückgehende Veriﬁkationsmethode.
(In Ihrer Antwort müssen Sie mindestens die Begriﬀe von Zusicherung,
schwächste und stärkste Nachbedingung erklären.)

b) Eine Bank bietet ihren Kunden 1% Zinsen pro Monat. Betrachten Sie das
folgende Hoare-Triple (*), das das Anwachsen eines Geldbetrags B be-
schreibt, wenn ein Kunde diesen eine gewisse Anzahl von Monaten M auf
seinem Konto stehen lässt.
(*)

{betrag = B, Zeitraum = M, M > 0 }
while (Zeitraum > 0) {
betrag = betrag*(1+1/100);
Zeitraum = Zeitraum - 1
}
{betrag = B ∗ (1 + 1/100)M }

b1) Zeigen Sie, dass {betrag = B · (1 + 1/100)M−zeitraum, zeitraum ≥ 0}

eine Schleifeninvariante ist.

b2) Beweisen Sie die Gültigkeit von (*).
b3) Terminiert das Programm immer? Beweisen Sie Ihre Antwort.

(cid:27)

------------------------------------------------------------------------
Frühjahr 05 - Thema 1

163

a) Mit der Veriﬁkationsmethode wird die Korrektheit eines Programm(stücks)
bewiesen. Die Wirkung eines Programms oder Codefragments kann durch
die Angabe von Prädikaten zu Beginn und am Ende des Codes speziﬁziert
werden. Zusicherungen sind prädikatenlogische Aussagen über die Werte der
Programmvariablen an den Stellen im Programm, an denen die jeweiligen
Zusicherungen stehen. Eine Zusicherung vor einer bestimmten Anweisungs-
folge wird auf diese bezogen als Vorbedingung (
pre-condition“) bezeichnet.
”
Entsprechend nennt man eine Nachbedingung (
post-condition“) eine Zusi-
”
cherung nach einer Anweisungsfolge. Vorbedingung und Nachbedingung des
gesamten Programms bilden eine prädikatenlogische Speziﬁkation.
Eine Veriﬁkation prüft, ob ein Programm bestimmte Zusicherungen erfüllt,
d. h. ob die Nachbedingung Q einer Anweisungsfolge A nach Abarbeitung
der Anweisungen aus der Vorbedingung P ableitbar ist.
Bei der Methode von Floyd und Hoare wird ausgehend von der stärksten
Nachbedingung die schwächste Vorbedingung gesucht. P heißt schwächer als
P 0 genau dann, wenn P 0 → P gilt.

b) b1) Es muss gezeigt werden, dass die Schleifeninvariante während des Durch-
laufens der Schleife gilt, also dass {I ∧ B}p{I}, wobei I die Schleifenin-
variante und B die Schleifenbedingung ist.
{(betrag = B · (1 + 1/100)M −Zeitraum, Zeitraum ≥ 0)
∧ (Zeitraum > 0)}betrag = betrag ∗ (1 + 1/100);
Zeitraum = Zeitraum − 1;
{betrag = B · (1 + 1/100)M −Zeitraum}
{betrag = B · (1 + 1/100)M −Zeitraum, Zeitraum > 0}betrag = betrag ∗ (1 +
1/100);
{betrag = B · (1 + 1/100)M −(Zeitraum−1)}
{betrag = B · (1 + 1/100)M −Zeitraum, Zeitraum > 0} {betrag ∗ (1 + 1/100) =
B · (1 + 1/100)M −Zeitraum+1}
{betrag = B · (1 + 1/100)M −Zeitraum, Zeitraum > 0}
{betrag = B · (1 + 1/100)M −Zeitraum}
Diese Bedingung ist korrekt und damit ist I eine Schleifeninvariante.

b2) Zuerst muss gezeigt werden, dass {I ∧ ¬B} ⇒ {P } (P ist die Nachbe-

dingung).
Es muss also gelten
{(betrag = B ·(1+1/100)M −Zeitraum, Zeitraum ≥ 0)∧¬(Zeitraum > 0)} ⇒
⇒ {betrag = B · (1 + 1/100)M }
{betrag = B · (1 + 1/100)M −Zeitraum, Zeitraum = 0} ⇒
⇒ {betrag = B · (1 + 1/100)M }
Da Zeitraum = 0 gilt
{betrag = B · (1 + 1/100)M , zeitraum = 0} ⇒
⇒ {betrag = B · (1 + 1/100)M}
Als Letztes muss noch gezeigt werden, dass {Q} ⇒ {I}
{betrag = B, Zeitraum = M, M > 0}
{betrag = B · (1 + 1/100)M −Zeitraum, Zeitraum ≥ 0}
Aus Zeitraum = M ∧ M > 0 folgt dass Zeitraum ≥ 0.
Wenn Zeitraum = M gilt


------------------------------------------------------------------------
164

2 Algorithmen und Datenstrukturen

betrag = B · (1 + 1/100)M−Zeitraum = B · (1 + 1/100)0 = B · 1 = B
Diese Bedingung ist immer korrekt.

b3) (Zu diesem Thema siehe [GUS], S.201.)

Um die Terminierung der Schleife zu zeigen, muss ein ganzzahliger
Wert t bestimmt werden, der bei jedem Durchlauf verringert wird,
aber stets positiv bleibt. In dieser Aufgabe ist t = Zeitraum, denn
es gilt Zeitraum ist positiv, wegen der Vorbedingung {Zeitraum =
M, M > 0} und der Schleifenbedingung Zeitraum > 0. Außerdem
gilt {Zeitraum = k}p{Zeitraum < k}, wegen der Programmzeile
Zeitraum = Zeitraum − 1. D. h. der Wert von Zeitraum verringert
sich bei jedem Schleifendurchlauf.
Zeitraum erfüllt also alle Bedingungen für t und damit ist bewiesen,
dass das Programm terminiert.

Frühjahr 05 - Thema 2

Aufgabe 4

Komplexi-
tät,
O-Notation

Gegeben seien die Methoden foo(n) und bar(n) mit asymptotischen Aufwands-
funktionen O(log n) bzw. O(n). Es seien:
• k eine positive Konstante
• n eine Variable
• i und j zwei Laufvariablen.
Geben Sie den asymptotischen Aufwand (Komplexität) folgender Programm-
stücke in O-Notation an:
a) for

(int i = 1; i <= n; i++) {
foo(i);

}
bar(n);

b) for

}

c) for

}

(int i = 1; i <= k; i++) {
foo(n);
bar(n);

(int i = 1; i <= n; i++) {
bar(i);
for (int j = 1; j <= k; j++) {

foo(n);

}

(cid:27)

------------------------------------------------------------------------
Frühjahr 05 - Thema 2

165

d) for

(int i = 1; i <= n; i++) {
for

(int j = 1; j <= i; j++) {
bar(j);

}

}

a) Der Aufwand für die Schleife beträgt n ∗ log n, dazu kommt noch die einzelne
Anweisung bar(n) mit dem Aufwand n. Die Gesamtkomplexität beträgt also
n ∗ log(n) + n = n ∗ (1 + log(n)) und gehört damit in die Komplexitätsklasse
O(n log n).

b) In diesem Fall beträgt die Komplexität k ∗ (n + log(n)) = k ∗ n + k ∗ log(n)

und gehört in die Klasse O(n).

c) n ∗ (n + k ∗ log(n)) , also O(n2).

d) Sowohl die beiden Schleifen als auch die Funktion bar besitzen die Komple-

xität n, damit beträgt der Aufwand insgesamt O(n3).

Aufgabe 5

Folgendes Programmstück realisiert ein Sortieren durch Einfügen:

1
2
3
4
5
6
7
8
9
10
11

for (int j = 1; j < f eld.length; j + +) {

schluessel = feld[j];
// Fuege Element j in sortierte Folge
// feld[0]...feld[j-1] ein
int i = j − 1;
while (i >= 0 && f eld[i] > schluessel) {

feld[i+1] = feld[i];
i=i-1;

}
feld[i+1] = schluessel;

}

a) Geben Sie für die Programmzeilen 1, 2, 6 und 7 an, wie oft diese Zeilen im
besten sowie im schlechtesten Fall ausgeführt werden. Nehmen Sie an, dass
das Feld 10 Elemente enthält und alle Variablen korrekt vereinbart wurden.

b) Geben Sie eine Aufwandsabschätzung in O-Notation für das Verhalten im

schlechtesten Fall an.

c) Im obigen Code wird die Einfügestelle mit linearer Suche gefunden. Wieso
verschlechtert sich durch die Verwendung der Binärsuche der Aufwand
im günstigsten Fall? Erläutern Sie Ihre Antwort gegebenenfalls an einer
Zahlenfolge.

Sortieren
durch
Einfügen,
O-Notation


------------------------------------------------------------------------
166

2 Algorithmen und Datenstrukturen

a) Zeile 1 wird 10-mal durchlaufen. Im letzten Durchlauf ist j = feld.length =
10 und damit wird das Innere der Schleife nicht mehr bearbeitet. Zeile 2 wird
demnach 9-mal durchlaufen. Zeile 6 wird in jedem Durchgang (j + 1)-mal
durchlaufen. Insgesamt also 2 + 3 + 4 + ... + 8 + 9 = 54-mal. Zeile 7 wird im
Best Case überhaupt nicht durchlaufen und im Worst Case wird in jedem
Durchlauf der for-Schleife das größte Element ganz hinten eingefügt. Damit
wird Zeile 7 im 1. Durchgang einmal, dann zweimal, etc. - also jeweils einmal
weniger als Zeile 6 - benötigt. Insgesamt also 1 + 2 + 3 + ... + 8 + 9 = 45-mal.

b) (Es sei feld.length-1 = n)

Die while-Schleife besitzt die Komplexität n∗(n−1)
, die for-Schleife benötigt
n Durchläufe, die einzelnen Anweisungen haben die Komplexität 1 und fallen
nicht ins Gewicht. Durch die Schachtelung ergibt sich
O(n ∗ n∗(n−1)

) = O(n3).

) = O( n

2

3−n
2
2

2

c) Bei der linearen Suche besteht der Best Case darin, dass die Liste bereits
sortiert ist. Im 1. Suchschritt wird die Zeile 6 einmal durchlaufen und die
Schleife nicht ausgeführt, weil f eld[i] < schluessel. Hierbei beträgt die Kom-
plexität O(1). Bei binärer Suche wird der Abschnitt der Liste, in der gesucht
wird, in jedem Schritt halbiert und zwar so lange bis die Länge der Liste 1
ist. Der Aufwand, um eine Einfügestelle zu ﬁnden, beträgt damit in jedem
Fall - also auch im Best Case - O(log n).


------------------------------------------------------------------------
Frühjahr 05 - Thema 2

Aufgabe 6

167

Die Zahl π soll nach folgender Formel berechnet werden:
π = (4/1 − 4/3 + 4/5 − 4/7...)

iterativ,
rekursiv

Hinweis: Wenn Sie die Zahl π auf eine andere Weise berechnen, z. B. durch
einen Zugriﬀ auf die Java-Bibliothek, ist Ihre Lösung ungültig.

Gegeben sei folgender Rahmen:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16

static ﬁnal double EPSILON = 0.0001;

public static double piBerechnung(char schalter) {

double pi= 0.0;
switch (schalter) {
case’r’:

pi = piBerechnungRekursiv(1.0,1.0);
break;

case ’i’:

pi = piBerechnungIterativ(1.0,1.0);
break;

default:

throw new RuntimeExecption(’’Fehlende Methode’’);

} //switch
return pi;
}//piBerechnung

Die Berechnung soll abbrechen, wenn der Wert des Bruchs unter den vorgege-
benen Wert EPSILON gefallen ist. Geben Sie bei jeder Ihrer Lösungen an, ob
in Ihrer Lösung der erste berechnete Bruch, der unter dem Wert von EPSILON
liegt, noch zur Summe mit hinzuaddiert wird oder nicht. Beide Varianten sind
erlaubt.
a) Geben Sie eine rekursive Methode piBerechnungRekursiv an, die π ent-
sprechend der oben angegebenen Formel berechnet und über eine Schnitt-
stelle wie in der Methode piBerechnung angegeben verfügt. Verwenden Sie
den ersten Parameter zur übergabe des aktuell betrachteten Nenners. Der
zweite Parameter soll zur Implementierung des Vorzeichens dienen.
b) Geben Sie eine iterative Methode piBerechnungIterativ an, die π ent-

sprechend der oben angegebenen Formel berechnet und über eine Schnitt-
stelle wie in der Methode piBerechnung angegeben verfügt.

a) public static double piBerechnungRekursiv(double nen, float vorz) {

if (4/Nenner > EPSILON) {

vorz = -vorz;
return vorz * 4/nen + piBerechnungRekursiv(nen + 2, vorz);}

else {return 4/nen;}

}


------------------------------------------------------------------------
168

2 Algorithmen und Datenstrukturen

Der letzte Bruch, der bereits kleiner als EPSILON ist, wird noch hinzuad-
diert. Andernfalls müsste im else-Zweig 0 zurückgegeben werden.

b) public static double piBerechnungIterativ() {

int Nenner = 1;
int Vorzeichen = 1;
double pi = 0.0;
while (4/Nenner > EPSILON) {

pi = pi + (Vorzeichen * 4/Nenner);
Vorzeichen = -Vorzeichen;
Nenner = Nenner + 2;}

return pi;

}

Der letzte Bruch, der addiert wird, ist echt größer als EPSILON.

Aufgabe 7

Algorith-
mus von
Dijkstra

Bestimmen Sie mit dem Algorithmus von Dijkstra die kürzesten Pfade für den
Knoten v.

a) Machen Sie den Ablauf des Algorithmus mit Hilfe einer Tabelle folgenden

Musters deutlich:

Schritt

·/·
0
1

ausgewählter
Knoten
·/·
-
v

untersuchter
Knoten
·/·
-

Knotenbewertung nach
Dijsktras Algorithmus

a

v
e
0 ∞ ∞ ∞ ∞ ∞

b

d

c

b) Geben Sie die kürzesten Pfade ausgehend von Knoten v zu jedem einzelnen

der übrigen Knoten an!


------------------------------------------------------------------------
Frühjahr 05 - Thema 2

169

a)

b)

Schritt

ausgewählter
Knoten

untersuchter
Knoten

Knotenbewertung nach
Dijkstras Algorithmus

0
1
2
3
4
5
6

v
a
c
d
e
b

a, d
b, c
e
a, b, c
v
c

c

a

d

b

v
e
0 ∞ ∞ ∞ ∞ ∞
10 ∞ ∞ 40 ∞
0
40 ∞
35
10
0
55
40
35
10
0
55
40
35
10
0
55
40
35
10
0
55
40
35
10
0

60
60
60
60
60

von v nach
Entfernung
Weg

a
10
va

b
60
vab

c
35
vac

d
40
vd

e
55
vace

Aufgabe 8

Gegeben seien die folgenden Zahlen: 7, 4, 3, 5, 0, 1
a) Zeichnen Sie eine Hash-Tabelle mit 8 Zellen und tragen Sie diese Zahlen ge-
nau in der oben gegebenen Reihenfolge in Ihre Hash-Tabelle ein. Verwen-
den Sie dabei die Streufunktion f (n) = n2mod7 und eine Kollisionsauﬂö-
sung durch lineares Sondieren.

Hashing,
Hashta-
belle,
Hashfunk-
tion

b) Welcher Belegungsfaktor ist für die Streutabelle und die Streufunktion

aus Teilaufgabe a zu erwarten, wenn sehr viele Zahlen eingeordnet werden
und eine Kollisionsauﬂösung durch Verkettung (verzeigerte Listen) verwen-
det wird. Begründen Sie Ihre Antwort kurz.
Hinweis: Es ist kein formaler Beweis nötig, aber Sie müssen Ihre Antwort
plausibel begründen.

a) Die Zellen sind von 0 bis 7 nummeriert.

72 mod 7 = 49 mod 7 = 0, d. h. 7 kommt in die erste Zelle.

7
7

4

32 mod 7 = 9 mod 7 = 2, da die zweite Zelle bereits belegt ist, liegt eine
Kollision vor. Für die Kollisionsauﬂösung wird lineares Sondieren verwendet,
d. h. es wird jeweils die nächste Zelle überprüft: hier ist Zelle 3 noch frei und
wird damit für die 3 verwendet.

7
7

4
4

3
3

5

Auch hier wird wieder mit der Schrittweite 1 sondiert:
5

0

7

3

4


------------------------------------------------------------------------
170

2 Algorithmen und Datenstrukturen

0

7

Sondiert man immer nur in eine Richtung, ergibt sich:
5

3
Sondierung in beide Richtungen führt zu:
3

1

7

4

1

5

0

4

b) Mit der Streufunktion werden Werte zwischen 0 und 6 ermittelt. Bei der
Verwendung von verketteten Listen kann nun also das letzte Feld der Tabelle
nie gefüllt werden, da dafür die Streufunktion den Wert 7 liefern müsste. Die
Hash-Tabelle ist also zu 7
8 = 87, 5%.

8 gefüllt. Der Belegungsfaktor beträgt 7

Aufgabe 9

Baum Gegeben sei folgende partielle Speziﬁkation eines Datentyps Baum mit der Ei-
genschaft, dass genau eine Integer-Zahl pro Knoten gespeichert wird.

Signatur:
→ Baum
neu
konstr: Baum × Baum × int → Baum
→ Baum
links:
Baum
→ Baum
rechts: Baum
→ int
anzahl: Baum

Axiome:

links(konstr(b1,b2,k)) = b1
rechts(konstr(b1,b2,k)) = b2

a) Die Funktion anzahl soll angeben, wieviel int-Werte im Baum enthalten

sind. Geben Sie Axiome an, die diese Funktion festlegen.

b) Eine Klasse enthalte bereits die den Axiomen entsprechenden Methoden

links und rechts mit folgenden Signaturen:

• Baum links(Baum b)
• Baum rechts(Baum b)

Geben Sie den Rumpf der folgenden Methode an:
public int anzahl (Baum b)

c) Geben Sie an, wie die Reihenfolge bezeichnet wird, in der die Knoten in

Ihrer Lösung der Methode anzahl durchlaufen werden.

a) anzahl(konstr(null,null,k)) = 1

anzahl(konstr(b1 ,null,k)) = 1 + anzahl(links(konstr(b1 ,null,k)))
anzahl(konstr(null,b2 ,k)) = 1 + anzahl(rechts(konstr(null,b2 ,k)))
anzahl(konstr(b1 ,b2,k)) =

= 1 + anzahl(links(konstr(b1 ,b2,k))) + anzahl(rechts(konstr(b1 ,b2,k)))

b) public int anzahl (Baum b) {

while (links(Baum b) != null || rechts (Baum b) != null) {

if (links(Baum b) == null) {return 1 + anzahl(rechts(Baum b));}
if (rechts(Baum b) == null) {return 1 + anzahl(links(Baum b));}
else {return 1 + anzahl(links(Baum b)) + anzahl(rechts(Baum b));}}}


------------------------------------------------------------------------
Algorith-
mus,
vollständige
Induktion

Herbst 05 - Thema 1

171

c) Hier wird jeweils zuerst die Wurzel, dann der linke und dann der rechte
Teilbaum betrachtet, der Baum also im preorder-Verfahren durchlaufen.

Herbst 05 - Thema 1

Aufgabe 2

Sie möchten von München nach Tallinn mit dem Auto fahren und dabei die
Anzahl der Tankstopps so klein wie möglich halten. Ihnen liegt eine Liste aller
Tankstellen auf dem Weg vor mit der jeweiligen Entfernung von München. Be-
kannt sind außerdem das Fassungsvermögen des Tanks und der (als konstant
angenommene) Verbrauch Ihres Autos. Mit folgendem Algorithmus können Sie
die Zahl der Tankstopps minimieren. An jeder Tankstelle entscheiden Sie, ob
das noch im Tank vorhandene Benzin zur Fahrt bis zur nächsten Tankstelle
reicht. Falls ja, so übergehen Sie die Tankstelle, falls nein, so tanken Sie dort
voll.
a) Zu welcher Klasse von Verfahren gehört diese Methode?
b) Implementieren Sie den Algorithmus in einer höheren Programmierspra-
che (funktional oder objektorientiert, auch Pseudocode) Ihrer Wahl! Sie
dürfen voraussetzen, dass die Tankstellen als geeignete Datenstruktur be-
reits vorliegen, müssen sich also nicht um Ein-/Ausgabe kümmern. Aller-
dings müssen Sie die verwendeten Datenstrukturen genau dokumentieren!
c) Beweisen Sie, dass der Algorithmus korrekt ist, also tatsächlich die Zahl der
Tankstopps minimiert! Dazu können Sie zum Beispiel nachweisen, dass zu
jedem Zeitpunkt die bereits getroﬀenen Entscheidungen noch zu einer opti-
malen Lösung erweitert werden können.

a) Durch die schrittweise Verbesserungsstrategie

fahre solange der Treibstoﬀ
”
reicht und die nächste Tankstelle noch erreicht werden kann, sonst tanke“
zählt die hier angegebene Vorgehensweise zu den Greedy-Algorithmen.

b) Tankstellen sind als ﬂoat-Array gespeichert. Im ersten Eintrag mit Index 0

steht die Entfernung von der ersten Tankstelle nach München.

float[] = ts[]; //Array mit Daten füllen
const float TANK = 45; // Fassungsvermögen des Tanks in Litern
const float VERBRAUCH = 7,5; // Verbrauch auf 100km in Litern
int letzte tankstelle;

//speichert den Index der Tankstelle,

boolean entscheiden (int t) {

an der zuletzt getankt wurde

//t ist der Index der Tankstelle,

an der man sich gerade befindet
float gefahrene Strecke = ts[t] - ts[letzte tankstelle];


------------------------------------------------------------------------
172

2 Algorithmen und Datenstrukturen

float tankinhalt = TANK - (gefahrene strecke * VERBRAUCH/100);
float entfernung = ts[t + 1] - ts[t];

//Entfernung zur nächsten Tankstelle

float tankinhalt neu = tankinhalt-(entfernung * VERBRAUCH/100);
if (tankinhalt neu < 0) return true;
else return false; //bei true wird getankt, bei false nicht
}

c) Variante 1:

Induktion über Anzahl der Tankstopps:
Wenn in München gestartet wird, ist der Tank voll und die Anzahl der
Tankstopps 0. Jetzt wird solange gefahren, bis der Tank nicht mehr bis zur
nächsten Tankstelle ausreichen würde. Erst dann wird der erste Tankstopp
eingelegt. Das heißt, bis Anzahl Stopps=1 ist die Lösung minimal. Sei nun
Anzahl Stopps=n (und die Anzahl bis dahin minimal). Durch den Algorith-
mus wird erst dann wieder getankt, wenn das Benzin nicht zur nächsten
Tankstelle reichen würde. Das heißt auch für n+1 ist die Lösung optimal.
Variante 2:
Vollständige Induktion über Tankstellen:
Bis zu Tankstelle 1 wurde nicht getankt, die Anzahl der Tankstopps ist
also 0. An der Tankstelle 1 wird nun entschieden, ob der Tankinhalt noch
bis zur Tankstelle 2 ausreicht. Falls ja, wird nicht getankt und die Anzahl
der Tankstopps ist mit 0 immer noch minimal. Falls nein, ist es unbedingt
nötig zu tanken und damit wird in jedem Fall die optimale Entscheidung
getroﬀen. Sei nun die Lösung bis zu Tankstelle n optimal. Bei Tankstelle n+1
wird entweder nicht getankt oder getankt. Wenn nicht getankt wird, dann
bleibt die Anzahl der (bis dahin minimalen) Tankstopps gleich, also weiterhin
minimal. Wenn getankt wird, dann wäre die Tankstelle n+2 nicht mehr zu
erreichen gewesen und damit erreicht man in jedem Fall eine Erweiterung zu
einer optimalen Lösung.

Aufgabe 3

Automat

In einem Automatikfahrzeug müssen Sie beim Starten den Schalthebel in Posi-
tion N bringen. Ist das Fahrzeug gestartet, so ertönt ein Gong, falls nicht vorher
der Sicherheitsgurt angelegt wurde. Sie können dann losfahren, indem Sie den
Schalthebel in die Position D bringen, allerdings muss hierbei die Bremse ge-
drückt werden. Nach dem Ausschalten des Motors kann der Zündschlüssel nur
entfernt werden, wenn vorher der Schalthebel in Position P gebracht wurde.


------------------------------------------------------------------------
Herbst 05 - Thema 2

173

a) Modellieren Sie diesen Sachverhalt durch einen Zustandsautomaten! Ihre
Modellierung darf und sollte sinnvolle übergänge enthalten, die im obigen
Text nicht ausdrücklich erwähnt, aber auch nicht ausdrücklich verboten
sind.

b) Zu einer gefährlichen Situation kann es kommen, wenn der Motor läuft und
der Schalthebel von N nach D umgelegt wird, ohne dass die Bremse ge-
drückt wird. Kann diese Situation in Ihrer Modellierung auftreten? Falls ja,
so ändern Sie Ihre Modellierung entsprechend ab!

c) Gib es in Ihrem Modell einen zyklischen Ablauf, der einen Zustand enthält,
in dem das Auto fährt und einen Zustand, in dem der Motor ausgeschaltet
ist? Falls nein, so ändern Sie Ihre Modellierung entsprechend ab!

a)

b) Da ein übergang zu

Auto fährt, Position D“ nur möglich ist, wenn die
”
Bremse gedrückt“ erfüllt ist (s. Zustandsautomat), braucht hier
”

Bedingung
nichts geändert zu werden.

c) Da ein zyklischer übergang von

an, Position N“ zu
mat), braucht hier nichts geändert zu werden.

Motor
”
Auto fährt, Position D“ möglich ist (s. Zustandsauto-
”

Motor aus, Schlüssel steckt“ über
”

Herbst 05 - Thema 2

Aufgabe 2

Geben Sie ein WHILE-Programm an, das die Funktion < x → 2x > berechnet.

WHILE


------------------------------------------------------------------------
174

2 Algorithmen und Datenstrukturen

erg = 1;
WHILE x 6= 0 DO
erg = erg * 2;
x = x-1;

END WHILE;
return erg;

Aufgabe 5

Hash-Ver-
fahren,
Sondie-
rungsfunk-
tion

Gegeben sei ein Hashverfahren mit Kollisionsauﬂösung innerhalb der Tabelle
(oﬀene Adressierung) mit beliebiger Sondierungsfunktion! Modiﬁzieren Sie den
Algorithmus zum Einfügen eines Schlüssels so, dass alle entstehenden Sondie-
rungsfolgen sortiert sind (Ordered Hashing)! Geben Sie einen Algorithmus zum
Suchen von Schlüsseln an, der diese Eigenschaften ausnutzt. ändert sich der
Aufwand für die Operation wesentlich?

Eingabe: n //einzufügender Wert
i: Integer //Schritt beim Sondieren, am Anfang gilt i = 0

void einfuegen(int n, int i) {

if tabelle(h(n +i) mod m) = 0

fuege n an dieser Stelle ein

else { //Platz belegt → Kollisionsauflösung

if (n > tabelle(h(n +i) mod m))

einfuegen(n, i+1)

else {

hilf = tabelle(h(n +i) mod m)
tabelle(h(n +i) mod m) = n
einfuegen(hilf, i+1)}

} }

Suchen eines Schlüssels:

Eingabe: n //zu suchender Wert
i: Integer //Schritt beim Sondieren, am Anfang gilt i = 0

boolean suchen(int n, int i) {

if tabelle(h(n +i) mod m) = n

return true

else {

if (tabelle(h(n +i) mod m) < n)
suchen(n, i+1)

else {

} }

return false}


------------------------------------------------------------------------
Herbst 05 - Thema 2

175

Der Aufwand zum Suchen bei nicht geordneten Schlüsseln ist linear, d. h. O(n).
Auch bei Ordered Hashing kann diese Laufzeit nicht verbessert werden, denn eine
Verbesserung kann nur durch konstante Laufzeit erreicht werden und diese ist hier
nicht gegeben.

Aufgabe 6

a) Erzeugen Sie aus der gegebenen Folge einen 2-3-4 Baum (B-Baum mit

2-3-4 Baum

Ordnung m=2):

22; 10; 19; 1; 13; 12; 7; 8; 5; 42; 33; 21

Fügen Sie dazu die einzelnen Elemente in gegebener Reihenfolge in einen
anfangs leeren 2-3-4 Baum ein! Stellen Sie für jeden Wert die entsprechen-
den Zwischenergebnisse und die angewendeten Operationen als Bäume dar!

b) In dem Ergebnisbaum suchen wir nun den Wert 17. Stellen Sie den Ablauf

des Suchalgorithmus an einer eigenen Zeichnung graﬁsch dar!

c) Es sei n die Zahl derjenigen Schlüssel, die in einem inneren Knoten gespei-
chert sind. Zeigen Sie: Die Zahl der Blätter, also Knoten ohne Kinder,
beträgt n + 1.

a) Eine ausführliche Lösung zu dieser Aufgabe ﬁnden Sie bei Herbst 2002 -

Thema II Aufgabe 3 (Seite 127), wo die identische Aufgabe gestellt wurde. x

b) Eine ausführliche Lösung zu dieser Aufgabe ﬁnden Sie bei Herbst 2002 -

Thema II Aufgabe 3 (Seite 127), wo die identische Aufgabe gestellt wurde. x

c) Zu den deﬁnierenden Eigenschaften eines B-Baums gehört es, dass ein Kno-
ten mit n Schlüsseln genau n + 1 Söhne hat oder keinen Sohn. Da hier ein
innerer Knoten vorliegt, muss er n + 1 Söhne haben, um die Eigenschaft des
B-Baums nicht zu verletzen (s. [DUD]).

(cid:28)

------------------------------------------------------------------------
Veriﬁka-
tion,
Schleifenin-
variante

176

2 Algorithmen und Datenstrukturen

Frühjahr 06 - Thema 1

Aufgabe 6

Gegeben ist folgender Algorithmus, der veriﬁziert werden soll.

//{x ≥ 0} = P
y = 0
z = 0
while (z ≤ x − 1)
{

y = y + z + z + 1
z = z + 1

}

//{...} = Q
6.1. Geben Sie die Bedingungen an, welche nach dem Ablauf der while-Schleife

für das Prädikat Q gelten und geben Sie die Schleifeninvariante an. Begrün-
den Sie Ihre Antwort.

6.2. Führen Sie für diesen Algorithmus eine Veriﬁkation durch, wobei die einzel-
nen Beweisschritte mit den Regeln der axiomatischen Semantik ausführlich
zu beschreiben und zu begründen sind.

6.1. Um zu sehen, was mit den Variablen in der Schleife geschieht, wird eine

Tabelle mit den jeweils aktuellen Werten erstellt:

Initialisierung:
1. Durchlauf:
2. Durchlauf:
3. Durchlauf:
4. Durchlauf:
...

y = 0
y = 0 + 0 + 0 + 1 = 1
y = 1 + 1 + 1 + 1 = 4
y = 4 + 2 + 2 + 1 = 9
y = 9 + 3 + 3 + 1 = 16

z = 0
z = 1
z = 2
z = 3
z = 4

Die Schleife berechnet folglich z2,
d. h. die Schleifeninvariante lautet I = {y = z2}.
Nach Beendigung der Schleife ist logischerweise die Schleifenbedingung nicht
mehr erfüllt, d. h. es gilt nun z = x und damit Q = {y = x2}.
Dieses Programm berechnet also (möglichst umständlich) das Quadrat einer
positiven Zahl.

6.2. Im ersten Schritt ist zu zeigen, dass I ∧ ¬B ⇒ Q gilt:

(y = z2 ∧ z 6≤ (x − 1)) ⇒ (y = x2)
Aus z 6≤ (x − 1) und der Tatsache, dass z in jedem Schleifendurchauf nur um
1 erhöht wird, ist folglich z = x nach Beendigung der Schleife.
(y = z2 ∧ z = x)) ⇒ (y = x2) ist korrekt.


------------------------------------------------------------------------
Frühjahr 06 - Thema 1

177

Nun muss gezeigt werden, dass die Schleifeninvariante gilt:
{y = z2 ∧ z ≤ (x − 1)} y = y + z + z + 1; z = z + 1; {y = z2}
{y = z2 ∧ z ≤ (x − 1)} y = y + z + z + 1; {y = (z + 1)2}
{y = z2 ∧ z ≤ (x − 1)} {y + z + z + 1 = (z + 1)2}
Umformen in der rechten Klammer ergibt: {y + z + z + 1 = z2 + 2 ∗ z + 1}
Nach Kürzen erhält man {y = z2}
Als letztes muss bewiesen werden {P } y = 0; z = 0; {I}
{x ≥ 0} y = 0; z = 0; {y = z2}
{x ≥ 0} y = 0; {y = 02}
{x ≥ 0} {0 = 02}
Auch hierbei ergibt sich kein Widerspruch und damit ist die Veriﬁkation
abgeschlossen.

Aufgabe 7

nQ

i=1

i

iterativ,
rekursiv,
rekursive
Funktion

7.1. Es gibt zwei Möglichkeiten die Fakultät F : N+ → N+, mit F (n) =

zu berechnen. Zum einen kann sie iterativ und zum anderen rekursiv be-
rechnet werden. Geben Sie für jede der Möglichkeiten jeweils eine Methode
in einer höheren Programmiersprache an.

7.2. In der Linearen Algebra ist die Determinante eine Funktion, die jeder qua-
dratischen Matrix eine Zahl zuordnet. Zum Beispiel hat die 2 × 2-Matrix

(cid:18)

(cid:19)

a b
c d

die Determinante det(A) =

A =
Allgemein wird die Determinante eine n × n-Matrix berechnet, indem aus
einer gewählten Zeile i jedem Element ai,1, ..., ai,n eine Untermatrix Aij ge-
bildet wird. Die Untermatrix Aij entsteht aus A durch Streichen der i-ten
Zeile und j-ten Spalte. Für die Determinante von A gilt:

(cid:12)
(cid:12)
(cid:12)
(cid:12)

a b
c d

(cid:12)
(cid:12)
(cid:12)
(cid:12) = ad − bc.

det(A) =

(−1)i+j · aij · det(Aij).

nP

j=1

Schreiben Sie eine rekursive Funktion in einer höheren Programmierspra-
che, welche die Determinante der Matrix A bestimmt. Die Funktionsdekla-
ration könnte in C wie folgt aussehen:
float det(float[][] Matrix, int dimension)

7.1. Für die Implementierung wurde Pascal gewählt.

Rekursive Variante:

function fakultaet(n: integer): integer;
var n: integer;
begin

if n=1 then fakultaet:=1
else fakultaet:=n*fakultaet(n-1);

end;


------------------------------------------------------------------------
178

2 Algorithmen und Datenstrukturen

Iterative Variante:
function fak it(n: integer): integer;
var n: integer;
n it: integer;
begin

fak it:=1;
for n it:=1 to n do

fak it:=fak it*n it;

end;

7.2. typematrixtyp = array[0..n,0..n] of integer;

//Typdefinition für die Matrix

var matrix:matrixtyp;

function det(matrix:matrixtyp; dimension:integer):integer;

//Matrix und Dimension werden übergeben

var j,k,l:integer;
summe:integer;
neuematrix:matrixtyp;
vorzeichen:integer;

begin
if (dimension=2)

//Hilfsmatrix

then det:=matrix[0][0]*matrix[1][1]

-matrix[0][1]*matrix[1][0]

//Abbruchbedingung

else

begin
summe:=0;
for j:=0 to dimension-1 do

begin
for k:=0 to dimension-2 do

for l:=0 to dimension-1 do
//Bestimmung der Untermatrix
//ohne Zeile k und Spalte l

if (l < j) then neuematrix[k,l] := matrix[k+1,l]
else if (l > j)

then neuematrix[k,l-1] := matrix[k+1,l];

if odd(j) then vorzeichen := -1
else vorzeichen := 1;
//Vorzeichen, mit dem die Teildeterminante
//in die Summe eingeht
summe:=summe+vorzeichen*matrix[0][j]
*det(neuematrix, dimension-1);

//rekursiver Aufruf mit der um eine
//Zeile und Spalte reduzierten Matrix
end;


------------------------------------------------------------------------
zweidimen-
sionales
Feld,
balancierter
binärer
Suchbaum,
Liste,
O-Notation

Frühjahr 06 - Thema 1

179

det := summe;
end;

end;

Aufgabe 8

8.1. Nennen Sie den Aufwand von sortierten Listen, balancierten Suchbäumen
und sortierten Arrays in Bezug zueinander bei der Speicherung von n Ele-
menten für die Operationen Element ﬁnden und Element einfügen bzw. lö-
schen. Geben Sie ebenfalls den zusätzlichen Speicherbedarf für die Verwal-
tung der Datenstrukturen an.

Kriterium
Element ﬁnden
Element einfügen bzw. löschen
zusätzlicher Speicherbedarf

Listen Bäume Arrays
· · ·
· · ·
· · ·

· · ·
· · ·
· · ·

· · ·
· · ·
· · ·

8.2. Gesucht ist ein nicht notwendigerweise balancierter binärer Suchbaum, bei
welchem in jedem Knoten eine Zahl n ∈ N gespeichert ist. Für jeden Kno-
ten gilt, dass alle Knoten, welche an seinem linken (rechten) Ast hängen,
kleinere (größere) Elemente als n gespeichert haben. Ferner gibt es in
dem Suchbaum keine doppelten Elemente n.
Geben Sie eine Methode insert(n) zum Einfügen und eine Methode
search(n) zum Suchen eines Elementes an. Fügen Sie mit der Methode
insert(n) die Elemente 5, 14, 2, 8, 14, 7 in einen leeren Baum ein und
geben Sie den Baum nach jedem Einfügen eines Elementes an.

8.3. Im Weinkeller eines grausamen Königs beﬁnden sich n wertvolle Weinﬂa-
schen. Seine Wächter haben einen Hexer gefangen genommen, der genau
eine Flasche vergiftet hat. Unglücklicherweise wissen sie nicht welche. Das
Gift wirkt jedoch so stark, dass man sogar dann sterben würde, wenn man
den Wein aller Flaschen vermischt und davon kostet. Allerdings wirkt das
Gift so langsam, dass man erst einen Monat später daran erkrankt. Mit
welcher Methode könnte der König innerhalb eines Monats feststellen,
welche Flasche vergiftet ist und dabei höchstens O(log(n)) Vorkoster ein-
setzen?

8.1.

Kriterium

Element ﬁnden
Element einfügen bzw. löschen
zusätzlicher Speicherbedarf

Listen Bäume
O(n)
O(n)
keiner

Arrays
O(log(n)) O(log(n))
O(log(n))
O(n)

O(n)
keiner


------------------------------------------------------------------------
180

2 Algorithmen und Datenstrukturen

8.2. void insert(int n){

if (root == null) {
new Baum(n);}

else {

insertKnoten(n, root);}

void insertKnoten(int n, Knoten k){
Knoten aktuellerKnoten = k;
if n < aktuellerKnoten.wert {

if aktuellerKnoten.links == null {

aktuellerKnoten.links = new Knoten();
aktuellerKnoten.links.wert = n;

}
else {insertKnoten(n, aktuellerKnoten.links)}}

else {

if aktuellerKnoten.rechts == null {

aktuellerKnoten.rechts = new Knoten();
aktuellerKnoten.rechts.wert = n;

}
else {insertKnoten(n, aktuellerKnoten.rechts)}

}

}

void search(int n){

searchKnoten(n, root);}

boolean searchKnoten(int n, Knoten k){
if aktuellerKnoten.wert == n {

return true;}

if n < aktuellerKnoten.wert {

if aktuellerKnoten.links == null {

return false;}

else {return searchKnoten(n, aktuellerKnoten.links)}

if aktuellerKnoten.rechts == null {

return false;}

else {return searchKnoten(n, aktuellerKnoten.rechts)}

}
else {

}

}


------------------------------------------------------------------------
Frühjahr 06 - Thema 1

181

Erstellen des Binärbaums:

8.3. Hierbei sind zwei Lösungsansätze möglich, je nachdem, was es bedeutet Vor-
koster einzusetzen. In Variante 1 werden mehr Vorkoster verwendet, von de-
nen maximal O(log(n)) sterben. In Variante 2 benötigt man von vornherein
nur O(log(n)) Vorkoster.

Als Beispiel werden n = 8 Flaschen betrachtet:
Variante 1

Es werden nicht nur einzelne Flaschen verkostet, sondern auch Mischungen
von Flaschen. Die Beschriftungen der Knoten des obigen Baumes geben an,
welche Flasche (unterste Ebene des Baumes) bzw. die Mischung welcher Fla-
schen (alle anderen Ebenen) jeweils betrachtet wird. Getrunken wird jeweils
nur aus den farblich markierten Flaschen, die sich immer in den rechten
Teilzweigen (mit 1 markiert) der Teilbäume beﬁnden. Hier werden also 7
Vorkoster verwendet, von denen maximal 3 sterben (was hier als
einsetzen“
”
interpretiert wurde). Dieser schlimmste Fall tritt nur ein, wenn Flasche 8 ver-
giftet war. Stirbt jedoch kein einziger Vorkoster, so war Flasche 1 vergiftet,


------------------------------------------------------------------------
182

2 Algorithmen und Datenstrukturen

die niemand (auch nicht in Mischung) verkostet hat. Die vergiftete Flasche
kann aus der Kombination der gestorbenen Vorkoster jeweils eindeutig iden-
tiﬁziert werden.

Variante 2

Es werden nur drei Vorkoster eingesetzt und jeder trinkt eine Mischung aus
vier Flaschen. Auch hier kann wieder in Abhängigkeit der Toten eindeutig
auf die vergiftete Flasche geschlossen werden.

Herbst 06 - Thema 1

Aufgabe 4

AVL-Baum a) Gegeben sei die folgende Folge ganzer Zahlen: 6, 13, 4, 8, 11, 9, 10.

• Fügen Sie obige Zahlen der Reihe nach in einen anfangs leeren AVL-
Baum ein und stellen Sie den Baum nach jedem Einfügeschritt dar.
• Löschen Sie das Wurzelelement des entstandenen AVL-Baums und stel-

len Sie die AVL-Eigenschaft wieder her!

einfügen der 6 als
Wurzel; rechts anhängen
Wurzel; rechts anhängen
der 13, da 13 > 6

links anhängen
der 4, da 4 < 6

8 > 6, deshalb rechter
Teilbaum; 8 < 13,
also links anhängen


------------------------------------------------------------------------
Herbst 06 - Thema 1

183

11 > 6, 11 < 13, 11 > 8
deshalb an linken Teil des
rechten Teilbaums 11
anhängen; Balancierung
verletzt, deshalb Linksrotation

Balancierung weiter
verletzt (-2);
deshalb Rechtsrotation

Balancierung wieder
hergestellt

9 > 8, deshalb einfügen
rechts unter der 8;
Balancierung verletzt,
deshalb Rechtsrotation

Balancierung weiter
verletzt (2);
deshalb Linksrotation

Balancierung wieder
hergestellt

9 einfügen
Endergebnis Teil 1 mit
korrekter Balancierung

kleinster Knoten
des rechten
Teilbaums nach oben

Endergebnis


------------------------------------------------------------------------
184

2 Algorithmen und Datenstrukturen

b) Gegeben sei der folgende gerichtete und gewichtete Graph:

Algorith-
mus von
Dijkstra,
Tiefen-
durchlauf

• Bestimmen Sie mit Hilfe des Algorithmus von Dijkstra die kürzesten
Wege vom Knoten A zu allen anderen Knoten! Geben Sie dabei nach
jedem Verarbeitungsschritt den Zustand der Hilfsdatenstruktur an.
• Skizzieren Sie einen Algorithmus zum Tiefendurchlauf von gerichteten

Graphen, wobei jede Kante nur einmal verwendet werden darf!

b)

S
{}

{A}

Heap

{A, B, D, E, C, F } dis

A
0

{B, D, E, C, F }

{A, B}

{D, C, F, E}

{A, B, D}

{E, C, F }

{A, B, D, E}

{C, F }

{A, B, D, E, C}

{A, B, D, E, C, F }

{F }

{}

E

C

null

null

F
D
B
∞ ∞ ∞ ∞ ∞
null
null
null
20 ∞ ∞ ∞ ∞
null
null
null
A
30 ∞ 80
20
B
null
B
A
80
50
30
20
B
D
B
A
80
50
30
20
B
D
B
A
70
50
30
20
C
D
B
A
70
50
30
20
C
D
B
A

null
70
B
70
B
60
E
60
E
60
E

0

0

0

from null
dis
from null
dis
from null
dis
from null
dis
from null
dis
from null
dis
from null

0

0

0

Prinzipiell wird beim Tiefendurchlauf nur irgendein noch nicht besuchter
Nachbarknoten im nächsten Schritt abgearbeitet. Verwendet man immer den
Nachbarknoten mit dem geringsten Abstand zum Startknoten, so resultiert
der Algorithmus von Djikstra. Es sei V die Menge aller Knoten, D[v] der Ab-
stand (Distanz) eines Knotens v zum Startknoten u. (s. [DUD], Stichworte
Tiefensuche“)

Djikstra-Algorithmus“ bzw.

”

”

setze D[v] = ∞ für alle Knoten v;
D[u] = 0, S := {u}
while V 6= ∅ do

(cid:27)

------------------------------------------------------------------------
Herbst 06 - Thema 1

185

deletemin(V, v); //entferne den Knoten mit minimalem Abstand
S:= S ∪ {u};
for all Nachbarknoten w von v do

h:= D[v] + d(v, w) //neuer Abstand
if (h < D[w]) //nur wenn Abstand kleiner ist

then D[w] := h;

c) Ein wesentlicher Nachteil der Standardimplementierung des QUICKSORT-

Algorithmus ist dessen rekursiver Aufruf.

Quicksort-
Algorith-
mus

• Implementieren Sie den Algorithmus QUICKSORT ohne den rekursi-

ven Prozeduraufruf!

c) public class Quicksort{

// Implementierung eines Stacks:
int pos;
int [] stack;
public boolean isempty() {return( (pos == 0)); }
//Prüfung, ob Stapel leer ist
public void push(int i) {stack[++pos] = i; }
//Ablegen eines Wertes
public int top() {return( stack[pos] ); }
//Auslesen des obersten Wertes
public void pop() { if (pos > 0) pos−−; }
//Entfernen des obersten Wertes

// Zu sortierende Liste
int [] A;
int N;

Quicksort() {

stack = new int[50];
pos = 0;
A = new int[10];
A[0] = 5; A[1] = 60; A[2] = 23; A[3] = 90;
A[4] = 24; A[5] = 3;
N = 6;
//Länge der Liste - könnte auch als eigene Methode
//implementiert werden

}

void Go(){

for(int i = 0; i < N; i++) System.out.print(A[i] + ",
System.out.println();
//Ausgabe der unsortierten Liste
Sort();

\);


------------------------------------------------------------------------
186

2 Algorithmen und Datenstrukturen

for(int i = 0; i < N; i++) System.out.print(A[i] + ",
System.out.println();
//Ausgabe der sortierten Liste

\);

}

void Sort(){

int i, j, links, rechts, x, w;

links = 0;
//Index des ersten Elements
rechts = N-1;
//Index des letzten Elements

push (links);
push (rechts);
//Auf dem Stapel werden jeweils die Indizes der Enden
//der gerade aktuellen (Teil-)Liste abgelegt.

while (!isempty()){

if (rechts > links){

x = A[(links + rechts)/2];
//Wert des mittleren Elements wird
//als Pivotelement verwendet
i = links;
j = rechts;

//In der folgenden while-Schleife werden alle Elemente,
//die größer sind als das Pivotelement, in die rechte
//Teilliste sortiert, alle anderen in die linke Teilliste.

while (i<j){

while (A[i]<x) { i++; }
while (A[j]>x) { j−−; }
if(i<=j){

w = A[i];
A[i] = A[j];
A[j] = w;
i = i + 1;
j = j - 1;

}

}

//Nun wird die Liste in Teillisten zerlegt.

if ((i-links) >= (rechts-i)){

}
else{

push (links);
push (i - 1);
links = i ;

push (i + 1);
push (rechts);
rechts = i - 1;


------------------------------------------------------------------------
Herbst 06 - Thema 2

187

}

}
else{ rechts = top();

pop();
links = top();
pop();

}}

}

}

Herbst 06 - Thema 2

Aufgabe 4

Ein Navigationssystem soll folgenden Service anbieten. Ausgehend von einem
aktuellen Standort eines Anfragenden sollen alle Restaurants einer bestimm-
ten Küchenrichtung (z. B. italienisch, chinesisch) ausgegeben werden, die sich
innerhalb eines quadratischen Bereichs einer anzugebenden Größe um diesen
beﬁnden.

Algorith-
mus, Liste,
Laufzeit

Gehen Sie vereinfachend davon aus, dass
sowohl der Standort, als auch aller Re-
staurants jeweils mit ihren (x,y)-Koor-
dinaten vorliegen, wobei 0 ≤ x ≤ xmax
und 0 ≤ y ≤ ymax gelten soll. Verwen-
den Sie zur Formulierung von Algorith-
men bzw. Datentypen eine gängige höhe-
re Programmiersprache oder einen ent-
sprechenden Pseudocode! Erläutern Sie
Ihre Lösung ausgiebig durch Kommen-
tare!

a) Geben Sie einen geeigneten Datentyp zur Verwaltung der Restaurants an!

Zusätzlich zur Lage ((x,y)-Koordinaten) soll der Name, die Adresse, die Te-
lefonnummer und die Küchenrichtung angegeben werden!

b) Geben Sie einen Algorithmus an, der als Eingabe einen Standort in (x,y)-

Koordinaten, eine Bereichsgröße und eine bevorzugte Küchenrichtung erhält
und der als Ergebnis eine Datenstruktur liefert, die alle Restaurants dieser
Richtung innerhalb eines achsenparallelen, quadratischen Bereichs um den
Standort enthält!
Lösungshinweis:
Eine mögliche Strategie besteht darin, zunächst nur die Restaurants mit passender
x-Koordinate zu identiﬁzieren und aus diesen diejenigen mit passender y-Koordi-
nate auszuwählen.

c) Geben Sie die Laufzeit Ihres Verfahrens in O(n)-Notation an und begrün-

den Sie Ihr Ergebnis!


------------------------------------------------------------------------
188

2 Algorithmen und Datenstrukturen

a) public class Restaurant

{

private int x;
private int y;
private String name;
private String strasse;
private int hausnr;
private long telefonnr;
private String kuechenrichtung;

//Konstruktor
public Restaurant(int a, int b, String n, String kr)
//fuer eine komplette Implementierung muessten hier
//ALLE Attribute gesetzt werden
{

x = a;
y = b;
name = n;
kuechenrichtung = kr;

}

}

b) public class Restaurantliste

{

private Restaurant[] rListe;
private Restaurant[] ergebnisListe;
private int restaurantanzahl = 0;
//Anzahl der tatsaechlich eingegebenen Restaurants in der Liste

//Konstruktor
public Restaurantliste(){

rListe = new Restaurant[100];}
//Liste von Objekten der Klasse Restaurant

//Methoden
public void eingebenRest(int x,int y,String name,String kueche){
rListe[restaurantanzahl] = new Restaurant(x,y,name,kueche);
//Fuellen der Restaurantliste
//(eigentlich muessten hier ALLE Attribute gesetzt werden)
restaurantanzahl++;
//Erhoehen der Anzahl der tatsaechlich
//eingegebenen Restaurants in der Liste

}

public void sucheRestaurant(int x,int y,int b,String kueche)
//x und y sind die Koordinaten des Standorts,
//b die halbe Breite des quadratischen Suchbereichs
{ int j = 0;


------------------------------------------------------------------------
Herbst 06 - Thema 2

189

ergebnisListe = new Restaurant[restaurantanzahl];
//Ergebnisliste hat maximal so viele Eintraege
//wie die Restaurantliste
for(int i = 0; i<restaurantanzahl; i++){

if ((rListe [i].gibX()>(x-b))&& (rListe[i].gibX()<(x+b)) &&
// Pruefung, ob x-Koordinate im Suchbereich
(rListe[i].gibY()>(y-b)) && (rListe[i].gibY()<(y+b)) &&
// Pruefung, ob y-Koordinate im Suchbereich

(rListe[i].gibKueche() == kueche)){
//Pruefung der Kuechenrichtung

ergebnisListe[j] = rListe[i];
//Einfuegen der gefundenen Restaurants
//in die Ergebnisliste
j++;

}

}

}

}

c) Da es sich um eine einfach for-Schleife handelt, beträgt die Laufzeit O(n).

Teile und Herrsche“
”

rekursiver
Algorith-
mus

Aufgabe 5

a) Geben Sie einen rekursiven Algorithmus vom Typ

zum Zeichnen einer Approximation des Geradenabschnitts an, welcher zwei
gegebene Punkte (x1, y1) und (x2, y2) verbindet, indem Pixel mit ganzzahli-
gen Koordinaten gezeichnet werden! Dabei soll der erste zu zeichnende
Punkt etwa in der Mitte zwischen den beiden gegebenen Punkten liegen.
Wann kann die Rekursion abgebrochen werden? Gehen Sie davon aus, dass
zum Zeichnen eines Pixels eine Operation zeichne mit geeigneten Parame-
tern zur Verfügung steht. Verwenden Sie (auch im Teil c) zur Formulie-
rung eine gängige höhere Programmiersprache oder einen entsprechenden
Pseudocode. Erläutern Sie Ihre Lösung ausgiebig durch Kommentare!
b) Warum sollte man dieses Problem nicht mit einem Algorithmus vom Typ

Teile und Herrsche“ lösen?
”

c) Geben Sie eine bessere Lösung für die unter a) beschriebene Aufgabenstel-

lung an!

a) void gerade (int x1, int y1, int x2, int y2) {

//solange zwischen den x- oder y-Koordinaten noch
//mindestens ein Pixel liegt
if ((abs(x2-x1)> 1) || (abs(y2-y1)> 1)) {
//zeichnen des mittleren Punktes →


------------------------------------------------------------------------
190

2 Algorithmen und Datenstrukturen

//zerlegen der Strecke in zwei Teilstrecken
zeichne ((x1+x2)/2, (y1+y2)/2);

//rekursiver Aufruf für die linke und rechte Teilstrecke
//es wird hier die Ganzzahldivision verwendet
gerade (x1, y1, (x1+x2)/2, (y1+y2)/2);
gerade ((x1+x2)/2, (y1+y2)/2, x2, y2);
}

//zeichnen des Anfangs- und Endpunkts
//des jeweiligen Streckenabschnitts
zeichne (x1, y1);
zeichne (x2, y2);

return;
}

b) Entstehende Rundungsfehler werden durch die rekursiven Aufrufe mitgeführt.
Wegen der Baumrekursion mutliplizieren sich diese Fehler besonders häuﬁg.
Der Speicherbedarf und die Laufzeit einer iterativen Lösung sind kleiner.

c) void gerade (int x1, int y1, int x2, int y2) {

int temp;
//sicherstellen, dass x1 <= x2 ist
if x1 > x2 {

temp = x1; x1 = x2; x2 = temp;
temp = y1; y1 = y2; y2 = temp;}

int x=x1;
while (x<=x2) {
//punktweises Zeichnen der Geraden mittels der
//Geradengleichung y = Steigung*(x-x1) + t
//Steigung = ∆y/∆x, t = vertikale Verschiebung = y1

zeichne (x,

(int)((x-x1)*((float)(y2-y1))/((float)(x2-x1))+ y1));

x++;

}

return;
}


------------------------------------------------------------------------
Frühjahr 07 - Thema 1

191

Frühjahr 07 - Thema 1

Aufgabe 2

a) Die loop-Anweisung kann in WHILE-Programmen durch while-Anweisun-

gen ersetzt werden. Beweisen Sie diese Aussage für die folgende loop-Anwei-
sung:
loop a do P enddo (P sei ein beliebiges WHILE-Programm.)

WHILE,
GOTO,
LOOP

b) Terminieren GOTO-Programme immer? Begründen Sie Ihre Antwort.
c) Geben Sie eine Turingmaschine M = (Z, {|, 0}, Γ, δ, z0} mit einem Band an,
die überprüft, ob die Anzahl der 0-Symbole im Eingabewort gerade ist.

a) b := a;

WHILE b 6= 0 DO
b := b-1;
P;

ENDDO.
Dieses WHILE-Programm wird genau a-mal durchlaufen und führt in jedem
Durchgang P aus.

b) Variante 1:

Die Menge der GOTO-Programme ist identisch mit der Menge der WHILE-
Programme. Da WHILE-Programme partielle Funktionen beschreiben und
diese nicht für alle Eingaben terminieren, terminieren GOTO-Programme
ebenfalls nicht für alle Eingaben.
Variante 2:
Die charakteristische Funktion einer semi-entscheidbaren Sprache ist Turing-
bzw. GOTO-berechenbar, d. h. zu jeder semi-entscheidbaren Sprache gibt es
eine Turing-Maschine. GOTO-Programme können Turing-Maschinen simu-
lieren. Da hier von einer nur semi-entscheidbaren Sprache ausgegangen wird,
terminiert das GOTO-Programm nicht, falls die Eingabe x kein Element der
Sprache ist.

c)

Z = {Z0, Z1}, Γ = {0, 1, (cid:3)}, Σ = {0, 1}, M = (Z, Σ, Γ, δ, z0, (cid:3), {z0})

Z0
δ
(Z1, (cid:3), R)
0
(Z0, (cid:3), R)
1
(cid:3) (Z0, (cid:3), N )

Z1
(Z0, (cid:3), R)
(Z1, (cid:3), R)
(Z1, (cid:3), N )


------------------------------------------------------------------------
192

2 Algorithmen und Datenstrukturen

Aufgabe 3

iterativ,
rekursiv

Die Multiplikationsfunktion für zwei ganze Zahlen n, m kann durch fortgesetzte
Addition realisiert werden:

n · m = mult(n, m) =

(

m + m · (n − 1) :
0 : sonst

falls n > 0

Geben Sie eine iterative und eine rekursive Implementierung der Multiplika-
tionsfunktion in einer imperativen oder objektorientierten Programmiersprache
an. Verwenden Sie dabei nicht den Multiplikationsoperator dieser Programmier-
sprache.

mult rek(n, m)
begin

if (n = 0) then mult rek(n, m) := 0;
else mult rek(n, m) := m + mult rek(n-1, m);

end.

mult it(n, m)
var i, summe: int
begin

summe := 0;
for i:= n to 1 do

summe := summe + m

end.

Aufgabe 4

Adjazenz-
matrix,
Adjazenz-
liste,

Repräsentieren Sie den folgenden Graphen mit Hilfe einer Adjazenzmatrix und
einer Adjazenzliste.


------------------------------------------------------------------------
Frühjahr 07 - Thema 1

193

Adjazenzmatrix:

S A B C D T
S 0 1 1 0 0 0
A 0 0 0 1 1 0
B 0 0 0 0 1 0
C 0 0 0 0 0 1
D 0 0 0 1 0 1
T 0 0 0 0 0 0

Adjazenzliste:

Aufgabe 5

Fügen Sie nacheinander die Schlüssel 7, 20, 30, 2, 14, 18, 9, 12, 4, 6, 16 in einen
anfangs leeren binären Suchbaum ein. Zeichnen Sie den kompletten Baum.

binärer
Suchbaum


------------------------------------------------------------------------
194

2 Algorithmen und Datenstrukturen


------------------------------------------------------------------------
Frühjahr 07 - Thema 1

195


------------------------------------------------------------------------
196

2 Algorithmen und Datenstrukturen

Aufgabe 6

Sortieralgo-
rithmus,
Mergesort

Gegeben seien die Zahlen 2, 3, 8, 5, 6, 4, 1, 7. Sortieren Sie diese in aufsteigender
Reihenfolge mit dem Sortierverfahren Mergesort. Geben Sie alle Zwischenschrit-
te in einer Tabelle an, in der Sie die durch Aufteilung entstehenden Teilfolgen
durch senkrechte Striche trennen.

2 3 8 5 6 4 1 7

2 3 8 5

6 4 1 7

2 3
3
2
2 3

8 5
5
8
5 8

6 4
4
6
4 6

1 7
7
1
1 7

2 3 5 8

1 4 6 7

1 2 3 4 5 6 7 8

Aufgabe 7

verkettete
Liste

Implementieren Sie die angegebenen Methoden einer Klasse Queue für Warte-
schlangen. Eine Warteschlange soll eine unbeschränkte Anzahl von Elementen
aufnehmen können. Elemente sollen am Ende der Warteschlange angefügt und
am Anfang aus ihr entfernt werden. Sie können davon ausgehen, dass eine Klasse
QueueElement mit der folgenden Schnittstelle bereits implementiert ist.


------------------------------------------------------------------------
197

Frühjahr 07 - Thema 1

class QueueElement {

QueueElement(Object contents);
Object getContents();
QueueElement getNext();
void setNext(QueueElement next);

}

Von der Klasse Queue ist folgendes gegeben:
class Queue {

QueueElement first;
QueueElement last;

}

a) Schreiben Sie eine Methode void append (Object contents), die ein

neues Objekt in die Warteschlange einfügt.

b) Schreiben Sie eine Methode Object remove(), die ein Element aus der

Warteschlange entfernt und dessen Inhalt zurückliefert. Berücksichtigen Sie,
dass die Warteschlange leer sein könnte.

c) Schreiben Sie eine Methode boolean isEmpty(), die überprüft, ob die War-

teschlange leer ist.

a) void append (object contents) {

QueueElement E = new QueueElement(contents);
last.setNext(E);
last = last.getNext();

}

b) Object remove() {

Object x;
if first != NULL {

x = first.getContents();
first = first.getNext();

}
return x;

}

c) boolean isEmpty() {

if first == NULL {
return TRUE; }
else return FALSE;

}


------------------------------------------------------------------------
198

2 Algorithmen und Datenstrukturen

Aufgabe 8

Vorbedin-
gung,
Nachbedin-
gung,
Schleifenin-
variante,
Terminie-
rung

Gegeben sei folgende Funktion zur Berechnung der Quadratwurzel einer positi-
ven, reellen Zahl a ≥ 1: Es lässt sich zeigen, dass bei Terminierung der while-
Schleife x = y gilt. Diese Tatsache können Sie für Ihre Lösung ausnutzen.
double heron(double a) {
double x, y;
x = a; y = 1;
while (x>y) {

x = (x+y)/2;
y = a/x;

}
return x;

}

a) Bestimmen Sie eine Vorbedingung, eine Nachbedingung und die Invariante

der while-Schleife.

b) Begründen Sie, warum aus der Invariante und der Nachbedingung folgt,
dass der Algorithmus tatsächlich die Quadratwurzel von a berechnet.

a) Die Vorbedingung lautet a ≥ 1.
√
Für die Nachbedingung gilt
√

a = x.

√

x ∗ y

x=y
=

√

x ∗ x =

√

x2 = x, also

a =

2 ∗ a·2

Innerhalb der Schleife gilt, dass x∗y = ( x+y

x+y =) a, dies ist die Invariante.
b) Aus der Schleifeninvariante x ∗ y = a und der Schleifenbedingung x > y folgt
bei der Terminierung der Schleife mit x = y automatisch die Nachbedingung.
Mit den Zusicherungen sieht dies folgendermaßen aus:
{(x ∗ y = a) ∧ (x = y)}{x =
{(x ∗ x = a)}{x =
√
{(x2 = a)}{x =
Diese Aussage ist korrekt.

a}

a}

a}

√

√

Für die Schleifeninvariante gilt:
{(x ∗ y = a) ∧ (x > y)}x = (x + y)/2; y = a/x; {x ∗ y = a}
{(x ∗ y = a) ∧ (x > y)}x = (x + y)/2; {x ∗ a/x = a}
{(x ∗ y = a) ∧ (x > y)}x = (x + y)/2; {a = a}
{(x ∗ y = a) ∧ (x > y)}{a = a}
Auch hier ergibt sich kein Widerspruch.


------------------------------------------------------------------------
Frühjahr 07 - Thema 2

199

Frühjahr 07 - Thema 2

Aufgabe 1

a) Beschreiben Sie in Pseudocode oder in einer Programmiersprache Ihrer

Wahl einen Greedy-Algorithmus, der einen Betrag von n Cents mit mög-
lichst wenigen Cent-Münzen herausgibt. Bei n = 29 wäre die erwartete Ant-
wort etwa 1 × 20ct, 1 × 5ct, 2 × 2ct.

b) Beweisen Sie die Korrektheit Ihres Verfahrens, also dass tatsächlich die

Greedy-Al-
gorithmus

Anzahl der Münzen minimiert wird.

c) Nehmen wir an, Bayern führe eine Sondermünze im Wert von 7ct ein.

Dann liefert der naheliegende Greedy-Algorithmus nicht immer die mini-
male Anzahl von Münzen. Geben Sie für dieses Phänomen ein konkretes
Beispiel an und führen Sie aus, warum Ihr Beweis aus Aufgabenteil a) in
dieser Situation nicht funktioniert.

a) procedure wechselgeld (nat n,var nat c50,c20,c10,c5,c2,c1):

var nat rest;

begin

c50 := n div 50;
rest:= n mod 50;
c20 := rest div 20;
rest:= rest mod 20;
c10 := rest div 10;
rest:= rest mod 10;
c5 := rest div 5;
rest:= rest mod 5;
c2 := rest div 2;
c1 := rest mod 2

endproc

b) Sei (c50, c20, c10, c5, c2, c1) eine münz-minimale Auszahlung des Betrags

b. Dann gilt:

• c20 < 3, da ansonsten drei 20er-Münzen durch eine 50er und eine 10er-

Münze ersetzt werden könnten.

• c10 < 2, da ansonsten zwei 10er-Münzen durch eine 20er-Münze ersetzt

werden könnten.

• c5 < 2, da ansonsten zwei 5er-Münzen durch eine 10er-Münze ersetzt

werden könnten.

• c2 < 3, da ansonsten drei 2er-Münzen durch eine 5er- und eine 1er-

Münze ersetzt werden könnten.

• c1 < 2, da ansonsten zwei 1er-Münzen durch eine 2er-Münze ersetzt

werden könnten.


------------------------------------------------------------------------
200

2 Algorithmen und Datenstrukturen

• ¬(c20 = 2 ∧ c10 = 1), da ansonsten die 20er- und 10er-Münzen durch

eine 50er-Münze ersetzt werden könnten.

• ¬(c2 = 2 ∧ c1 = 1), da ansonsten die 2er- und 1er-Münzen durch eine

5er-Münze ersetzt werden könnten.

Maximal kann also mit der kleinsten (den zwei kleinsten, den drei kleinsten)
Münzsorte ein Betrag von 1 (4, 9) erreicht werden. Bzw. mit den drei größeren
Münzen 10, 40 und 90 Cent. Daraus folgt: Die optimale Lösung ist eindeutig
und der Algorithmus berechnet genau diese Lösung.

c) Falls es den Münzwert 7 gibt, ist der Greedy-Algorithmus nicht mehr opti-
mal. Für die Rückgabe von 14 Cent benutzt der Greedy-Algorithmus zunächst
so viele 10-Cent-Münzen wie möglich. Es würden also eine 10-Cent und zwei
2-Cent Münzen zurückgegeben. Optimal ist aber die Aufteilung in zwei 7-
Cent-Münzen.

Herbst 07 - Thema 1

Aufgabe 4

Spann-
baum,
Graph, Al-
gorithmus,
Laufzeit,
Komplexi-
tät,
O-Notation

Wrestling ist eine Showkampf, bei dem es zwei Arten von Teilnehmern gibt:
Gute und böse Wrestler. Wer gut und wer böse ist, wird von den Organisato-
ren vorab festgelegt, die Wrestler haben sich dann entsprechend zu kleiden und
zu benehmen. Zwischen manchen Wrestlern bestehen persönliche Rivalitäten
und um die Kämpfe zusätzlich anzuheizen, ist man bestrebt, die Einteilung in
Gute und Böse so vorzunehmen, dass es keine Rivalitäten zwischen zwei Guten
oder zwischen zwei Bösen gibt, sondern nur zwischen
Böse“. Helfen
”
Sie dem Management, indem Sie einen eﬃzienten Algorithmus entwerfen, der
entscheidet, ob solch eine Einteilung existiert und sie ggf. berechnet. Gegeben
ist hierbei die Menge von W Wrestlern repräsentiert durch {1, ..., W } und ei-
ner Liste von R Paaren einander rivalisierender Wrestler.
Eﬃzient“ bedeutet
”
hier, dass die Laufzeit O(W + R) sein muss. Beschreiben Sie Ihre Lösung in
Pseudocode oder einer Programmiersprache Ihrer Wahl.
Beispiel: Bei drei Wrestlern {1, 2, 3} und Rivalitäten zwischen 1,2 sowie 1,3
könnte man 1 als
böse“ einteilen. Besteht zusätzlich
gut“ und 2,3 jeweils als
”
”
noch eine Rivalität zwischen 2 und 3, so existiert keine Lösung.

Gut“ und
”

Hinweis: Bauen Sie Ihren Algorithmus auf einem geeigneten Verfahren zum
Durchlaufen von (ungerichteten) Graphen auf.

Die W Wrestler werden in einem Graphen mit W Knoten dargestellt. Für jedes
Paar von rivalisierenden Wrestlern wird die entsprechende Kante in den Graphen
eingetragen. Der Graph besitzt also R Kanten.
Betrachtet man nun die Expansion (Spannbaum) des Graphen von einem Knoten


------------------------------------------------------------------------
Herbst 07 - Thema 1

201

aus, z. B. Knoten 1 so darf in dem resultierenden Baum jeder Knoten nur entweder
in den geraden oder ungeraden Ebenen auftreten. (Es wird hierbei angenommen,
dass der Graph zusammenhängend ist.)

Beispiel 1:

Abb. 2.1: Graph

Abb. 2.2: Expansion des Graphen

Beispiel 2: Nun kommt noch die Rivalität zwischen 2 und 3 hinzu:

Abb. 2.3: Graph

Abb. 2.4: Expansion des Graphen


------------------------------------------------------------------------
202

2 Algorithmen und Datenstrukturen

Beispiel 3: Zur Verdeutlichung wird noch ein Beispiel mit 5 Knoten betrachtet:

Abb. 2.5: Graph

Abb. 2.6: Expansion des Graphen

Hierbei ergeben sich zwei disjunkte Mengen, zum einen {1, 3, 5} und zum anderen
{2, 4}.

Beispiel 4:

Abb. 2.7: Graph

Abb. 2.8: Expansion des Graphen

Nun wurde in diesen Graphen auch eine zusätzliche Kante eingefügt.
Somit ﬁnden sich die Knoten 2 und 3 sowohl auf der zweiten als auch der dritten
Ebene der Expansion. Wrestler 3 darf also weder mit den Wrestlern 1 und 5 als
auch den Wrestlern 2 und 4 in eine Gruppe. In diesem Fall existiert keine Lösung.

Der Algorithmus kann sowohl auf der Breitensuche, als auch auf der Tiefensuche
aufbauen. In dieser Lösung wird mit der Breitensuche gearbeitet.

gut“ eingeordnet, alle seine Kinder als
”

Am Anfang sind alle Knoten als unbesucht markiert.
Der Startknoten wird als
Der Startknoten wird als besucht markiert.
Gemäß der Breitensuche werden die Kinder des Startknotens nacheinander abge-
arbeitet, deren Kinder als
Bei jeder Einordnung muss geprüft werden, ob der Knoten bereits in der entge-
gengesetzten Menge enthalten ist. In diesem Fall bricht der Algorithmus ab und
es gibt keine Lösung des ursprünglichen Problems.

gut“ eingeordnet und markiert.
”

böse“.
”


------------------------------------------------------------------------
Herbst 07 - Thema 2

203

var q: queue of 1..w

//Warteschlange der unbearbeiteten Knoten

gut: array[1..w] of integer
//unbearbeitete Knoten sind mit 0 gekennzeichnet
//gute Wrestler mit 1, böse mit 2
n, v: 1..w

begin

//alle Knoten werden als unbesucht markiert

for n:=1 to w {
gut[n] := 0

}
fuege Knoten 1 in die Queue ein
gut[1] := 1
while q != empty {

//der 1. Wrestler ist gut

n := erstes Element von q
// 1. Element der Queue entfernen und abarbeiten
for (alle v, die Nachbarn von n sind) {

if (gut[v]== 0) {
//Wenn das Element noch unbearbeitet ist...

fuege v an das Ende von q an
if (gut[n] == 1) {gut[v] := 2}
else {gut[v] := 1}
//in die jeweils entgegengesetzte Gruppe einordnen

}
else {if (((gut[v] == 1) and (gut[n] == 1)) or

((gut[v]== 2) and (gut[n] == 2))){
Abbruch, es gibt keine Loesung
}
//falls der Knoten schon in einer Gruppe ist
//und es einen Widerspruch gibt => Abbruch

}

}
end.

}

Herbst 07 - Thema 2

Aufgabe 1

a) Beschreiben Sie kurz allgemein die Wirkungsweise des Sortier-Algorith-

mus Heapsort.

b) Welche Zeitkomplexität hat Heapsort? Begründen Sie Ihre Antwort.
c) Beschreiben Sie konkret die einzelnen Schritte, die durchgeführt werden,

wenn die Zahlenfolge 13,8,25,3,9,20,5,21 mit Heapsort aufsteigend sortiert
wird. Geben Sie dabei die jeweiligen Heapstrukturen sowohl als Baum als
auch in ihrer üblichen Darstellung als Feld an.

Heap,
Heapsort,
Komplexi-
tät

(Für diese Aufgabe s. [DUD], Stichwort

Heapsort“)

”

(cid:28)

------------------------------------------------------------------------
204

2 Algorithmen und Datenstrukturen

a) Aus den zu sortierenden Elementen wird zuerst ein binärer Baum gebaut.
Dieser ist noch völlig unsortiert. Anschließend wird der Baum durch Ver-
sickern der Knoten ausgehend von den Blättern sortiert. Jeder Knoteninhalt,
der kleiner als mindestens einer seiner Nachfolger ist, sinkt durch Vertau-
schen nach unten ab. Der Heap besitzt nicht die Eigenschaft eines binären
Suchbaums, es wird nur gewährleistet, dass die Inhalte jeder Ebene größer
sind als die darunter liegenden. Dadurch muss die Heapeigenschaft bei der
Ausgabe nach jedem Element wieder hergestellt werden. Dazu wird ein Blatt,
z. B. immer das am Weitesten rechts stehende, in die Wurzel geschrieben und
versickert.

b) Die Komplexität beträgt O(n · log(n)).

Bei n Knoten hat der Baum eine Tiefe von log(n), denn der Baum ist immer
ausgeglichen. Im Worst Case müssen beim Aufbau des Heaps alle Knoten
umsortiert werden, was n · 2 log(n) Vergleiche bedeutet. Bei der Ausgabe des
Heaps müssen nach jedem Schritt maximal log(n) Vergleiche durchgeführt
werden, werden alle n Knoten ausgegeben führt dies zu n·2 log(n). Insgesamt
ergibt sich O(n · log(n)) + O(n · log(n)) = O(n · log(n))

c) Zuerst werden die Zahlenwerten ebenenweise in der gegebenen Reihenfolge
eingefügt. Nun wird beginnend bei der untersten Ebene jeweils geprüft, ob
die Heapeigenschaft für den aktuellen Teilbaum (Wurzel ist jeweils der aktu-
elle Knoten) erfüllt ist und diese dann gegebenenfalls vom aktuellen Knoten
nach unten arbeitend hergestellt. Unter der Baumdarstellung ist jeweils die
zugehörige Darstellung als Liste zu sehen.


------------------------------------------------------------------------
Herbst 07 - Thema 2

205

Nun wird jeweils das Minimum (die Wurzel) ausgelesen, dann die Heap-
eigenschaft wieder hergestellt (dadurch, dass das rechteste Element der un-
tersten Ebene den Platz der Wurzel einnimmt und dann
versickert“). Das
”
Löschen des Wurzelwertes ist durch das rote Kreuz dargestellt, das Element,
das den Platz der Wurzel einnimmt mit einem grünen Pfeil gekennzeichnet.
Rechts neben dem Heap sind die jeweils bereits ausgelesenen Werte aufgelis-
tet.


------------------------------------------------------------------------
206

2 Algorithmen und Datenstrukturen


------------------------------------------------------------------------
Frühjahr 08 - Thema 2

207

Frühjahr 08 - Thema 2

Aufgabe 1

a) Führen Sie den Dijkstra-Algorithmus zur Bestimmung aller kürzesten Pfa-

de vom Startknoten s am folgenden Graphen aus:

Algorith-
mus von
Dijkstra,
Heap

Begründen Sie Ihre Schritte geeignet.

b) Der Dijkstra-Algorithmus benutzt einen Heap R, in dem diejenigen Kno-

ten verwaltet werden, deren Entfernung zu s noch nicht endgültig feststeht.
Sei v1, v2, ...vn eine Anordnung der Knoten in der Reihenfolge, in der sie
aus R mittels deletemin(R, v) herausgenommen werden. Weisen Sie nach,
dass in dieser Anordnung die Knoten aufsteigend nach der Entfernung d[v]
von s sortiert sind.
Hinweis: Zeigen Sie zuerst, dass für alle benachbarten Paare (vi, vi+1) von
Knoten gilt: vi ≤ vi+1.

a)

S

s
s v
s v w
s v w t
s v w t u

t

u

w Heap

s
v
0 ∞ ∞ ∞ ∞ s t u v w
10 ∞ 5 ∞ v t u w
0
8 ∞ 5
0
5
13
8
0
5
11
8
0
5
11
8
0

w t u
t u
u

7
7
7
7


------------------------------------------------------------------------
208

2 Algorithmen und Datenstrukturen

b) Zu jedem Zeitpunkt stehen im Heap alle Knoten in der Reihenfolge der
zu diesem Zeitpunkt errechneten Abstände von s. Alle nicht betrachteten
Knoten ergänzen in beliebiger Reihenfolge den Heap. Zu Beginn wird der
Startknoten entfernt (v1 = s), dessen Entfernung zu sich selbst oﬀensicht-
lich minimal (nämlich gleich 0) ist. Jetzt wird der vom Startknoten aus am
wenigstens weit entfernte Knoten v2 herausgegriﬀen und dessen sämtliche
Nachbarknoten betrachtet. Es ist sicher, dass er selbst einen größeren Ab-
stand zu s hat als s selbst (nämlich irgendeinen positiven) und alle von
ihm aus erreichbaren Nachbarknoten weiter von s entfernt sind als er selbst
(d[s, vi] = d[s, v2] + d[v2, vi], wobei i ∈ {3..n}, d[v2, vi] > 0). So sind auch
bei jedem weiteren Knoten vj bereits alle Vorgängerknoten untersucht, also
der Weg mit der minimalen Entfernung zu vj bereits bekannt. Alle von vj
erreichbaren Knoten werden betrachtet und als nächster Knoten vj+1 derje-
nige gewählt, für den die Summe d[s, vj] + d[vj, vj+1] = d[s, vj+1] minimal
ist. Somit werden auch alle weiteren Knoten mit aufsteigender Reihenfolge
ihrer Entfernung von s aus dem Heap ausgelesen.


------------------------------------------------------------------------
3

Objektorientierte
Modellierung

Herbst 02 - Thema 1

Aufgabe 4

In einer Anforderungsanalyse für ein Banksystem wird der folgende Sachverhalt
beschrieben: Eine Bank hat einen Namen und sie führt Konten. Jedes Konto
hat eine Kontonummer, einen Kontostand und einen Besitzer. Der Besitzer hat
einen Namen und eine Kundennummer. Ein Konto ist entweder ein Sparkonto
oder ein Girokonto. Ein Sparkonto hat einen Zinssatz, ein Girokonto hat einen
Kreditrahmen und eine Jahresgebühr.
a) Deklarieren Sie geeignete Klassen in Java oder in C++, die die oben be-

Klassendia-
gramm,
abstrakte
Klasse,
Vererbung,
Konstruk-
tor,
abstrakte
Methode

schriebenen Anforderungen widerspiegeln! Nutzen Sie dabei das Vererbungs-
konzept aus, wo es sinnvoll ist! Gibt es Klassen, die als abstrakt zu verste-
hen sind?

b) Geben Sie für alle nicht abstrakten Klassen benutzerdeﬁnierte Konstrukto-

ren an mit Parametern zur Initialisierung der folgenden Werte: der Name ei-
ner Bank, die Kontonunmer, der Kontostand, der Besitzer und der Zinssatz
(bzw. Kreditrahmen und Jahresgebühr) eines Sparkontos (bzw. Girokon-
tos), der Name und die Kundennummer eines Kontobesitzers!
Ergänzen Sie die Klassen um Methoden für die folgenden Aufgaben! Nutzen
Sie wenn immer möglich das Vererbungskonzept aus und verwenden Sie ggf.
abstrakte (bzw. virtuelle) Methoden!

c) Auf ein Konto soll ein Betrag eingezahlt werden können und es soll ein Be-
trag abgehoben werden können. Soll von einem Sparkonto ein Betrag abge-
hoben werden, dann darf der Kontostand nicht negativ werden. Bei einer
Abhebung von einem Girokonto darf der Kreditrahmen nicht überzogen
werden.

d) Ein Konto kann eine Jahresabrechnung durchführen. Bei der Jahresabrech-
nung eines Sparkontos wird der Zinsertrag gut geschrieben, bei der Jahres-
abrechnung eines Girokontos wird die Jahresgebühr abgezogen (auch wenn
dadurch der Kreditrahmen überzogen wird).

e) Eine Bank kann einen Jahresabschluss durchführen. Dieser bewirkt, dass für

jedes Konto der Bank eine Jahresabrechnung durchgeführt wird.


------------------------------------------------------------------------
210

3 Objektorientierte Modellierung

f) Eine Bank kann ein Sparkonto eröﬀnen. Die Methode soll die folgenden

fünf Parameter haben: den Namen und die Kundennummer des Kontobesit-
zers, die Kontonummer, den (anfänglichen) Kontostand und den Zinssatz
des Sparkontos. Alle Parameter sind als String-Objekte oder als Werte eines
Grunddatentyps zu übergeben! Das Sparkonto muss nach seiner Eröﬀnung
in den Kontenbestand der Bank aufgenommen sein.

a)

B a n k

- n a m e

f u e h r t

K o n t o

# k o n t o n r
# k o n t o s t a n d

h a t

B e s i t z e r

- n a m e
- k u n d e n n r

S p a r k o n t o

- z i n s s a t z

G i r o k o n t o

- k r e d i t r a h m e n
- j a h r e s g e b u e h r

Die Klasse Konto ist abstrakt, da ein Konto immer entweder ein Spar- oder
ein Girokonto ist. Ein Objekt der Klasse Konto ist deshalb nicht sinnvoll.

class Bank {

private string name;
private ArrayList <Konto> fuehrt;}

abstract class Konto {

protected int kontonr;
protected float kontostand;
protected Besitzer hatBesitzer;}

class Sparkonto extends Konto {
private float zinssatz;}

class Girokonto extends Konto {

private float kreditrahmen;
private float jahresgebuehr;}


------------------------------------------------------------------------
Herbst 02 - Thema 1

211

class Besitzer {

private string name;
private int kundennr;
private Konto hatKonto;}

b) class Bank {

private String name;
private ArrayList <Konto> fuehrt;
public Bank (String name) {
this.name = name;

}}

abstract class Konto {

protected int kontonr;
protected float kontostand;
protected Besitzer hatBesitzer;}

class Sparkonto extends Konto {
private float zinssatz;
public Sparkonto(int knr, float kst, Besitzer b, float zs) {

super(knr, kst, b);
zinssatz = zs;

}}

class Girokonto extends Konto {
private float kreditrahmen;
private float jahresgebuehr;
public Girokonto(int knr,float kst,Besitzer b,float kr,float jg){

super(knr, kst, b);
kreditrahmen = kr;
jahresgebuehr = jg;

}}

class Besitzer {

private String name;
private int kundennr;
public Besitzer (String name, int kundennr) {

this.name = name;
this.kundennr = kundennr;

}}

Bemerkung: Auch eine abstrakte Klasse kann einen Konstruktor besitzen,
dieser kann nur nicht ausgeführt werden. In den abgeleiteten Klassen kann
dieser Super-Konstruktor aber verwendet werden.


------------------------------------------------------------------------
212

3 Objektorientierte Modellierung

}

}

}

}

c) abstract class Konto {

public void einzahlen(float betrag){

kontostand += betrag;}

class Sparkonto extends Konto {

public boolean abheben(float betrag){
if (kontostand - betrag >= 0) {
kontostand -= betrag;
return true;}
else return false;

class Girokonto extends Konto {

public boolean abheben(float betrag){

if (kontostand - betrag >= kreditrahmen) {

kontostand -= betrag;
return true;}
else return false;}

}

Anmerkung: Die Attribute wurden weggelassen, nur Methoden aufgeführt.
Die Methode einzahlen ist in der Klasse Konto implementiert, da sie sich
für Spar- und Girokonten nicht unterscheidet im Gegensatz zur Methode
abheben, die in beiden Klassen unterschiedlich implementiert ist. Kredit-
rahmen wird als negativer Wert gespeichert. Die Methoden zum Abheben lie-
fern zusätzlich zur änderung des Kontostandes eine Rückmeldung bezüglich
Erfolg oder Misserfolg der Abbuchung.

d) class Sparkonto extends Konto {
public void abrechnung() {

kontostand += kontostand*zinssatz;}

class Girokonto extends Konto {
public void abrechnung() {

kontostand -= jahresgebuehr;}

e) class Bank {

public abrechnung () {

for (int i = 0; i <= fuehrt.size(); i++){

fuehrt[i].abrechnung;}

} }


------------------------------------------------------------------------
Herbst 02 - Thema 2

213

f) class Bank {

public anlegen (String n,int kn,int kto,float kst,float zs){

Besitzer bes = schonVorhanden(n, kn);
fuehrt[fuehrt.size()] = new Sparkonto(kto, kst, bes, zs);

}

public Besitzer schonVorhanden (String name, int kunr){

for (int i = 0; i <= fuehrt.size(); i++){

if (fuehrt[i].hatBesitzer.kundennr = kunr) {

return fuehrt[i].hatBesitzer}

}
return new Besitzer(name, kunr);

}

}

Herbst 02 - Thema 2

Aufgabe 5

Sie sollen in dieser Aufgabe eine objektorientierte Analyse für eine Bibliothek er-
stellen. In dem System sollen mindestens Ausleiher, der Bibliothekar und Bücher
(jedes Buch ist genau einmal, d. h. nicht mehrfach vorhanden) repräsentiert sein.
Desweiteren existieren folgende Geschäftsprozesse:
1. Buch ausleihen: ein Ausleiher, dessen Name und Anschrift dem System be-

Klassendia-
gramm,
Sequenzdia-
gramm

kannt sind, leiht ein Buch aus.

2. Buch zurückgeben: Ein Ausleiher gibt ein geliehenes Buch zurück. Hier wird
auch gleich bei überzogener Frist (dieses Buches) die Zahlung für die Mah-
nung eingefordert.

3. Mahnungen verschicken: Der Bibliothekar überprüft bei allen entliehenen
Büchern die Ausleihfrist. Falls diese abgelaufen ist, verschickt er an den
Ausleiher täglich eine Mahnung.

Ein Buch soll folgende Attribute besitzen: 1) Autoren, 2) Titel, 3) Jahr, 4) ISBN,
5) Genre und 6) Schlagwörter. Genre kann dabei eine von fünf verschiedene
Möglichkeiten sein und es existieren mindestens 50 verschiedene Schlagwörter,
die allerdings vom Benutzer erweitert werden können.

Als Chefentwickler müssen Sie folgende Aufgaben erledigen:
a) Zeichnen Sie ein Analyse-Klassendiagramm für dieses Szenario!
b) Fertigen Sie für alle Geschäftsprozesse Sequenzdiagramme an!


------------------------------------------------------------------------
214

a)

b)

3 Objektorientierte Modellierung

B i b l i o t h e k a r

- N a m e :   S t r i n g
+ a n m a h n e n ( ) :   v o i d

b e t r e u t

A u s l e i h e r

- N a m e :   S t r i n g
- A n s c h r i f t :   S t r i n g
- L N R :   i n t
+ t e s t e n M a h n u n g ( ) :   v o i d

l e i h t _ a u s

G e n r e

g e h ö r t _ z u

B u c h

- B e z e i c h u n g :   S t r i n g

- A u t o r e n :   S t r i n g   [ ]
- T i t e l :   S t r i n g
- I S B N :   l o n g
- J a h r :   i n t
- S c h l a g w ö r t e r :   S t r i n g   [ ]
- A u s l e i h d a t u m :   D A T E
- F r i s t :   i n t
+ p r ü f e ( ) :   b o o e l a n
+ b e r e c h n e G e b ü h r ( ) :   i n t
+ a b g e b e n ( ) :   v o i d

B u c h

a u s l e i h e n

s e t z e D a t u m ( D a t e   d )

B u c h

a b g e b e n

h o l e D a t u m ( )

h o l e F r i s t ( )

p r ü f e ( D a t e   d ,   i n t   f )

b e r e c h n e G e b ü h r ( D a t e   d ,   i n t   f )


------------------------------------------------------------------------
Frühjahr 04 - Thema 1

215

B i b l i o t h e k a r

A u s l e i h e r

B u c h

a n m a h n e n

t e s t e n M a h n u n g

p r ü f e

h o l e D a t u m ( )

h o l e F r i s t ( )

Frühjahr 04 - Thema 1

Aufgabe 6

a) Geben Sie exemplarisch drei Design-Pattern (oder Entwurfsmuster) an, er-
läutern Sie deren Einsatzgebiet und Funktionsweise und diskutieren Sie an-
hand dieser Beispiele verschiedene mögliche Arten von Design-Pattern.

b) Erstellen Sie ein Klassendiagramm (im Sinne der UML) für die Prüfungsver-
waltung an einer Hochschule. Sie sollten dabei zumindest Studenten, Prüfer,
mündliche Prüfungen, schriftliche Prüfungen und Prüfungsfächer modellie-
ren. Nutzen Sie die Möglichkeiten der Vererbung und bemühen Sie sich um
eine möglichst ﬂexible Modellierung. Begründen Sie dabei einzelne Ent-
wurfsentscheidungen.

Entwurfs-
muster,
Klassendia-
gramm

a) Beobachter: Ein objektbasiertes Verhaltensmuster, das dafür sorgt, dass
bei der änderung eines Objekts alle davon abhängigen Ob-
jekte benachrichtigt und aktualisiert werden.
Singleton: Ein objektbasiertes Erzeugungsmuster, dass sicher stellt,

Proxy:

dass von einer Klasse genau ein Objekt existiert und globa-
len Zugriﬀ auf dieses Objekt ermöglicht.
Ein objektbasiertes Strukturmuster, dass den Zugriﬀ auf ein
Objekt mit Hilfe eines vorgelagerten Stellvertreterobjekts kon-
trolliert, so dass nicht direkt auf das Objekt zugegriﬀen
werden kann.

(s. [BAL] S. 281ﬀ.)

(cid:28)

------------------------------------------------------------------------
216

3 Objektorientierte Modellierung

Diese drei Entwurfsmuster sind objektbasiert, d. h. sie beschreiben die Be-
ziehungen zwischen einzelnen Objekten im Gegensatz zu klassenbasierten
Mustern. Mit Hilfe von Strukturmustern können Klassen und Objekte zu
größeren Strukturen zusammengesetzt werden. Verhaltensmuster befassen
sich mit der Interaktion zwischen Objekten und Klassen, für objektbasier-
te Verhaltensmuster werden Aggregation und Komposition eingesetzt. Ein
Entwurfsmuster gibt eine bewährte Lösung für ein immer wiederkehrendes
Problem an, das in bestimmten Situationen auftritt. Entwurfsmuster sparen
an vielen Stellen Code, da sie wiederverwendbar sind und durch den einheit-
lichen Aufbau bleibt die Software auch besser pﬂegbar.

b)

i s t B e i s i t z e r

S c h r i f t l i c h

M u e n d l i c h

S t u d e n t

- i m m a :   i n t
- n a m e :   s t r i n g
- v o r n a m e :   s t r i n g

1

n i m m t T e i l

P r u e f u n g

- d a t u m :   d a t e
- u h r z e i t :   t i m e
- n o t e :   i n t
+ s e t z e N o t e ( i n t )

n i m m t A b

1

1

P r u e f e r

- P e r s N r :   l o n g
- n a m e :   S t r i n g
- v o r n a m e :   s t r i n g

1

F a c h

- b e z e i c h n u n g

Herbst 04 - Thema 2

Aufgabe 4

objekt-
orientierter
Entwurf,
Klassendia-
gramm,
Objektdia-
gramm,
Methode

Ein Volkslauf besitzt einen Namen, die Länge der Strecke, der Ort und das Da-
tum sind weitere wichtige Eigenschaften. Ein Volkslauf wird von Mitgliedern
einer Laufsportgruppe veranstaltet. Läufer, die an dem Lauf teilnehmen wollen,
müssen zur Anmeldung ihren Namen, die Laufsportgruppe, der sie angehören
und ihre Altersklasse mitteilen. Es soll deutlich zwischen der Rolle als Laufver-
anstalter und als Mitläufer unterschieden werden.


------------------------------------------------------------------------
Herbst 04 - Thema 2

217

a) Modellieren Sie den Sachverhalt durch ein UML-Klassendiagramm. Dabei
soll zum Ausdruck kommen, dass an einem Volkslauf mindestens 50 Läu-
fer teilnehmen und ein Läufer durchaus an mehreren Volksläufen teilneh-
men kann.

b) Geben Sie ein Objektdiagramm für folgende Situation

• Sammy nimmt teil an Residenzlauf.
• Sammy nimmt teil an Nikolauslauf.
• Hans veranstaltet Nikolauslauf.
• Paul nimmt teil an Residenzlauf.
• Haile nimmt teil an Residenzlauf.

c) Implementieren Sie die Klasse Läufer in Java. Dabei soll ein Läufer einen
Namen, eine Laufsportgruppe und sein Geburtsjahr als Attribute besit-
zen. Eine Methode bestimmt die Altersklasse. Altersklassen sind nur vom
Geburtsjahr abhängig.

• unter 18 Jahre: Jugend
• 19 bis 29 Jahre: Haupt
• zwischen i und i + 4 Jahren: Mi i = 30, 35, ...

d) Sehen Sie nun vor, dass der Läufer auch seine Volkslauf-Teilnahmen einse-
hen kann. Legen Sie eine entsprechende Datenstruktur an. Schreiben Sie
eine Methode printLaeufe (int jahr), die die Namen aller Läufe, bei de-
nen er im Jahr jahr mitgelaufen ist, ausgibt.

a)

V o l k s l a u f

- N a m e :   S t r i n g
- L a e n g e :   F l o a t
- O r t :   S t r i n g
- V e r a n s t a l t u n g s d a t u m :   D a t u m

1 . . *

v e r a n s t a l t e t

0 . . *

1 . . *

n i m m t _ t e i l

5 0 . . *

L a e u f e r

- N a m e :   S t r i n g
- L a u f s p o r t g r u p p e :   S t r i n g
- G e b u r t s j a h r :   i n t
+ a l t e r s k l a s s e ( )

b)

R e s i d e n z l a u f

N i k o l a u s l a u f

n i m m t _ t e i l

n i m m t _ t e i l

n i m m t _ t e i l

n i m m t _ t e i l

v e r a n s t a l t e t

P a u l

H a i l e

S a m m y

H a n s


------------------------------------------------------------------------
218

3 Objektorientierte Modellierung

c) import java.util.ArrayList;

public class Laeufer {

private String name;
private String laufsportgruppe;
private int geburtsjahr;
private ArrayList <Volkslauf> veranstaltetListe;
private ArrayList <Volkslauf> nimmt teilListe;

public Laeufer(String n, String lg, int gj) {

name = n;
laufsportgruppe = lg;
geburtsjahr = gj;
veranstaltetListe = new ArrayList <Volkslauf> ();
nimmt teilListe = new ArrayList <Volkslauf> ();

}

public void nimmt teil(Volkslauf vl) {

nimmt teilListe.add(vl);
return;

}

public void veranstaltet(Volkslauf vl) {

veranstaltetListe.add(vl);
return;

}

public String gibAltersklasse() {

if (aktuellesJahr - geburtsjahr <= 18)
return ’Jugend’;
else if (aktuellesJahr - geburtsjahr <= 29)
return ’Haupt’;
else {

return ’M’+((aktuellesJahr - geburtsjahr)/5)∗5);}

}

}

d) Datenstruktur: ArrayList (s. o.), deren Objekte Volksläufe sind

public void printLaeufe(int jahr) {

for (int i = 0; i <= nimmt teilListe.size(); i++) {

if (nimmt teilListe(i).gibDatum().gibJahr() == jahr)
System.out.println(Volkslauf.Name);

}


------------------------------------------------------------------------
objekt-
orientierter
Entwurf,
Klassendia-
gramm

Herbst 05 - Thema 2

219

Herbst 05 - Thema 2

Aufgabe 4

Seit Jahren bemühen sich die Finanzbehörden, insbesondere private Steuerzah-
ler zur elektronischen Abgabe der Steuererklärung (ELSTER) zu bewegen. Erst
in den letzten Jahren ist aufgefallen, dass die Unterstützung eines einzigen Be-
triebssystems zu einschränkend ist. Es sind die Grundlagen eines plattformunab-
hängigen ELSTER-Programms zur Unterstützung der folgenden Anforderungen
zu modellieren:

• Das Programm unterstützt die üblichen Formulare einer Steuererklärung,
z. B. den Mantelbogen, Anlage N (Nichtselbstständige), Kap (Kapitalein-
künfte), ...

• Jedes Formular besteht aus Zeilen, die wiederum vorgegebenen Text oder
Eingabefelder enthalten können. Einige Felder werden aus den Werten an-
derer Felder anhand vorgegebener Formeln wie in einer Tabellenkalkula-
tion berechnet.

• Zu jedem Formular gibt es speziﬁsche Regeln, um die Eingaben zu veriﬁzie-

ren.

• Eine kontextsensitive und formularspeziﬁsche Hilfe zum Ausfüllen der ein-

zelnen Formulare ist anzubieten.

• Parallel zur Eingabe der Daten in ein Formular sollen Zusatzinformationen
als Freitext erfasst werden, der dann als Anlage für z. B. Begründungen
und Absetzungen zu den Formularen beigelegt werden kann.

Stellen Sie die relevanten Klassen durch ein verfeinertes UML-Analyseklassen-
diagramm dar! Speziﬁzieren Sie die Beziehungen zwischen den Klassen.

S t e u e r e r k l a e r u n g

- s t e u e r n r :   i n t
- f i n a n z a m t :   s t r i n g

*

F o r m u l a r

- t y p :   s t r i n g

1

F r e i t e x t

- t x t :   s t r i n g

Z e i l e

- z e i l e n n r :   i n t

*

R e g e l

+ p r u e f e n ( )

*

H i l f e s t e l l u n g

+ a n z e i g e n ( )

T e x t

- t x t :   s t r i n g

E i n g a b e f e l d

n

- w e r t :   s t r i n g
+ b e r e c h n e n ( )

1

w i r d _ b e r e c h n e t _ a u s


------------------------------------------------------------------------
220

3 Objektorientierte Modellierung

Frühjahr 06 - Thema 2

Aufgabe 3

Klassendia-
gramm,
Zustands-
diagramm

Es soll ein Mühlespiel programmiert werden. Die beiden Spieler sollen abwech-
selnd mit der Maus Züge wählen; das Programm soll überprüfen, ob ein Zug
erlaubt ist und das Ergebnis des Zuges auf dem Bildschirm anzeigen.
1. Skizzieren Sie einen objektorientierten Entwurf für diese Aufgabenstellung
in Form eines Klassendiagramms (in UML o. ä.). Ihr Diagramm sollte
nicht weniger als fünf Klassen haben und neben den Beziehungen der Klas-
sen untereinander auch deren wichtigste Methoden und Attribute beinhal-
ten.

2. Das Programm muss mehrere Zustände haben aus denen hervorgeht, wel-

cher Spieler am Zug ist, ob die Maus gedrückt wurde, ob das Spiel zu Ende
ist, etc. Modellieren Sie diese Programmzustände als Ablaufdiagramm.

1.

S p i e l e r

2

- a k t i v :   b o o l e a n
- g e w o n n e n :   b o o l e a n

h a t

f u e h r t A u s

S p i e l z u g

1 . . 2
+ s e t z e n S t e i n ( )
+ b e w e g e n S t e i n ( )
+ e n t f e r n e n S t e i n ( )

n i m m t T e i l

2 . . 9

S p i e l s t e i n

b e t r i f f t

1

- F a r b e   =   ( s c h w a r z ,   w e i s s )
- S t e i n n u m m e r

S p i e l

- S p i e l B e e n d e t :   b o o l e a n
+ d a r s t e l l e n Z u g ( ) :   v o i d
+ p r u e f e S p i e l e n d e ( ) :   i n t
+ p r u e f e Z u g E r l a u b t ( S p i e l z u g ) :   b o o l e a n

b e l e g t

0 . . 1

F e l d

- F e l d n u m m e r :   i n t

2 . . 4

h a t N a c h b a r f e l d

2. Es gibt keine einheitliche Deﬁnition, was ein Ablaufdiagramm genau ist. Le-
diglich herrscht übereinstimmung darin, dass hiermit Abläufe verdeutlicht
werden sollen. Nachdem hier von Zuständen die Rede ist, verwenden wir im
folgenden ein Zustandsdiagramm.


------------------------------------------------------------------------
Herbst 06 - Thema 1

221

p r ü f e n ,   o b   A   g e w o n n e n   h a t [ j a ]

S p i e l z u g   u n g ü l t i g

S p i e l e r   A

M a u s   g e d r ü c k t

S p i e l z u g   p r ü f e n

S p i e l z u g   g ü l t i g

S p i e l z u g   d a r s t e l l e n

S p i e l e r   B

M a u s   g e d r ü c k t

S p i e l z u g   p r ü f e n

S p i e l z u g   d a r s t e l l e n

S p i e l z u g   g ü l t i g

p r ü f e n ,   o b   A   g e w o n n e n   h a t [ j a ]

p r ü f e n ,   o b   B   g e w o n n e n   h a t [ j a ]

S p i e l z u g   u n g ü l t i g

Herbst 06 - Thema 1

Aufgabe 5

a) Erklären Sie den Begriﬀ Vererbung und benennen Sie die damit verbunde-

nen Vorteile!

b) Erstellen Sie zu der folgenden Beschreibung eines Systems zur Buchung von
Flügen ein Klassendiagramm, das neben Attributen und Assoziationen mit
Kardinalitäten auch Methoden zur Tarifberechnung enthält! Setzen Sie da-
bei das Konzept der Vererbung sinnvoll ein!

• Die Fluggesellschaft bietet verschiedene Flugrouten an, die durch den
jeweiligen Startﬂughafen und Zielﬂughafen charakterisiert werden.
• Jeder Flug besitzt eine Flugnummer, ein Abﬂugzeit, eine geplante

Klassendia-
gramm,
Objektdia-
gramm,
Sequenzdia-
gramm,
Vererbung

Ankunftszeit und ist genau einer Flugroute zugeordnet. Flugrouten sol-
len auch gespeichert werden, falls noch keine zugehörigen Flüge existie-
ren.

• Flugbuchungen beziehen sich auf einzelne Plätze im Flugzeug. Sowohl
in der Economy Class als auch in der Business Class gibt es Nichtrau-
cher- und Raucherplätze. Zu jeder Buchung wird das Datum vermerkt.

• Zu jedem Passagier müssen die Adressinformationen erfasst werden.
• Die Berechnung des Tarifs soll vom System unterstützt werden. Jeder
Flug besitzt einen Grundpreis. Für Plätze der Business Class wird ein
Aufschlag verrechnet. Auf diesen ermittelten Zwischenpreis sind zwei
Arten von Rabatten möglich:

– Jugendliche Privatkunden unter 25 Jahren erhalten einen Nach-

lass auf den Flugpreis.

– Geschäftsreisende erhalten Vergünstigungen in Abhängigkeit ihrer

gesammelten Flugmeilen.

c) Erstellen Sie ein exemplarisches Objektdiagramm! Es soll mindestens einen
Flug enthalten, in dem sowohl ein privater Kunde als auch ein Geschäfts-
kunde einen Platz gebucht haben! Wählen Sie geeignete Attributwerte!

d) Beschreiben Sie den Vorgang

Tarifberechnung“ wahlweise als
”

Sequenzdiagramm oder Kommunikationsdiagramm!


------------------------------------------------------------------------
222

3 Objektorientierte Modellierung

a) In der objektorientierten Programmierung versteht man unter Vererbung,
dass neue Klassen N alle oder gewisse Eigenschaften (Attribute, Methoden)
einer bereits existierenden Klasse K übernehmen. Hierdurch wird Implemen-
tierungsarbeit gespart. K wird Oberklasse oder Superklasse von N ge-
nannt; die Klasse N heißt Unterklasse oder Subklasse von K. Jede ererbte
Eigenschaft darf aber auch bei der Deklaration von N umdeﬁniert (
über-
”
schrieben“) werden. Die Vererbung ist nicht auf zwei Schichten beschränkt.
Es kann eine ganze Vererbungshierarchie erstellt werden.
Das Vererbungskonzept dient auch der Polymorphie, indem zunächst eine
recht grobe Klasse kreiert wird, die man erst im Laufe der Entwicklung im-
mer weiter zu der angestrebten Subklasse verfeinert.
(s. [DUD] S. 719f.)
Bei der folgenden Modellierung wird davon ausgegangen, dass Geschäftskun-
den immer Businessclass und Privatkunden stets Economyclass buchen.

b)

F l u g

- f l u g n u m m e r :   i n t
- a b f l u g z e i t :   t i m e
- a n k u n f t s z e i t :   t i m e
- g r u n d p r e i s :   f l o a t

1

g i l t _ f u e r

B u c h u n g

- b u c h u n g s n u m m e r :   i n t
- d a t u m :   d a t e
+ b e r e c h n e P r e i s ( )
+ b e r e c h n e R a b a t t ( )

w i r d _ v o r g e n o m m e n _ v o n

1

P e r s o n

- a l t e r :   i n t
- a d r e s s e :   S t r i n g
- n a m e :   S t r i n g
+ g i b A l t e r ( ) :   i n t

        h a t

b e z i e h t _ s i c h _ a u f

1

F l u g r o u t e

- s t a r t f l u g h a f e n :   S t r i n g
- z i e l f l u g h a f e n :   S t r i n g

1

P l a t z

# r a u c h e r :   b o o l e a n

E c o n o m y

B u s i n e s s

- f l u g m e i l e n :   i n t
- a u f s c h l a g :   f l o a t
+ g i b F l u g m e i l e n ( ) :   i n t
+ g i b A u f s c h l a g ( ) :   f l o a t

c)

f l u g 1 : F l u g

  f l u g n u m m e r :   1 2 3 4
  a b f l u g z e i t :   7 : 0 5
  a n k u n f t s z e i t :   1 5 : 3 0
  g r u n d p r e i s :   2 8 0

b u s i n e s s 1 : P l a t z

  r a u c h e r :   f a l s e
  f l u g m e i l e n :   2 5 6 3
  a u f s c h l a g :   0 . 0 7

b u c h u n g 2 : B u c h u n g

  b u c h u n g s n u m m e r :   9 3 4
  d a t u m :   2 3 . 7 . 0 8

b u c h u n g 1 : B u c h u n g

  b u c h u n g s n u m m e r :   8 1 6
  d a t u m :   1 7 . 8 . 0 8

r o u t e 1 : F l u g r o u t e

  s t a r t f l u g h a f e n :   A - H a f e n
  z i e l f l u g h a f e n :   B - S t a d t

e c o n o m y 1 : P l a t z

  r a u c h e r :   t r u e

p e r s o n 2 : P e r s o n

  a l t e r :   4 5
  a d r e s s e :   A - H a u s e n . . .
  n a m e :   H a n s   M e y e r

p e r s o n 1 : P e r s o n

  a l t e r :   3 7
  a d r e s s e :   B S t a d t   . . .
  n a m e :   G i s e l a   H u b e r

(cid:27)

------------------------------------------------------------------------
Herbst 06 - Thema 1

223

d)

b u c h u n g 1 : B u c h u n g

p e r s o n 1 : P e r s o n

A k t e u r

b e r e c h n e P r e i s ( )

b e r e c h n e R a b a t t ( )

g i b A l t e r ( )

b u c h u n g 2 : B u c h u n g

b u s i n e s s 1 : P l a t z

A k t e u r

b e r e c h n e P r e i s ( )

g i b A u f s c h l a g ( )

b e r e c h n e R a b a t t ( )

g i b F l u g m e i l e n ( )


------------------------------------------------------------------------
Klassendia-
gramm,
Objektdia-
gramm,
Sequenzdia-
gramm

224

3 Objektorientierte Modellierung

Herbst 06 - Thema 2

Aufgabe 3

Im Folgenden sollen Zusammenhänge innerhalb einer Präsentationssoftware als
Klassendiagramm dargestellt werden. Folgende Zusammenhänge sind zu berück-
sichtigen: Eine Präsentation besteht aus mehreren Folien (mindestens aus einer),
die sich in einer bestimmten Reihenfolge beﬁnden. Eine Folie kann Textboxen
sowie einfache Vektor- und Pixelgraﬁken enthalten. Textboxen enthalten Text
und haben eine Position sowie eine Breite und eine Höhe. Sie können eine Füll-
farbe haben und umrandet sein, in diesem Fall kann eine Randstärke und eine
Randfarbe angegeben werden. Für den enthaltenen Text kann die Schriftart und
die Schriftgröße erfasst werden. Vektorgraﬁken können aus Linien, Rechtecken
und Kreisen zusammengesetzt werden. Für diese können jeweils die Position, die
Linienstärke und Linienfarbe sowie ggf. eine Füllfarbe erfasst werden. Pixelgraﬁ-
ken liegen als externe Dateien vor und werden an einer bestimmten Position mit
einer gegebenen Höhe und einer Breite eingebunden. Die Elemente auf einer Fo-
lie werden in einer bestimmten Reihenfolge gezeichnet, um bestimmte Elemente
im Vordergrund, andere Elemente im Hintergrund verdecken zu lassen. Jeder
Folie ist ein Folienmaster zugeordnet, auf dem immer wiederkehrende Elemente
(z. B. ein Logo) zur Erstellung eines einheitlichen Layouts für mehrere Folien
erfasst werden können. Dabei kann ein Folienmaster prinzipiell dieselben Ele-
mente enthalten, wie eine normale Folie. Eine Präsentation kann ggf. mehrere
Folienmaster verwenden. Alle Elemente auf einer Folie (Textboxen, Rechtecke
etc.) können zu Gruppen zusammengefasst werden. Gruppen können ihrerseits
weitere Gruppen sowie die genannten Folienelemente enthalten.

a) Erstellen Sie für die beschriebenen Zusammenhänge ein UML-Klassendia-
gramm! Um eine Präsentation vorführen zu können, müssen verschiedene
Elemente der Folie über eine Operation darstellen zur Darstellung verfü-
gen. Ergänzen Sie diese! Jede Klasse soll mindestens über ein Attribut ver-
fügen. Speziﬁzieren Sie alle Attribute, Operationen und Beziehungen durch
Angabe von Datentypen, Beziehungstypen und -namen sowie Kardinalitä-
ten!


------------------------------------------------------------------------
Herbst 06 - Thema 2

225

a)

e n t h a e l t

G r u p p e

  g r u p p e n n r :   i n t
  r e i h e n f o l g e :   i n t
+ d a r s t e l l e n ( )

0 . . *

h a t

P r a e s e n t a t i o n

  a u t o r :   s t r i n g

b e s t e h t _ a u s

1 . . *

1

F o l i e

  f o l i e n n r :   i n t
+ d a r s t e l l e n ( )

h a t _ F o l i e n m a s t e r

  0 . . *

F o l i e n o b j e k t

  r e i h e n f o l g e :   i n t

P i x e l g r a f i k

  d a t e i n a m e :   s t r i n g
  x - p o s i t i o n :   f l o a t
  y - p o s i t i o n :   f l o a t
  b r e i t e :   f l o a t
  h o e h e :   f l o a t
+ d a r s t e l l e n ( )

T e x t b o x

  h o e h e :   f l o a t
  b r e i t e :   f l o a t
  x - p o s i t i o n :   f l o a t
  y - p o s i t i o n :   f l o a t
  f u e l l f a r b e :   s t r i n g
  u m r a n d e t :   b o o l e a n
  r a n d f a r b e :   s t r i n g
  r a n d s t a e r k e :   i n t
  t e x t :   s t r i n g
  s c h r i f t a r t :   s t r i n g
  s c h r i f t g r o e s s e :   i n t
+ d a r s t e l l e n ( )

V e k t o r g r a f i k

  b r e i t e :   f l o a t
  h o e h e :   f l o a t
+ d a r s t e l l e n ( )

b e s t e h t _ a u s

0 . . *

G r a f i k o b j e k t

  x - p o s i t i o n :   f l o a t
  y - p o s i t i o n :   f l o a t
  f u e l l f a r b e :   s t r i n g
  l i n i e n s t a e r k e :   i n t
  l i n i e n f a r b e :   s t r i n g
+ d a r s t e l l e n ( )

L i n i e

R e c h t e c k

K r e i s

  l a e n g e :   f l o a t

  b r e i t e :   f l o a t
  h o e h e :   f l o a t

  r a d i u s :   f l o a t


------------------------------------------------------------------------
226

3 Objektorientierte Modellierung

b) Gegeben sei folgende Folie:

Die Folie enthält eine überschrift. Im
Hauptteil beﬁndet sich eine Pixelgra-
ﬁk mit einer Bildunterschrift. Graﬁk
und Bildunterschrift bilden eine Grup-
pe. Der Folienmaster enthält ein hell-
graues Rechteck als Hintergrund für
den Hauptteil (ohne überschrift) und
ein Logo (Pixelgraﬁk) in der oberen
rechten Ecke. Geben Sie zu dieser Fo-
lie und dem zugehörigen Folienmaster

ein Objektdiagramm an!
Hinweis:
Gehen Sie von den üblichen Folienmaßen aus: Höhe = 21cm, Breite = 29,7cm.
Alle Angaben für Breiten, Höhen und Positionen von Folienelementen dürfen Sie
schätzen, keinesfalls müssen diese maßstabsgetreu sein! Das Koordinatensystem
habe in der oberen linken Ecke seinen Nullpunkt, Punkte im Inneren des Folien-
bereichs haben positive x- und y-Koordinaten.

b)

p r a e s e n t a t i o n 1 : P r a e s e n t a t i o n

A u t o r :   " H a n s   D a m p f "

f o l i e 1 : F o l i e

f o l i e n n r :   1 7

g r u p p e 1 : G r u p p e

g r u p p e n n r :   1

f o l i e n m a s t e r 1 : F o l i e

f o l i e n n r :   1

b o x U n t e r s c h r i f t : F o l i e n o b j e k t . T e x t b o x

b i l d 1 : F o l i e n o b j e k t . P i x e l g r a f i k

v e k t o r g r a f i k 1 : F o l i e n o b j e k t . V e k t o r g r a f i k

l o g o : F o l i e n o b j e k t . P i x e l g r a f i k

r e i h e n f o l g e :   3
h o e h e :   2 . 4
b r e i t e :   1 7 . 0
x - p o s i t i o n :   1 . 0
y - p o s i t i o n :   1 8 . 0
f u e l l f a r b e :   " w e i s s "
u m r a n d e t :   t r u e
r a n d f a r b e :   " s c h w a r z "
r a n d s t a e r k e :   1
t e x t :   " D i e s   i s t   e i n . . . "
s c h r i f t a r t :   " v e r d a n a "
s c h r i f t g r o e s s e :   1 6

d a t e i n a m e :   " b i l d . g i f "
r e i h e n f o l g e :   4
x - p o s i t i o n :   1 . 0
y - p o s i t i o n :   4 . 0
b r e i t e :   1 7 . 0
h o e h e :   1 2 . 0

r e i h e n f o l g e :   0
h o e h e :   1 9 . 0
b r e i t e :   2 8 . 0

d a t e i n a m e :   " l o g o . g i f "
r e i h e n f o l g e :   1
x - p o s i t i o n :   2 6
y - p o s i t i o n :   0 . 5
b r e i t e :   3 . 0 0
h o e h e :   1 . 5

r e c h t e c k 1 : G r a f i k o b j e k t . R e c h t e c k

x - p o s i t i o n :   0 . 2
y - p o s i t i o n :   4 . 0
f u e l l f a r b e :   " h e l l g r a u "
l i n i e n s t a e r k e :   0
l i n i e n f a r b e :   " "
h o e h e :   1 9 . 0
b r e i t e :   2 8 . 0

b o x U e b e r s c h r i f t : F o l i e n o b j e k t . T e x t b o x

r e i h e n f o l g e :   2
h o e h e :   3 . 5
b r e i t e :   1 8 . 0
x - p o s i t i o n :   0 . 5
y - p o s i t i o n :   0 . 5
f u e l l f a r b e :   " w e i s s "
u m r a n d e t :   t r u e
r a n d f a r b e :   " s c h w a r z "
r a n d s t a e r k e :   1
t e x t :   " B e i s p i e l ü b e r s c h r i f t "
s c h r i f t a r t :   " v e r d a n a "
s c h r i f t g r o e s s e :   1 8


------------------------------------------------------------------------
Herbst 06 - Thema 2

227

c) Die Folie aus Aufgabe b) soll präsentiert (dargestellt) werden. Zeichnen Sie

für diese Situation ein UML-Sequenzdiagramm!

c)

)
(
n
e

l

l

e

t
s
r
a
d

)
(
n
e

l

l

e

t
s
r
a
d

)
(
n
e

l

l

e

t
s
r
a
d

x
o
b
t
x
e
T

:

t

f

i
r
h
c
s
r
e
t
n
U
x
o
b

k

i
f

a
r
g

l

e
x

i

P

:

1
d

l

i

b

e
p
p
u
r

G

:

1
e
p
p
u
r
g

x
o
b

t
x
e
T

:

t

f

i
r
h
c
s
r
e
b
e
U
x
o
b

k

i

f

a
r
g

l

e
x

i

P

:

o
g
o

l

)
(
n
e

l

l

e

t
s
r
a
d

)
(
n
e

l

l

e

t
s
r
a
d

)
(
n
e

l

l

e

t
s
r
a
d

k
c
e

t

h
c
e
R

.

t
k
e

j

b
o
k

i

f

a
r

G

:

1
k
c
e

t

h
c
e
r

t
k
e

j

b
o
k

i

f
a
r
g
r
o
t
k
e
V

:
1
k

i

f
a
r
g
r
o
t
k
e
v

e

i

l

o
F

:
1
r
e
t
s
a
m
n
e

i

l

o
f

e

i

l

o
F

:
1
e

i

l

o

f

)
(
n
e

l

l

e
t
s
r
a
d

)
(
n
e

l

l

e
t
s
r
a
d

)
(
n
e

l

l

e

t
s
r
a
d

r
u
e

t
k
A


------------------------------------------------------------------------

------------------------------------------------------------------------
4

Betriebssysteme

Frühjahr 01 - Thema 1

Aufgabe 3

Prozess,
Thread,
Prozesszu-
stand,
Semaphor,
Erzeuger-
Verbrau-
cher-
Problem

3.1.1 Beschreiben Sie die Gemeinsamkeiten und Unterschiede zwischen ei-

nem Prozess und einem Thread.

3.1.2 Welche Zustände kann ein Thread während seiner Laufzeit annehmen?

3.2. Skizzieren Sie ein Programm-Modul (Klasse), das einen Ringpuﬀer imple-

mentiert, mit den Prozeduren (Methoden):
einfügenElement und entnehmenElement.
Die Prozeduren sollen von mehreren Threads parallel aufrufbar sein, d. h.
Sie müssen insbesondere auf die Koordinierung achten. Als Element kön-
nen Sie einen beliebigen Datentyp wählen.
3.2.1 Skizzieren Sie in einer Ihnen geläuﬁgen Programmiersprache (bzw. in
einer programmiersprachenähnlichen Notation) die verwendeten Da-
tenstrukturen.

prozedural“) die beiden Proze-
3.2.2 Skizzieren Sie in ähnlicher Notation (
”
duren (Methoden) zum Einfügen und Entfernen eines Elements. Der
Schwerpunkt soll auch hierbei auf den notwendigen Koordinierungs-
maßnahmen liegen.

3.2.3 Beschreiben Sie die Funktionsweise des von Ihnen verwendeten Koordi-

nierungsmechanismus.

3.1.1 (siehe Frühjahr 07 Thema 2 Aufgabe 1a) auf Seite 304
3.1.2 Da ein Thread einem leichtgewichtigen Prozess ähnlich ist, kann er die

gleichen Zustände annehmen wie ein Prozess: bereit, blockiert, aktiv
(siehe Herbst 06 Thema 1 Aufgabe 2.2 auf Seite 291)

x

x
3.2.1 (siehe Frühjahr 03 Thema 2 Aufgabe 5 auf Seite 245)
3.2.2 (vgl. hierzu Herbst 07 Thema 1 Aufgabe 4b) auf Seite 318) - Hierbei x

beschreibt die Methode
consumer“ das Verbrauchen oder Entnehmen der Elemente.
”
(siehe außerdem Frühjahr 03 Thema 2 Aufgabe 5 auf Seite 245)

producer“ das Erzeugen eines Elements und
”

3.2.3 (siehe Frühjahr 03 Thema 2 Aufgabe 5 auf Seite 245)

x

x


------------------------------------------------------------------------
230

4 Betriebssysteme

Herbst 01 - Thema 1

Aufgabe 2

Betriebs-
mittel,
Deadlock

Eine der wesentlichen Aufgaben eines Betriebssystems ist es, die vorhandenen
Hardware- und Software-Betriebsmittel zu verwalten und für einen verklem-
mungsfreien Ablauf der einzelnen Prozesse zu sorgen.
2.1. In welche Klassen können Betriebsmittel eingeteilt werden? Geben Sie für

jede der genannten Betriebsmittelklassen ein Beispiel an.

2.2. Bei der Zuteilung von Betriebsmitteln an Prozesse sollte das Auftreten von

Deadlocks ausgeschlossen werden. Welche vier Bedingungen sind Voraus-
setzung für einen Deadlock? Bei welchen der oben genannten Betriebsmit-
telklassen können diese Bedingungen eintreten?

2.3. Erklären Sie den Unterschied zwischen Deadlock-Verhinderung und Dead-

lock-Vermeidung, und nennen Sie jeweils ein Ihnen bekanntes Verfahren.

2.1. Betriebsmitteln sind klassiﬁzierbar in:

• aktive, zeitlich aufteilbare (Prozessor)
• passive, nur exklusiv nutzbare (periphere Geräte, z. B. Drucker u. ä.)
• passive, räumlich aufteilbare (z. B. Speicher, Plattenspeicher)

2.2. Exklusive Belegung:

Mindestens ein Betriebsmitteltyp muss nur exklusiv belegbar sein.
Nachforderungen von Betriebsmittel möglich:
Es muss einen Prozess geben, der bereits Betriebsmittel hält, und ein neues
Betriebsmittel anfordert.
Kein Entzug von Betriebsmitteln möglich:
Betriebsmittel können nicht zurückgefordert werden bis der Prozess sie wie-
der freigibt.
Zirkuläres Warten:
Es gibt einen Ring von Prozessen, in dem jeder auf ein Betriebsmittel wartet,
das der Nachfolger im Ring besitzt.
(siehe auch Herbst 06 Thema 1)

Exklusive Belegung ist wie der Name bereits sagt bei der Klasse der passi-
ven, nur exklusiv nutzbaren Betriebsmittel gegeben, allerdings werden hier
keine Betriebsmittel nachgefordert. Nachgefordert werden kann z. B. Spei-
cherplatz; dieser ist beim schreibenden Zugriﬀ auch nur exklusiv nutzbar!
Bei zeitlich aufteilbaren Betriebsmitteln kann es zwar zu Nachforderungen
kommen, aber eine exklusive Belegung kann nicht vorliegen.

y

2.3. (siehe Frühjahr 07 Thema 1 Aufgabe 3b) auf Seite 302 sowie [DUD], Stichworte

y

Nebenläuﬁgkeit“,

”

”

Philosophenproblem“)

(cid:27)

------------------------------------------------------------------------
Herbst 01 - Thema 1

231

Aufgabe 3

Gegeben sei ein Keller, in den Elemente der Klasse Element abgelegt werden
können. Auf dem Keller seien zwei Methoden deﬁniert: füge ein, mit der ein
Element der Klasse Element in den Keller eingefügt werden kann und entnimm,
mit der ein Element aus dem Keller entnommen werden kann. Es können ma-
ximal max Elemente im Keller abgelegt werden.
Für die Benutzung des Kellers seien folgende Synchronisationsbedingungen ge-
geben:

• Die Methoden füge ein und entnimm sind wechselseitig ausgeschlossen

Semaphor,
Synchroni-
sation,
Prozesszu-
standsgraph

auszuführen.

• Die Methode füge ein darf nur ausgeführt werden, wenn der Keller nicht
voll ist, d. h. wenn die Anzahl der Elemente im Keller kleiner max ist.
• Die Methode entnimm darf nur ansgeführt werden, wenn der Keller nicht

leer ist, d. h. wenn die Anzahl der Elemente im Keller größer 0 ist.

3.1. Implementieren Sie die Klasse Keller so, dass die oben genannten Synchro-

nisationsbedingungen durchgesetzt werden. Verwenden Sie zur Durchset-
zung der Synchronisationsbedingungen ausschließlich Semaphore (gegeben
durch die Klasse Semaphor). Achten Sie dabei auf die korrekte Initialisie-
rung der verwendeten Semaphore.
Sie dürfen für Ihre Lösung folgende zwei Klassen als gegeben voraussetzen:
public class Semaphor
// Konstruktor
public Semaphor(int init) ...
// Methoden
public void prolog 0 ...
public void epilog 0 ...
}
public class Element
// Konstruktor
public Element (...) ...
// Methoden
...
}

3.2. Nennen Sie die Eigenschaften eines Semaphors und erklären Sie seine

Funktionsweise.

3.3. Prozesse, die einen wie oben beschriebenen Puﬀer nutzen, können im Ver-
lauf ihrer Lebenszeit unterschiedliche Zustände annehmen. Zeichnen Sie ei-
nen allgemeinen Prozesszustandsgraphen und markieren Sie die möglichen
übergänge aus Teilaufgabe 3.1. in diesem Graph.

(Eine komplette Lösung zu diesen Aufgaben ﬁndet sich in [REP].)

(cid:28)

------------------------------------------------------------------------
232

4 Betriebssysteme

Aufgabe 4

Speicher-
verwaltung,
First Fit,
Best Fit,
SSF, SCAN

4.1. Beschreiben Sie die beiden Speicherverwaltungsstrategien First Fit und

Best Fit und nennen Sie jeweils deren Vor- und Nachteile.

4.2. Beschreiben und bewerten Sie die beiden Plattenzugriﬀsstrategien SSF

(shortest seek time ﬁrst) und SCAN (Aufzugsstrategie). Welches Gütekri-
terium für Festplatten wird heutzutage meist angegeben und wie beurtei-
len Sie es?

(Eine komplette Lösung zu diesen Aufgaben ﬁndet sich in [REP].)

Frühjahr 02 - Thema 1

Aufgabe 6

Seiten-
adressie-
rung,
Seiten-
größe,
interne
Fragmen-
tierung,
Seitenta-
belle

Gegeben sei ein System mit Seitenadressierung. Die Seitengröße betrage p.
1. Nennen Sie Gründe, die für eine Wahl eines kleinen bzw. großen Wertes für

die Seitengröße p sprechen.

2. Was versteht man im Fall von Seitenadressierung unter interner Fragmen-

tierung?

3. Welche Information muss in der Seitentabelle unabhängig von der gewähl-

ten Seitenverdrängungsstrategie mindestens enthalten sein?

4. Es sei e die Größe eines Seitentabelleneintrags und s die durchschnittliche
Größe eines im Hauptspeicher gehaltenen Programms. Bei welchem Wert
für die Seitengröße p wird die Summe aus interner Fragmentierung und
Größe der Seitentabelle minimal?

5. Welcher Wert ergibt sich nach Teilaufgabe 4. für die optimale Seitengröße p

bei s = 32KByte und e = 8Byte?

(s. hierzu auch [TAN])

1. Für eine kleinere Seitengröße spricht, dass die einzelnen Seiten besser ausge-
nutzt werden (können) und somit weniger Speicherplatz verschwendet wird.
Außerdem benötigen Programme Daten meist nur phasenweise; es reichen
also kleinere Seiten um abwechselnd die benötigten Daten in den Speicher
zu laden.
Kleinere Seiten bedeuten allerdings größere Seitentabellen.
Die Zeitdauer um eine Seite aus dem Hauptspeicher zu laden, ist aber un-
abhängig von der Größe dieser Seite.

2. Interne Fragmentierung bezeichnet den Verschnitt im Speicherplatz, der ent-

steht, wenn die Seiten nicht vollständig ausgenutzt werden.

(cid:27)
(cid:27)

------------------------------------------------------------------------
Frühjahr 02 - Thema 2

233

3. Es muss auf jeden Fall die zugehörige physikalische Adresse enthalten sein.

4. Durchschnittlich bleibt die Hälfte der Seiten ungenutzt, d. h. die interne

Fragmentierung beträgt p
2 .
Der Speicherverbrauch ist also insgesamt V = s·e
Das Minimum des Verbrauchs ﬁndet sich dort, wo die 1. Ableitung gleich
null ist:
−s·e
p2 + 1
Löst man dies nun nach p auf, erhält man: p =

p + p
2 .

2 · s · e

!
= 0

√

2

√
p

5. p =
=

2 · s · e =
219Byte2 = 29 ·

√

√

2 · 32KByte · 8Byte =

21 · 25 · 210 · 23Byte2 =

2Byte ≈ 0, 7KByte

p

Aufgabe 7

Geben Sie die vier Voraussetzungen für die Entstehung eines Deadlocks an sowie
wie diese verletzt werden können, um Deadlocks zu vermeiden!

Deadlock

(siehe Herbst 01 Thema 1 Aufgabe 2.2 auf Seite 230)

x

Frühjahr 02 - Thema 2

Aufgabe 1

a) Erläutem Sie anhand einer Skizze die Bildung der physikalischen Adresse
bei Seitenadressierung. Welche Vorteile verspricht man sich von ihrer Be-
nutzung? Welche Nachteile bringt ihr Einsatz mit sich?

b) In den Einträgen der Seiten-Kachel-Tabelle werden meist noch Indikato-

ren mitgeführt, die anzeigen, ob

1. die Seite im Arbeitsspeicher anwesend ist (Anwesenheits-Bit),
2. die Seite im Arbeitsspeicher angesprochen wurde (Benutzt-Bit),
3. die Seite im Arbeitsspeicher modiﬁziert wurde (Modiﬁkations-Bit).
Wozu werden diese Informationen bei ’Nachladen auf Verlangen (demand
paging)’ vom Betriebssystem benutzt?

Seiten-
adressie-
rung,
physikali-
sche
Adresse,
Seiten-Ka-
chel-Tabel-
le, demand
paging

a) (siehe Frühjahr 07 Thema 2 Aufgaben 3a) und 3d) auf Seite 307)

x

Meist ﬁndet nicht das ganze Programm Platz im Hauptspeicher, sondern
es werden nur die gerade benötigten Teile geladen. Dadurch, dass Haupt-
und Hintergrundspeicher in gleich große Kacheln bzw. Seiten aufgeteilt sind,
können die Programme stückweise geladen werden.


------------------------------------------------------------------------
234

4 Betriebssysteme

b) Wenn die Seite anwesend ist, muss sie nicht nachgeladen werden. Ist die
Seite allerdings abwesend, so kommt es zu einem Seitenfehler (page fault).
Unter Berücksichtigung der Seitenersetzungsstrategie wird eine andere Seite
ausgewählt, diese aus dem Speicher verdrängt und die gewünschte Seite aus
dem Hauptspeicher nachgeladen. Bei der Auswahl der zu ersetzenden Seiten
verwenden viele Strategien das Benutzt-Bit, d. h. es werden bevorzugt Seite
ersetzt, die seit längerem nicht mehr genutzt werden. Wenn eine Seite aus
dem Speicher verdrängt wird, kommt das Modiﬁkations-Bit zum Tragen. Bei
gesetztem Modiﬁkations-Bit kann die Seite nicht einfach gelöscht werden,
sondern muss in den Hauptspeicher zurückgeschrieben werden.

Aufgabe 2

binärer
Suchbaum,
demand
paging

a) Entwickeln Sie (für Einbenutzerbetrieb) eine Datenstruktur zur Speiche-
rung eines Telefonverzeichnisses, wobei die Einträge Name, Vorname und
Telefonnummer enthalten sein sollen! Die Datenstruktur soll sowohl eine ef-
ﬁziente Vorgehensweise beim Einfügen neuer Einträge als auch bei der Su-
che nach Einträgen ermöglichen (Löschen braucht nicht vorgesehen zu wer-
den). Als Basis soll ein Betriebssystem mit ’Anforderung auf Verlangen
(Demand Paging)’ dienen. Die Frage des Ablegens der Datenstruktur in
einer Datei bzw. des Wiederladens können Sie unberücksichtigt lassen. Er-
läutern Sie anhand von Beispielen die Vorgehensweise beim Einfügen und
beim Suchen!

b) Entwickeln Sie eine nicht-rekursive Prozedur, die das Verzeichnis alphabe-

tisch sortiert ausgibt. Die Prozedur soll direkt auf der Datenstruktur arbei-
ten, d. h. ohne Verwendung der Such-Prozedur! Dabei können Sie unterstel-
len, dass eine Prozedur zum Drucken eines Eintrags bereits existiert.

Diese themenübergreifende Aufgabe wird von uns an der Stelle eingearbeitet, an
der sie in der Staatsexamensaufgabe aufgeführt ist.

a) Als Datenstruktur wird ein Binärbaum verwendet. Jeder Knoten speichert
einen Eintrag bestehend aus Name, Vorname und Telefonnummer. Dadurch
beträgt der Aufwand zum Einfügen und Suchen von Einträgen O(log(n)). Es
muss nie die ganze Datenstruktur im Speicher gehalten werden, es genügen
alle Vorgängerknoten bis zur Wurzel. Soll nun ein Element eingefügt wer-
den, wird die Wurzel in den Speicher geladen. Ausgehend von deren Werten
wird entweder der linke oder rechte Sohn geladen, dann dessen linker oder
rechter Sohn usw. bis die Stelle zum Einfügen gefunden ist. Dabei werden
maximal log(n) Knoten geladen. Ein Eintrag soll dabei genauso groß sein wie
eine Kachel und ideal wäre es, wenn m = log(n) wäre. Die Vorgehensweise
beim Suchen ist analog zum Einfügen. Hierbei kann es aber passieren, dass
schon nach weniger als log(n) Schritten abgebrochen wird, weil das Element
gefunden wurde.


------------------------------------------------------------------------
235

Frühjahr 02 - Thema 2

class Knoten {

private String name;
private String vorname;
private int tel;
private Knoten l, r;
}

}
class Baum {

Knoten wurzel = null;
void fuege ein (int tel, String n, String v, Knoten k) {

Knoten e = new Knoten(tel, n, v);
if(k==null) {
k =e;
} else {

while(k.getName() != e.getName()) {
if(k.getName() < e.getName()) {

if(k.getL() == null) {

k.setL(e);

} else {

k = k.getL();

}
} else {

if(k.getR() == null) {

k.setR(e);

} else {

}

}

}

}

}

}

k = k.getR();

b) Wenn man die Telefonliste nach Namen aufsteigend sortiert ausgeben will,
so ist dies mit einem Inorder-Durchlauf möglich. Um die Rekursion zu ver-
meiden wird ein Stack verwendet.

public void inorder() {

Stack stack = new Stack();
Node n = root;
while (n != null || !stack.isEmpty()) {

if (n== null) {

n = (Node) stack.pop();
Ausgabe der Werte von n;
n = n.right;

}
if (n != null) {

stack.push(n);
n = n.left;

}

}

}


------------------------------------------------------------------------
236

4 Betriebssysteme

Herbst 02 - Thema 1

Aufgabe 2

Seitenerset-
zungsstra-
tegien,
FIFO,
LRU, Sei-
tenfehler,
Beladys
Anomalie

1. Gegeben sei ein Prozess mit einem virtuellen Speicher von fünf Seiten, für
dessen Realisierung drei Seitenrahmen (F rame = {K1, K2, K3}) zur Verfü-
gung stehen. Geben Sie für die Strategien LRU (Least Recently Used)
und FIFO (First in First out) die Entwicklung der Kachelseitentabelle für
die Zugriﬀsreferenzkette ω = 123412512345 an!

2. Die Seitenrahmen seien zu Beginn leer. Markieren Sie jedes Auftreten von
Seitenfehlern und notieren Sie jeweils die Gesamtzahl der Seitenfehler!

3. Geben Sie für die Strategie FIFO (First in First out) auch die Belegung der
Kachelseitentabelle für vier Seitenrahmen (F rame = {K1, K2, K3, K4}) und
obiger Zugriﬀsreferenzkette ω an. Beschreiben Sie das auftretende Phäno-
men!

1. Die Lösungen zu den Teilaufgaben 1 und 2 sind in den folgenden Tabellen

zusammengefasst.

LRU:

Referenzierte
Seiten
1
2
3
4
1
2
5
1
2
3
4
5

Inhalt
K1
10
11
12
40
41
42
50
51
52
30
31
32

Inhalt
K2

Inhalt
K3

20
21
22
10
11
12
10
11
12
40
41

30
31
32
20
21
22
20
21
22
50

Summe der
Seitenfehler
1
2
3
4
5
6
7
7
7
8
9
10


------------------------------------------------------------------------
Herbst 02 - Thema 1

237

FIFO:

Referenzierte
Seiten
1
2
3
4
1
2
5
1
2
3
4
5

Inhalt
K1
10
11
12
40
41
42
50
51
52
53
54
55

Inhalt
K2

Inhalt
K3

20
21
22
10
11
12
13
14
30
31
32

30
31
32
20
21
22
23
24
40
41

Summe der
Seitenfehler
1
2
3
4
5
6
7
7
7
8
9
9

2. s. o.

3. FIFO mit 4 Kacheln:
Referenzierte
Seiten
1
2
3
4
1
2
5
1
2
3
4
5

Inhalt
K1
10
11
12
13
14
15
50
51
52
53
40
41

Inhalt
K2

Inhalt
K3

Inhalt
K4

20
21
22
23
24
25
10
11
12
13
50

30
31
32
33
34
35
20
21
22
23

40
41
42
43
44
45
30
31
32

Summe der
Seitenfehler
1
2
3
4
4
4
5
6
7
8
9
10

Hier wird ab dem sechsten Schritt in jedem Schritt genau die Seite ausgelagert, die
beim nächsten Zugriﬀ benötigt wird. Dadurch ergeben sich trotz erhöhter Kachel-
anzahl mehr Seitenfehler als vorher. Dieses Phänomen heißt Beladys Anomalie.

Aufgabe 3

Beschreiben und erklären Sie das UNIX-Dateisystem! Gehen Sie insbesondere
auf die Verwaltung der belegten und freien Datenblöcke ein!

UNIX-
Datei-
system


------------------------------------------------------------------------
238

4 Betriebssysteme

Im UNIX-Dateisystem werden außer regulären Dateien und Verzeichnissen auch
Daten wie symbolische Links, block- und zeichenorientierte Geräte sowie festste-
hende Programmverbindungen und Netzwerk-Kommunikationsendpunkte als Da-
teien verwaltet. Jede dieser Dateien hat die Attribute Name, Größe, letzter schrei-
bender und letzter lesender Zugriﬀ, das Datum der letzten Statusänderung, Ei-
gentümer, zugehörige Gruppe, Anzahl der Hardlinks, Zugriﬀsmodus und Dateityp,
Inode-Nummer sowie mehrere Verweise auf die Datenblöcke.
UNIX fasst grundsätzlich alle Partitionen und angeschlossenen Laufwerke zu einem
Dateibaum zusammen. Physikalisch bleiben die Daten natürlich auf den entspre-
chenden Partitionen bzw. Laufwerken, logisch wird aber aus all den verschiedenen
Partitionen ein einziger Dateibaum zusammengebaut. Das Prinzip ist dabei ganz
einfach das, dass die Partitionen ausgehend von der Wurzelpartition an einem
bestimmten Punkt des Dateisystems eingehängt werden.

Das Prinzip des UNIX-Dateisystems beruht auf den sogenannten I-Nodes. Die
I-Node-Liste stellt eine Art Inhaltsverzeichnis dar. Die einzelnen Elemente der
I-Node-Liste sind die Dateiköpfe, also die Orte wo Dateiattribute, Größe usw. ge-
speichert sind. Diese Dateiköpfe werden I-Nodes genannt. In einem I-Node werden
außer den oben erwähnten Dateiattributen (außer dem Dateinamen!) üblicherwei-
se zusätzlich angegeben: Adresse von Datenblock 0 ... Adresse von Datenblock
9, Adresse des ersten Indirektionsblocks, Adresse des Zweifach-Indirektionsblocks,
Adresse des Dreifach-Indirektionsblocks. Die Indirektionsblöcke verweisen hierbei
nicht direkt auf Dateiblöcke, sondern auf weitere I-Node-Listen bzw. Indirektions-
blöcke. Bestimmte grundlegende Informationen zum Dateisystem selbst (Größe in
Blöcken, Größe der Blöcke in Bytes, Zeiger auf ersten freien Datenblock, Zeiger
auf erste freie I-Node, verschiedene Statusbits) sind im sogenannten Superblock
enthalten.
Die Verzeichnisse enthalten nur die Zuordnungen Dateiname → Inode (Link), es
können auch mehrere Dateinamen auf den gleichen Inode verweisen, was mit soge-
nannten Hard-Links (Verweisen von einer Datei auf eine andere) zwischen Dateien
des gleichen Filesystems realisiert wird. Wenn eine Datei erzeugt wird, erhält sie


------------------------------------------------------------------------
Herbst 02 - Thema 1

239

einen Link Counter mit dem Wert eins. Werden Links hinzugefügt, wird er erhöht;
wird ein Link gelöscht, wird dieser Counter verringert. Der Link Counter in der
Inode ist insbesondere für Hard-Links von Bedeutung. Er hält die aktuelle Anzahl
der Links an das Objekt fest. Es können Links beliebig erzeugt und gelöscht wer-
den, ohne dass das Objekt selbst gelöscht wird. Erst mit dem Löschen der letzten
Namensbindung wird der Link Counter auf Null gesetzt, was zur Freisetzung der
Inode und damit bei Dateien zur Freisetzung der Datenblöcke führt, womit das
Objekt endgültig gelöscht wird.
Eine andere Möglichkeit des Zugriﬀs auf eine bestimmte Datei von mehreren Stel-
len aus stellen die symbolischen Links dar. Bei ihnen handelt es sich tatsächlich
um Verweise auf eine bestehende Datei, d. h., der symbolische Link ist in Wahr-
heit eine Datei, die nur den Dateinamen einer anderen Datei enthält. Das System
kann bei dieser Art des Links im Gegensatz zum Hardlink immer zwischen Orginal
und Link unterscheiden. Symbolische Links erlauben es auch, Verweise über die
Partitionsgrenzen hinweg zu erstellen. Allerdings ist hier nicht sichergestellt, dass
der Link auch auf etwas zeigt, was existiert. Wird z. B. ein symbolischer Link auf
eine Datei angelegt und anschließend diese Datei gelöscht, so zeigt der Link ins
Leere.

Aufgabe 4

1. Was ist ein Prozess?
2. Prozesse können im Verlauf ihrer Lebenszeit unterschiedliche Zustände an-
nehmen. Zeichnen Sie einen allgemeinen Prozesszustandsgraphen und mar-
kieren Sie die übergänge, die vom Dispatcher realisiert werden.

3. Welche Hilfsmittel und Datenstrukturen benötigt man für die Realisierung

und Verwaltung von Prozessen?

Prozessver-
waltung,
Prozesszu-
standsgraph

1. Deﬁnition nach [DUD] :

Ein Prozess ist der Vorgang einer algorithmisch ablaufenden Datenbearbei-
tung. Speziell in Betriebssystemen ist ein Prozess ein Vorgang, der durch
ein Programm kontrolliert wird, welches zur Ausführung einen Prozessor
benötigt. Es kann mehrere Prozesse zu einem Programm geben, die je nach
Anwendung auch gleichzeitig oder nebenläuﬁg ablaufen. Ein Prozessor kann
immer nur einen Prozess gleichzeitig verarbeiten. Daher wurde die Möglich-
keit geschaﬀen, Prozesse nur teilweise auszuführen, zu unterbrechen, und
später wieder aufzusetzen und fortzuführen, was im Prozessmodell beschrie-
ben wird.

(cid:28)

------------------------------------------------------------------------
240

2.

4 Betriebssysteme

1. Prozess blockiert z. B. wegen Ein-
gabe
2. Scheduler wählt anderen Prozess
3. Scheduler bzw. Dispatcher wählt die-
sen Prozess
4. Eingabe vorhanden, Blockade auf-
gehoben

y

y

Zu diesem Thema siehe auch Herbst 06 - Thema 2 - Aufgabe 2.2!

3. Ein Prozess, der im Prinzip ein in Ausführung beﬁndliches Programm dar-
stellt, benötigt zusätzlich einen zugeordneten Adressraum. Dieser enthält
außer dem in Ausführung beﬁndlichen Programm, die Programmdaten und
den zugehörigen Stack. Darüber hinaus sind noch der Programmzähler, der
Zeiger auf den Stack (Stapelzeiger) und andere Register sowie weitere Infor-
mationen, die zur Ausführung des Programms benötigt werden, vorhanden.
All diese Informationen sind in einer Liste von Speicherstellen, in denen der
Prozess lesen und schreiben darf, abgelegt.
Zu diesem Thema siehe auch Herbst 06 - Thema 2 - Aufgabe 2.1!

Herbst 02 - Thema 2

Aufgabe 7

Prozesszu-
stände,
Scheduling,
Dis-
patching,
swapping

1. Skizzieren Sie den Zustandsautomaten, der die 7 allgemein möglichen Zu-
stände eines Prozesses sowie die möglichen übergänge zwischen diesen Zu-
ständen enthält!

2. Welcher Zustandsübergang eines Prozesses wird beim Dispatching realisiert?
3. Erläutern Sie kurz den Unterschied zwischen Scheduling und Dispatching!

(1-2 Sätze)

4. Was versteht man unter Swapping, und in welchen Fällen tritt es auf?

(1-2 Sätze)

1.


------------------------------------------------------------------------
Herbst 02 - Thema 2

241

2. Beim Dispatching wird der übergang bereit → aktiv realisiert.
3. Scheduling ist die Entscheidungsﬁndung (meist mit längerfristiger Planung),
welchem Prozess/Thread eine Ressource zugeteilt wird. Der für diese Ent-
scheidungsﬁndung verantwortliche Teil des Betriebssystems heißt Scheduler.
Der Dispatcher ist nur dafür zuständig einen Prozess von der CPU zu ver-
drängen und den nächsten Prozess, den der Scheduler bestimmt hat, zu laden.
4. Jeder Prozess wird komplett in den Hauptspeicher geladen bzw. auf die Fest-
platte ausgelagert. Swapping wird z. B. dann angewendet, wenn sich keine
bereiten Prozesse mehr im Speicher beﬁnden oder der Speicher aus anderen
Gründen voll ist, aber ein weiterer Prozess geladen werden soll.

Aufgabe 8

In dieser Aufgabe sei für die Speicherverwaltung einfache Segmentierung vorge-
sehen. Für jedes Segment eines Prozesses muss ein Eintrag in der Segmenttabelle
des Prozesses existieren. Adressen (logische und physische) haben eine Länge
von 16 Bit, von denen 5 Bit für die Segmentnummer reserviert sind.
1. Welche Informationen über die Segmente müssen in der Segmenttabelle ent-

halten sein?

2. Zeigen Sie (mit Hilfe einer Zeichnung) die Abbildung einer logischen auf ei-

ne physische Maschinenadresse!

3. Welche Art der Fragmentierung tritt bei der hier angenommenen einfachen
Segmentierung auf? Beschreiben Sie zusätzlich kurz (jeweils 1 Satz) die Ih-
nen bekannten Fragmentierungsarten!

4. Was ist bei den oben angenommenen Werten der Maximalwert für die Seg-

mentgröße?

5. Welche überprüfungen kann man vornehmen, um festzustellen, ob es sich
bei einer gegebenen logischen Adresse um eine gültige Adresse handelt?

Speicher-
verwaltung,
Segmentie-
rung,
Fragmen-
tierung,
logi-
sche/physi-
kalische
Adresse

1. Es muss die Segmentstartadresse und die Segmentlänge gespeichert werden.


------------------------------------------------------------------------
242

2.

4 Betriebssysteme

3. Bei der Verwendung von Paging tritt die interne Fragmentierung auf. Durch
die Vorgabe von festen Seitengrößen entsteht relativ viel Verschnitt; die-
ser wird als interne Fragmentierung bezeichnet. Bei der Segmentierung ent-
spricht die Segmentgröße genau dem benötigten Speicherbedarf. Wird ein
Segment aus dem Speicher entfernt und statt dessen ein anderes geladen,
so hat dies i. A. nicht die gleiche Größe. Es entsteht also eine Lücke zum
nächsten Segment. Nach und nach entstehen immer mehr Löcher zwischen
den Segmenten; dies wird als externe Segmentierung bezeichnet. (s. [TAN])

4. Die Länge eines Segments beträgt maximal

16 Bit (Länge logische Adresse) - 5 Bit (Länge Segmentnummer) = 11 Bit.

5. Es muss überprüft werden, ob der Rest der logischen Adresse, der zur Start-
adresse hinzu addiert wird, größer ist als die Länge des Segments. Falls dies
der Fall ist, wird der Speicherzugriﬀ nicht ausgeführt, da er ins nächste Seg-
ment führen würde (siehe auch obige Skizze).

Aufgabe 9

Prozessko-
ordination,
Semaphor,
Monitor,
Unterbre-
chungsver-
meidung,
wechselsei-
tiger
Ausschluss

1. Erklären Sie, wie ein allgemeiner Semaphor, S (Zählsemaphor) mit Hilfe
von binären Semaphoren und gewöhnlichen Variablen realisiert werden
kann!

2. Nennen und erklären Sie (1-2 Sätze) die Vorteile, die die Verwendung von

Monitoren gegenüber der Verwendung von Semaphoren bietet!

3. Wieso löst das Konzept der Unterbrechungsvermeidung das Problem des
wechselseitigen Ausschlusses nur bei Einprozessorsystemen (1-2 Sätze)?

(cid:27)

------------------------------------------------------------------------
Herbst 02 - Thema 2

243

1. Mit Hilfe der binären Semaphore muss der exklusive Zugriﬀ auf eine gewöhn-

liche Integer-Variable sichergestellt werden. D. h. die Operationen
erhoehen() und reduzieren() müssen durch binäre Semaphore geschützt
sein. Innerhalb der Methode erhoehen() muss überprüft werden, ob die Va-
riable die maximale Größe überschreiten würde. In diesem Fall muss durch
binäre Semaphore dafür gesorgt werden, dass der entsprechende Prozess
nicht weiterarbeiten kann, bis diese Methode erfolgreich ausgeführt wurde.
Beim reduzieren() muss darauf geachtet werden, dass der Wert der Varia-
blen nicht negativ wird. Auch hier muss der Prozess bis zum erfolgreichen
Durchlaufen der Methode gestoppt werden.

2. (siehe [TAN])

Mit Monitoren werden Deadlocks und Race Conditions verhindert. Dadurch,
dass immer nur ein Prozess innerhalb eines Monitors aktiv sein kann, kann
der Programmierer keine Deadlocks durch sich gegenseitig blockierende Se-
maphore entwerfen. Außerdem wird durch die Verwendung der Zustandsva-
riablen wait und signal verhindert, dass schlafende Prozesse nicht mehr
aufgeweckt werden bzw. Prozesse sich gegenseitig blockieren.

Beispiel für Monitoring:
Monitor belegen

Drucker frei?
falls nein:

Monitor freigeben
warten
Monitor belegen

falls ja:

drucken

Monitor enter

Drucker freigeben
signalisieren

Monitor leave

Beﬁndet sich ein Prozess (hier rechts dargestellt) innerhalb eines Monitors
und belegt ein Betriebsmittel (hier einen Drucker) und ein zweiter Prozess
(hier links dargestellt) belegt den Monitor um das selbe Betriebsmittel zu
belegen, so gibt der zweite Prozess den Monitor sofort wieder frei, wartet
aber auf die Freigabe des Druckers. (Monitor freigeben, warten) muss hier-
bei atomar sein! Ist jetzt der Druckauftrag des ersten Prozesses beendet, so
gibt dieser den Drucker frei und signalisiert dies allen wartenden Prozessen.
Anschließend verlässt er den Monitor, einer der wartenden Prozesse kann
den Montor belegen und den Drucker nutzen.

3. Durch das Prinzip der Unterbrechungsvermeidung wird verhindert, dass meh-
rere Prozesse abwechselnd auf die gleichen Variablen und Speicherbereiche
zugreifen. Erst wenn ein Prozess abgearbeitet ist, darf der nächste Prozess
an den Prozessor und damit aktiv auf Variablen zugreifen. Bei Mehrprozes-
sorsystemen kann nicht garantiert werden, dass parallel laufende Prozesse
im gleichen Speicherbereich arbeiten.

(cid:28)

------------------------------------------------------------------------
244

4 Betriebssysteme

Frühjahr 03 - Thema 1

Aufgabe 3

Betriebs-
mittel-
graph,
Deadlock

Was versteht man unter einer Verklemmung (Deadlock)? Erläutern Sie Ihre De-
ﬁnition anhand eines Beispiels eines Prozess-Betriebsmittelgraphen! Beschrei-
ben Sie mindestens eine Strategie zur Vermeidung von Verklemmungen!

(S. [DUD] Stichwort

Nebenläuﬁgkeit“)

”

Verklemmung: Ein Prozess ist im Besitz eines Betriebsmit-
tels A und benötigt im weiteren Verlauf das Betriebsmittel
B, welches jedoch im Moment im Besitz eines anderen Pro-
zesses ist. Der letztere Prozess benötigt seinerseits das Be-
triebsmittel A, um seine Verarbeitung fortsetzen zu können.
Ergebnis: Keiner der Prozesse kann weiterarbeiten.

Allgemein können an einer Verklemmung auch
mehr als zwei Prozesse beteiligt sein. In diesem
Fall muss ein Zyklus im Graph vorliegen, d. h.
jeder Prozess wartet in einem Ringschluss auf
das Betriebsmittel, das der nächste Prozess hält.
Ein Beipiel hierfür ist der Betriebsmittelgraph
des Philosophenproblems (s. links).

Eine einfache, jedoch nicht immer günstige Stra-
tegie zur Vermeidung von Verklemmungen erhält
man durch die Festlegung, dass Prozesse alle be-
nötigten Betriebsmittel nicht nacheinander im
Laufe ihrer Abarbeitung anfordern dürfen, son-
dern immer auf einmal im Voraus anfordern müs-
sen.

(cid:27)

------------------------------------------------------------------------
Frühjahr 03 - Thema 2

245

Frühjahr 03 - Thema 2

Aufgabe 5

Für die Kommunikation zwischen zwei Prozessen bzw. zwischen zwei Threads
wird häuﬁg ein Ringpuﬀer verwendet. Realisieren Sie einen derartigen Ringpuf-
fer in einer Ihnen geläuﬁgen Programmiersprache. Die Mehrbenutzersynchroni-
sation könnnen Sie wahlweise unter Nutzung von Semaphoren oder mittels des
Monitor-Konzepts (wie es in Java verwendet wird) realisieren. Zeigen Sie durch
entsprechende graphische Visualisierungen, wie Ihre Lösung bei gleichzeitigem
Zugriﬀ mehrerer Threads/Prozesse funktioniert. Gehen Sie insbesondere auf die
Erläuterung des kritischen Bereichs ein. Wie wird bei Ihrer Lösung der wechsel-
seitige Ausschluss garantiert? Ist Ihre Lösung verklemmungsfrei? Zeigen Sie an
einem Beispiel das Auftreten einer Verklemmung, wenn mehrere Prozesse über
mehrere Ringpuﬀer Daten austauschen. Geben Sie einige Lösungsideen an, die
Verklemmungen vermeiden.

Prozess,
Thread,
Ringpuﬀer,
Verklem-
mung,
Semaphor,
kritischer
Bereich,
wechselsei-
tiger
Ausschluss

public class Ringpuffer {

private int[] puffer // Inhalt, hier integer
private semaphor zugriff;
// binäre Semaphore
private semaphor nochFreiePlätze, belegtePlätze;
// Zähl-Semaphore
private int juengstes, aeltestes;

public Ringpuffer (int groesse) {

//Konstruktor
puffer = new int[groesse];
aeltestes = 0;
juengstes = groesse -1;
zugriff = 1;
nochFreiePlätze = groesse;
belegtePlätze = 0;

}

public void erzeugen(int x) {
nochFreiePlätze.down();
zugriff.down();
puffer[juengstes] = x;
juengstes = (juengstes + 1) % puffer.length;
zugriff.up();
belegtePlätze.Up();

}


------------------------------------------------------------------------
246

4 Betriebssysteme

public int verbrauchen() {

//es wird das Element zurückgegeben
belegtePlätze.down();
zugriff.down;
int x = puffer[aeltestes];
aeltestes = (aeltestes + 1) % puffer.length;
zugriff.up();
nochFreiePlätze.up();
return x;

}

}

Man kann hier einen Semaphor verwenden, den man mit Hilfe eines Vektors rea-





lisiert, der wie folgt vorbelegt wird (n ist die Größe des Ringpuﬀers):





1
n
0

Die erste Komponente steuert hierbei den wechselseitigen Ausschluss, die zweite
stellt einen Zähler für die noch freien Plätze dar, während die dritte für die beleg-
ten Plätze verantwortlich ist.
Durch Erzeuger können durch Addition folgender Vektoren die genannten ände-
rungen vorgenommen werden:




Erzeugeranmeldung:





Zugriﬀ auf Ringpuﬀer:




−
−1
−






−1
−
−


Freigabe Ringpuﬀer:



+1
−
+1







Verbraucheranmeldung:

Durch Verbraucher können durch Addition folgender Vektoren die genannten ände-
rungen vorgenommen werden:
−
−
−1

−1
−
−


Zugriﬀ auf Ringpuﬀer:












Freigabe Ringpuﬀer:



+1
+1
−



Der wechselseitige Ausschluss wird durch eine Zugriﬀssperre reguliert, die beim
Zugriﬀ auf den Ringpuﬀer durch Erzeuger bzw. Verbraucher gesetzt und bei der
Freigabe des Zugriﬀs wieder entfernt wird.


------------------------------------------------------------------------
Frühjahr 03 - Thema 2

247

Ausgangssituation

Erzeuger kommt an

Erzeuger meldet sich am
System an und greift so-
fort auf Ringpuﬀer zu,
da keine Sperren gesetzt
sind

Erzeuger löst Sperre für
Nachfolgende Erzeuger
und Verbraucher aus

zweiter Erzeuger kommt
an

zweiter Erzeuger meldet
sich am System an

zwei weitere Erzeuger
melden sich am System
an

Verbraucher kommt an,
kann sich aber wegen 0
belegter Plätze nicht an-
melden

weitere Erzeuger können
sich anmelden (so lan-
ge noch freie Plätze
existieren), Verbraucher
müssen warten

erster Erzeuger verlässt
das System, hebt die
Sperre auf

erster Erzeuger gibt Zu-
griﬀ frei und erhöht An-
zahl der belegten Plätze

erster Verbraucher mel-
det sich an, zweiter Er-
zeuger greift auf Ring-
puﬀer zu und setzt Sper-
re


------------------------------------------------------------------------
248

4 Betriebssysteme

zweiter
Erzeuger
verlässt System, hebt
Sperre auf

zweiter Erzeuger gibt
Zugriﬀ frei und erhöht
Anzahl
belegten
der
Plätze

zweiter
Verbraucher
meldet sich an, dritter
Erzeuger
auf
Ringpuﬀer zu und setzt
Sperre

greift

nach dem vierten greift
der fünfte Erzeuger auf
den Ringpuﬀer zu, die
Verbraucher (und even-
tuell weitere angekom-
mene Erzeuger bzw. Ver-
braucher) warten

erster Verbraucher greift
auf Ringpuﬀer zu, setzt
Sperre

Verbraucher
erster
verlässt System,
gibt
Zugriﬀ frei und erhöht
Anzahl der noch freien
Plätze

Kommen im Laufe der Zeit Erzeuger an, wenn der Wert der noch freien Plätze
0 beträgt, so müssen diese vor dem Einreihen in die Warteschlange warten bis
ein Verbraucher die Anzahl der freien Plätze wieder erhöht hat. Dieses System ist
verklemmungsfrei.

Wenn die Prozesse keinen Platz haben um ein Element zwischenzuspeichern, muss
ein Prozess, der von einem Ringpuﬀer Daten entnimmt, dort als Verbraucher fun-
gieren und am nächsten Ringpuﬀer als Erzeuger. Er muss also in dem Moment, in
dem er den Zugriﬀ auf Ringpuﬀer1 freigibt, sich bereits einen Platz im nächsten
Ringpuﬀer reservieren (nochFreiePlätze.down()). Falls er hier warten muss, weil
Ringpuﬀer2 voll ist, kann er die Methode des Verbrauchers nicht abschließen, also
die Anzahl der freien Plätze erhöhen. Wenn nun ein zweiter Prozess von Ring-
puﬀer2 (der voll ist) Daten entnehmen möchte und sie auf den ebenfalls vollen
Ringpuﬀer1 schreiben will, muss er hier warten, bis wieder ein Platz auf Ringpuf-
fer1 frei wird. Prozess1 wartet nun darauf, dass Prozess2 einen Platz in Ringpuﬀer2
freigibt und Prozess2 wartet auf den Platz, den Prozess1 auf Ringpuﬀer1 freigibt.


------------------------------------------------------------------------
Herbst 03 - Thema 1

249

Herbst 03 - Thema 1

Aufgabe 1

Für die Kommunikation zwischen verschiedenen Prozessen/Threads soll ein ge-
meinsamer Datenbereich dienen. Wir unterscheiden zwischen Lesern und Schrei-
bern. Es sollen beliebig viele Leser gleichzeitig lesen dürfen; aber ein Schreiber
benötigt exklusiven Zugriﬀ auf den Datenbereich. Es darf also weder ein Le-
ser noch ein anderer Schreiber gleichzeitig im kritischen Bereich sein. Realisie-
ren Sie dies mit Hilfe von Semaphoren. Zeigen Sie durch entsprechende gra-
phische Visualisierungen, wie Ihre Lösung bei gleichzeitigem Zugriﬀ mehrerer
Threads/Prozesse funktioniert! Gehen Sie insbesondere auf die Erläuterung des
kritischen Bereichs ein! Wie wird bei Ihrer Lösung der wechselseitige Ausschluss
garantiert? Ist Ihre Lösung verklemmungsfrei?

Prozessor,
Thread,
Semaphor,
kritischer
Bereich,
Verklem-
mung,
Leser-
Schreiber-
Problem

Man kann hier einen Semaphor verwenden, den man mit Hilfe eines Vektors rea-




lisiert, der wie folgt vorbelegt wird:





1
0
0

Die erste Komponente steuert hierbei den gegenseitigen Ausschluss von Schreibern,
die zweite stellt einen Zähler für Leser dar, während die dritte für die Anmeldung
der Schreiber verantwortlich ist.
Durch Leser können durch Addition folgender Vektoren die genannten änderun-
gen vorgenommen werden:



Betreten des Semaphors zum Lesen:



Verlassen des Semaphors:









−
−1
−





−
1
0


------------------------------------------------------------------------
250

4 Betriebssysteme

Schreiber ändern den Semaphorvektor durch die beschriebenen Aktionen mittels
folgender Vektoren:





−
−
1









−1
0
−

Anmeldung zum Schreiben:



Betreten des Semaphors zum Schreiben:



Verlassen des Semaphors:









1
−
−1

Der wechselseitige Ausschluss wird nun durch Schreib- bzw. Lesesperren reguliert,
die beim Betreten des Semaphors durch Leser bzw. Schreiber gesetzt und beim
Verlassen entfernt werden.

Ausgangssituation

Leser kommt an

Leser meldet sich am Sy-
stem an

Leser betritt Semaphor
für
und
Schreiber aus

Sperre

löst

zweiter Leser kommt an

zweiter Leser meldet sich
am System an

zweiter Leser betritt Se-
maphor, dritter Leser
kommt an

dritter Leser betritt Se-
maphor

erster Leser verlässt Se-
maphor


------------------------------------------------------------------------
Herbst 03 - Thema 1

251

erster Leser verlässt Sy-
stem,
erster Schreiber
kommt an

erster Schreiber meldet
sich an

Schreiber setzt Lesesper-
re

Schreiber wartet
auf
Aufhebung der Schreib-
sperre

nächster Leser kommt
an

Leser wartet auf Aufhe-
bung der Lesesperre

zweiter Schreiber meldet
sich am System an

zweiter Schreiber reiht
sich in Warteschlange
ein

zweiter Leser verlässt
Semaphor

dritter Leser verlässt Se-
maphor

Schreibsperre wird auf-
gehoben

Schreiber meldet sich an

Schreiber betritt Sema-
phor

Schreibsperre wird ge-
setzt

Schreiber verlässt Sem-
pahor,
Schreibsperre
wird aufgehoben


------------------------------------------------------------------------
252

4 Betriebssysteme

zweiter Schreiber betritt
Semaphor

Schreibsperre wird ge-
setzt

Schreiber verlässt Se-
maphor, Schreib- und
Lesesperre werden ent-
fernt, weil Schreiberwar-
teschlange leer

Nun kann der letzte Leser aus der Leserwarteschlange den Semaphor betreten
(dabei Schreibsperre setzen) und nach dem Lesevorgang wieder verlassen (dabei
Schreibsperre wieder aufheben).

Die oben dargestellte Lösung ist verklemmungsfrei, da ein wechselseitiges Warten
auf Freigabe des Semaphors nicht vorkommen kann.

Herbst 03 - Thema 2

Aufgabe 5

Folgende Prozesse sollen betrachtet werden (die Zeiten seien in beliebigen Zeit-
einheiten gegeben):

Prozess Ankunftszeit Laufzeit
0
1
2
3
4

A
B
C
D
E

3
2
1
2
3

Ein Prozess, der zum Zeitpunkt t eintritt, wird auch zum Zeitpunkt t in die
Warteschlange eingereiht. Kommen zwei Prozesse zur gleichen Zeit, so wird die
Ordnung auf den Prozessnamen (Alphabet) herangezogen. Wird ein Prozess
vor seinem Terminieren zum Zeitpunkt t0 unterbrochen, so reiht er sich in die
Warteschlange mit Ankunftszeit t0 wieder ein.

1. Erklären Sie zunächst den Unterschied zwischen preemptiven und

nicht-preemptiven Scheduling-Verfahren!

Scheduling,
Round-
Robin,
Shortest-
Job-First,
(nicht-)pre-
emptive
Scheduling-
verfahren,
Reaktions-
zeit


------------------------------------------------------------------------
Herbst 03 - Thema 2

253

2. Geben Sie für die Strategien Shortest Job First (SJF) und Round Robin

(RR) mit Quantum t = 1 jeweils in Form eines Diagramms für die ersten 11
Zeiteinheiten an, wann welchem Prozess Rechenzeit zugeteilt wird und wann
die Prozesse ggf. terminieren!

3. Die Reaktionszeit ri eines Prozesses pi sei deﬁniert als:

ri = erster Rechenzeitpunkt − Ankunf tszeitpunkt;

Geben Sie die mittlere Reaktionszeit der Strategien RR und SJF aus
Teilaufgabe a) an!

4. Wie muss die Größe des Quantums bei RR gewählt werden, damit sich diese

Strategie äquivalent zur FlFO-Strategie verhält?

5. Nennen Sie drei unabhängige Einﬂussgrößen, die man zur Festlegung der

Quantumslänge bei RR sinnvoll heranziehen kann!

1. Bei nicht-preemptiven Verfahren wird ein Prozess, sobald er einmal die CPU
zugeteilt bekommen hat, nicht mehr unterbrochen bis er terminiert. Bei pre-
emptiven Verfahren wird einem Prozess abhängig von einer Zeitdauer oder
einer Priorität die CPU entzogen und der Prozess unterbrochen, obwohl er
eigentlich noch bereit wäre.

2. SJF (es macht hier keinen Unterschied, ob preemptiv oder non-preemptiv):

Round Robin:

3. RSJF = (r1 + r2 + r3 + r4 + r5)/5 = ((0 − 0) + (4 − 1) + (3 − 2) + (6 − 3) +

(8 − 4))/5 = 11/5 = 2, 2
RRR = ((0 − 0) + (2 − 1) + (4 − 2) + (6 − 3) + (7 − 4))/5 = 9/5 = 1, 8

4. Die Zeitscheibe muss so groß sein, dass jeder Prozess innerhalb einer Zeit-

scheibe terminiert. In diesem Fall also 3.


------------------------------------------------------------------------
254

4 Betriebssysteme

5. Zeitdauer für Prozesswechsel

durchschnittliche Laufzeit der Prozesse → Vermeidung der FIFO-Anomalie
Reaktionszeit

Aufgabe 6

Seitenerset-
zungsstra-
tegien,
LIFO,
LRU, LFU,
swapping,
paging,
Seite,
Segment

Bei der Ausführung eines Speicherzugriﬀs bei der virtuellen Speicherverwaltung
kann es vorkommen, dass sich die referenzierte Seite nicht im Arbeitsspeicher
beﬁndet. Diese Situation wird Seitenfehler (page fault) genannt. Die Behand-
lung eines Seitenfehlers erfordert i. Allg. Maßnahmen zur Ersetzung einer Seite
im Arbeitsspeicher, d. h., um die gewünschte Seite in einen Seitenrahmen des
Arbeitsspeichers einlagern zu können, muss zunächst eine andere Seite vom Ar-
beitsspeicher auf den Hintergrundspeicher ausgelagert werden.
Die Menge der Seiten sei gegeben durch N = {0, 1, 2, 3, 4, 5} und die Menge
der Seitenrahmen, die für die Speicherung der Seiten im Arbeitsspeicher zur
Verfügung steht, sei gegeben durch F ramea = {f1, f2, f3, f4}. Auf die 6 Seiten
der Menge N werde in folgender Reihenfolge zugegriﬀen:

ω = 1 3 5 4 2 4 3 2 1 0 5 3 5 0
Arbeiten Sie mit den zur Verfügung stehenden Seitenrahmen der Menge F ramea
die Seitenzugriﬀsfolge ω gemäß den nachfolgenden Ersetzungsstrategien ab. Er-
stellen Sie hierzu jeweils eine Tabelle mit den hierfür angegebenen Spalten.

1. LIFO : Last in First out

Referenzierte
Seiten

Inhalt
f1

Inhalt
f2

Inhalt
f3

Inhalt
f4

Summe der
Seitenfehler

2. LRU : Least Recently used

Referenzierte
Seiten

Inhalt
f1

Inhalt
f2

Inhalt
f3

Inhalt
f4

Summe der
Seitenfehler

3. LFU : Least Frequently used

Referenzierte
Seiten

Inhalt
f1

Inhalt
f2

Inhalt
f3

Inhalt
f4

Summe der
Seitenfehler

4. Erklären Sie den Unterschied zwischen Swapping und Paging!
5. Erklären Sie den Unterschied zwischen Segmenten und Seiten (pages)!


------------------------------------------------------------------------
Herbst 03 - Thema 2

255

1. LIFO:

Referenzierte
Seiten
1
3
5
4
2
4
3
2
1
0
5
3
5
0
4

2. LRU:

Referenzierte
Seiten
1
3
5
4
2
4
3
2
1
0
5
3
5
0
4

Inhalt
f1
10
11
12
13
14
15
16
17
18
19
110
111
112
113
114

Inhalt
f1
10
11
12
13
20
21
22
20
21
22
23
30
31
32
33

Inhalt
f2

Inhalt
f3

Inhalt
f4

30
31
32
33
34
35
36
37
38
39
310
311
312
313

50
51
52
53
54
55
56
57
58
59
510
511
512

40
20
40
41
20
21
00
01
02
03
04
40

Inhalt
f2

Inhalt
f3

Inhalt
f4

30
31
32
33
34
30
31
32
33
50
51
50
51
52

50
51
52
53
54
55
10
11
12
13
14
15
40

40
41
40
41
42
43
00
01
02
03
00
01

Summe der
Seitenfehler
1
2
3
4
5
6
6
7
7
8
8
8
8
8
9

Summe der
Seitenfehler
1
2
3
4
5
5
5
5
6
7
8
9
9
9
10


------------------------------------------------------------------------
256

4 Betriebssysteme

3. LFU:

Referenzierte
Seiten
1
3
5
4
2
4
3
2
1
0
5
3
5
0
4

Inhalt
f1
10
10
10
10
20
20
20
21
21
21
21
21
21
00
00

Inhalt
f2

Inhalt
f3

Inhalt
f4

30
30
30
30
30
31
31
31
31
31
32
32
32
32

50
50
50
50
50
50
10
00
50
50
51
51
51

40
40
41
41
41
41
41
41
41
41
41
42

Summe der
Seitenfehler
1
2
3
4
5
5
5
5
6
7
8
8
8
9
9

4. Swapping = ganzer Prozess samt Prozesstabelle auslagern

Paging = nur einzelne Seiten auslagern.

5. Seiten haben eine feste Größe, Segmente eine variable Länge.

Bei Segmenten muss geprüft werden, ob bei der Adressumsetzung der Oﬀset
nicht die Segmentlänge überschreitet.

Aufgabe 7

Semaphor,
Konﬂikt,
Deadlock

Zwei Prozesse P1 und P2 seien wie folgt unter Verwendung von booleschen Se-
maphoren programmiert (WAIT entspricht UP und SIGNAL entspricht DOWN):
P1:

P2: REPEAT

REPEAT

(1)
(2)

<unkritischer Bereich>
WAIT(Platz)
WAIT(S)
<kritischer Bereich>
SIGNAL(S)
SIGNAL(Bestand)
<unkritischer Bereich>

<unkritischer Bereich>
WAIT(Bestand)
WAIT(S)
<kritischer Bereich>
SIGNAL(S)
SIGNAL(Platz)
<unkritischer Bereich>

UNTIL false

UNTIL false

Ein Vertauschen der Zeilen (1) und (2) von Prozess P1 könnte zu Konﬂikten
führen. Erklären Sie anhand einer Belegung der Semaphore S, Platz und Bestand
und einer Beschreibung eines zeitlichen Ablaufs der beiden Prozesse P1 und P2,
wie in diesem Fall ein Deadlock entstehen kann.


------------------------------------------------------------------------
Frühjahr 04 - Thema 1

257

Angenommen, P latz = 1, P1 könnte nun in den kritischen Bereich eintreten und
setzt S = 1. Im nächsten Schritt blockiert nun P1, da WAIT(Platz) nicht aus-
geführt werden kann. Um die Blockade von P1 zu lösen, müsste P2 P latz = 0
setzen. Dies ist aber erst nach dem kritischen Abschnitt möglich. Da sich aber
bereits P1 im kritischen Abschnitt beﬁndet, kann P2 diesen nicht durchlaufen und
hat keine Möglichkeit den Semaphor Platz zu verändern. Welchen Wert dabei der
Semaphor Bestand hat, ist irrelevant. Ist Bestand = 0 , blockiert P2 erst nach
WAIT(Bestand), andernfalls davor. Falls Bestand = 1, müsste P1 den Wert wie-
derum nach seinem kritischen Bereich ändern. Da P1 aber bereits blockiert ist,
kann dieser Fall nie eintreten.

Frühjahr 04 - Thema 1

Aufgabe 10

a) Was versteht man unter den Begriﬀen Programm und Prozess?
b) Was ist der Unterschied zwischen Benutzermodus und Kernel-Modus?
c) Mit Hilfe von Scheduling-Strategien wird in Betriebssystemen entschieden,
welcher der lauﬀähigen Prozesse den Prozessor zugeteilt bekommt. Be-
schreiben Sie die Ziele und die Vorgehensweise einer solchen Strategie in
einem heute typischen Mehrbenutzer-/Mehrprogramm-Betriebssystem wie
UNIX oder Linux!

a) (siehe Herbst 06 Thema 1 Aufgabe 2.2 auf Seite 291)

b) (siehe Frühjahr 07 Thema 1 Aufgabe 2 auf Seite 300)

ACID-
Prinzip,
Trans-
aktion

x

x

c) (siehe Frühjahr 07 Thema 2 Aufgabe 2b) auf Seite 306 und Herbst 07 Thema x

1 Aufgabe 3c) auf Seite 317)

Aufgabe 11

a) Was ist virtueller Speicher?
b) Skizzieren Sie den Ablauf der Umsetzung von einer virtuellen Adresse in

eine phys. Hauptspeicheradresse bei Seitenadressierung!

c) Wie wird ein Shared-Memory-Segment zwischen zwei Prozessen bereit-

gestellt?

d) Was ist Seitenﬂattern? Welche Ursachen führen dazu, wie kann man es be-

Speicher-
verwaltung,
Seitenﬂat-
tern,
Seiten-
adressie-
rung

heben?

a) (siehe [DUD] Stichwort

Speicherverwaltung“)

”

(cid:28)

------------------------------------------------------------------------
258

4 Betriebssysteme

Im Allgemeinen ﬁnden nicht das gesamte Programm und alle benötigten Da-
ten im schnellsten Speicher Platz, sondern nur ein kleiner, gerade benötigter
Teil. Puﬀerspeicher und Hintergrundspeicher sind in gleich große Speicherbe-
reiche aufgeteilt. Bei einem virtuellen Speicher adressiert der Benutzer direkt
den Hintergrundspeicher, der Prozessor adressiert jedoch nur den Puﬀerspei-
cher.

y

b) (siehe Frühjahr 07 Thema 2 Aufgabe 3a) auf Seite 307)

c) Shared Memory (dt.

geteilter Speicher“) bezeichnet eine bestimmte Art der
”
Kommunikation zwischen zwei Prozessen. Bei dieser Art der Kommunika-
tion nutzen zwei oder mehrere Prozesse einen bestimmten Teil des Hinter-
grundspeichers (RAM) gemeinsam. Für alle beteiligten Prozesse liegt dieser
gemeinsam genutzte Speicherbereich in deren Adressraum und kann mit nor-
malen Speicherzugriﬀsoperationen ausgelesen und verändert werden. Meist
wird dies über Pagingmechanismen realisiert, indem beide Prozesse gleiche
Seitendeskriptoren verwenden, wodurch die gleiche Speicherseite (Kachel) im
Hintergrundspeicher verwendet wird. Die Seitenkacheltabelle dieser beiden
Prozesse verweist also teilweise auf die gleichen Kacheln.

y

d) (siehe Frühjahr 07 Thema 1 Aufgabe 1c) auf Seite 298)

Herbst 04 - Thema 1

Aufgabe 3

Thread,
Adress-
raum,
Erzeuger-
Verbrau-
cher-
Problem

1. Besitzt jeder Thread einen eigenen Kellerspeicher? Erläutern Sie Ihre

Antwort.

2. Besitzt jeder Thread einen eigenen Adressraum? Erläutern Sie Ihre Antwort.
3. Erläutern Sie die Realisierung von Threads im Benutzer-Adressraum.
4. Erläutern Sie die Realisierung von Threads im System-Adressraum.
5. Threads in Java:

Im Folgenden soll der Betrieb eines Parkhauses teilweise simuliert werden.
Ein Objekt der Klasse Parkhaus repräsentiert das Parkhaus. Jedes Fahr-
zeug wird als eigener Thread simuliert.

Folgende Klassen seien gegeben:
public class ParkhausTest {

public static void main (String [] args) {

Parkhaus p = new Parkhaus (50);
/* Hier 100 Threads mit Hilfe der Klasse Fahrzeug und des
Objekts p erzeugen und starten (siehe Teilaufgabe a) */

}}


------------------------------------------------------------------------
259

Herbst 04 - Thema 1

public class Parkhaus {

private int kapazitaet;
private int anzFahrzeuge;
public Parkhaus (int kapazitaet) {

// Kapazitaet des Parkhauses
// Anzahl der parkenden Fahrzeuge

this.kapazitaet = kapazitaet;
anzFahrzeuge = 0 ;}

// Einfahrt (Methode noch zu ergaenzen, siehe Teilaufgabe b)
public void einfahrt() {

anzFahrzeuge++;}

// Ausfahrt (Methode noch zu ergaenzen, siehe Teilaufgabe b)
public void ausfahrt() {

anzFahrzeuge--;}

}}
public class Fahrzeug implements Runnable {

private Parkhaus p;
public Fahrzeug(Parkhaus p){
this.p = p;}

public void run() {

In Parkhaus einfahren
p.einfahrt();
//Aufenthalt
try {

Thread.sleep((int)(Math.random()*10000));

} catch (InterruptedException e) {}
// Aus Parkhaus ausfahren
p.einfahrt();

}}

a) Ergänzen Sie die Klasse ParkhausTest so, dass mit Hilfe der Klasse Fahr-
zeug und des Objekts p einhundert Threads erzeugt und gestartet werden.

b) Ergänzen Sie die Methoden einfahrt() und ausfahrt() der Klasse Park-
haus so, dass der Zugriﬀ auf anzFahrzeuge unter wechselseitigem Aus-
schluss geschieht! Ferner soll folgendes Szenario simuliert werden: Wenn die
Kapazität des Parkhauses erschöpft ist, warten einfahrbereite Fahrzeuge in
einer Wartezone. Immer wenn ein Fahrzeug das Parkhaus verlassen hat, ver-
lässt ein beliebiges wartendes Fahrzeug die Wartezone.

1. Ja, jeder Thread benötigt für die Verwaltung von Rücksprungadressen bei
Funktionsaufrufen und seiner lokalen Variablen einen eigenen Kellerspeicher.

2. Nein, die Threads arbeiten auf dem Adressraum des zugehörigen Prozesses.
Nur dadurch kann erreicht werden, dass Threads gemeinsam eine Aufgabe
lösen.

3. Das Betriebssystem weiß nichts von der Existenz der Threads, jeder Pro-
zess verwaltet seine Threads und die zugehörigen Threadtabellen selbst. Die
Threads werden also auf Anwendungsprogramm-Ebene realisiert.


------------------------------------------------------------------------
260

4 Betriebssysteme

4. Hier werden die Threads vom Betriebssystem realisiert. D. h. das Betriebs-
system verwaltet die einzelnen Threads und die zugehörige Threadtabelle im
Kern. Es ist damit einfacher Threads zu blockieren, aber teurer Threads zu
erzeugen.

5.

a) public class ParkhausTest {

public static void main (String[ ] args) {
Parkhaus P = new Parkhaus (50) ;
Thread t[100] ;
for (int i = 0; i ≤ 99; i++) {

t[i] = new Thread(Fahrzeug(p));
t[i].start();

}

}

}

b) public class Parkhaus {

private int kapazitaet;

//Kapazitaet des Parkhauses

private int anzFahrzeuge;

//Anzahl der parkenden Fahrzeuge

private int fahrzeuge;

//Boolescher Semaphor zum Zugriff
//auf anzFahrzeuge

private int frei;

//Semaphor, der die freien Plätze angibt

private int belegt;

//Semaphor, der die belegten Plätze angibt

public Parkhaus (int kapazitaet) {
this.kapazitaet = kapazitaet;
anzFahrzeuge = 0 ;

}

// Einfahrt
public void einfahrt() {

frei.down();
fahrzeuge.down();
anzFahrzeuge++;
fahrzeuge.up();
belegt.up();

}
// Ausfahrt
public void ausfahrt() {
belegt.down();
fahrzeuge.down();
anzFahrzeuge−−;
fahrzeuge.up();
frei.up(); }

}


------------------------------------------------------------------------
Herbst 04 - Thema 1

261

Es handelt sich hierbei um ein klassisches Erzeuger-Verbraucher-Pro-
blem.

Aufgabe 4

Semaphor

Vor dem Zugang zu den Flugsteigen eines Flugplatzes ﬁndet in einer Sicherheits-
zone eine Sicherheitsüberprüfung der Passagiere statt. In der Sicherheitszone
dürfen sich immer nur maximal 10 Passagiere aufhalten. Die Sicherheitszone
enthält einen Kontrollbereich mit einem Gepäckkontrolleur und einem Perso-
nenkontrolleur. Um jedes Gepäckstück eindeutig einem Passagier zuordnen zu
können, ist im Kontrollbereich nur maximal ein Passagier erlaubt. Der Gepäck-
kontrolleur darf erst dann mit seiner Kontrolle beginnen, wenn ein Passagier den
Kontrollbereich betreten hat. Erst nachdem der Gepäckkontrolleur dem Passa-
gier das Gepäckstück abgenommen hat, darf der Personenkontrolleur mit der
Kontrolle beginnen. Der Gepäckkontrolleur darf dem Passagier das Gepäckstück
erst dann wieder zurückgeben, wenn der Personenkontrolleur seine Kontrolle
beendet hat. Nur wenn eine komplette Kontrolle (Person und Gepäck) durch-
geführt wurde, darf der Passagier den Kontrollbereich verlassen.
Folgende Prozesse seien deﬁniert:
Passagier {

<betritt Sicherheitszone>
<betritt Kontrollbereich>
<verlässt Kontrollbereich>
<verlässt Sicherheitszone>}

Gepäckkontrolleur {

<nimmt Passagier Gepäckstück ab>
<kontrolliert Gepäckstück>
<gibt Passagier Gepäckstück zurück>}

Personenkontrolleur {

<kontrolliert Person>}

Stellen Sie mit Hilfe von Semaphoren den oben skizzierten Ablauf sicher. Geben
Sie zu jedem Semaphor einen kurzen aussagekräftigen Kommentar an. Geben
Sie auch zu jedem Semaphor die Art (boolesch oder ganzzahlig) so wie die
Anfangsbelegung an.

VAR sicherheit = 9 // (0,..9) Plätze in der Sicherheitszone

kontrolle = 1 //Sperre des Kontrollbereichs (boolesch)
gepaeck = 0 //Sperre des Gepäckkontrolleurs (boolesch)
gepaeckFertig = 0 //Gepäckkontrolleur ist fertig (boolesch)
person = 0 //Sperre des Personenkontrolleurs (boolesch)
personFertig = 0 //Personenkontrolleur ist fertig (boolesch)

Passagier{

sicherheit.down();


------------------------------------------------------------------------
4 Betriebssysteme

262

}

<betritt Sicherheitszone>
kontrolle.down();
<betritt Kontrollbereich>
gepaeck.up();
gepaeckFertig.down();
<verlässt Kontrollbereich>
kontrolle.up();
<verlässt Sicherheitszone>
sicherheit.up();

Gepäckkontrolleur{

gepaeck.down();
<nimmt Passagier Gepäckstück ab>
person.up();
<kontrolliert Gepäckstück>
personFertig.down();
<gibt Passagier Gepäckstück zurück>
gepaeckFertig.up();

}

Personenkontrolleur{
person.down();
down(passagierkontrolle);
personFertig.up();

}

Herbst 04 - Thema 2

Aufgabe 6

Prozess,
Betriebs-
mittel,
Verklem-
mung

Zu einem Zeitpunkt t sei in einem System mit drei Prozessen [A, B, C] folgende
Betriebsmittel-Zuteilung gegeben:

A hält eine Instanz vom Ressource-Typ R1 und zwei Instanzen vom
Ressource-Typ R2
B hält eine Instanz vom Ressource-Typ R2 und eine Instanz vom
Ressource-Typ R3
C hält eine Instanz vom Ressource-Typ R2

Dabei existieren insgesamt im System:

Eine Instanz vom Ressource-Typ R1
Vier Instanzen vom Ressource-Typ R2
Zwei Instanzen vom Ressource-Typ R3


------------------------------------------------------------------------
Herbst 04 - Thema 2

263

Zu einem Zeitpunkt t sei in einem System mit drei Prozessen [A, B, C] folgende
Betriebsmittel-Zuteilung gegeben:
Folgende Anforderungen bestehen:

A benötigt eine Instanz von R2, um erfolgreich terminieren zu können.
B benötigt eine Instanz von R2, um erfolgreich terminieren zu können.
C benötigt eine Instanz von R3, um erfolgreich terminieren zu können.

a) Vervollständigen Sie den Betriebsmittel-Zuteilungsgraphen in folgendem

Schema:

b) Gibt es Prozesse, die blockiert (= verklemmt) sind? Wenn ja: welche Pro-

zesse sind dies und warum?

c) Was ändert sich am obigen Systemzustand bzgl. des Blockierens von Pro-

zessen, wenn zusätzlich zu den bestehenden Anforderungen gilt:
C benötigt eine Instanz vom Ressource-Typ R1, um erfolgreich terminieren
zu können?

a)

b) C kann seine Betriebsmittel zugeteilt bekommen, terminiert und der Graph

reduziert sich:

Jetzt warten sowohl A als auch B auf die letzte freie Instanz von R2. Bei
gleichzeitigem und gleichpriorem Zugriﬀ geht es hier nicht mehr weiter, da
sich die Prozesse (ansonsten) wegen der Betriebsmittelbelegung gegenseitig
blockieren.
Teilt das Betriebssystem einem der beiden die letzte Instanz von R2 zu, ist
die Blockade aufgelöst.

c) C kann nun nicht mehr terminieren, da sich C und A im Deadlock bezüglich
R1 beﬁnden. A müsste R1 freigeben, was aber nicht geht, da er selbst auf die


------------------------------------------------------------------------
264

4 Betriebssysteme

nicht verfügbare Instanz von R2 wartet, die u. a. C hält. Es liegt der Zyklus
C → R1 → A → R2 → C vor.

Aufgabe 7

terminie-
render
Prozess,
Betriebs-
mittel-Zu-
teilung,
Banker’s
Algorith-
mus

Zu einem Zeitpunkt t sei in einem System mit fünf Prozessen [A, B, C, D, E]
folgende Betriebsmittel-Zuteilung gegeben:

Prozess Farbdrucker

s/w-Drucker CD-Brenner Scanner

A
B
C
D
E

3
0
1
1
0

0
1
1
1
0

1
0
1
0
0

1
0
0
1
0

Nachfolgende Tabelle gibt an, wie viele Ressourcen die Prozesse noch benötigen,
um bis zur erfolgreichen Terminierung arbeiten zu können:

Prozess Farbdrucker

s/w-Drucker CD-Brenner Scanner

A
B
C
D
E

1
1
3
0
2

1
1
1
0
1

0
1
0
1
1

0
2
0
0
0

Von jedem Ressourcentyp sind insgesamt vorhanden:

Farbdrucker
6

s/w-Drucker CD-Brenner Scanner

3

4

2

1. Stellen Sie zunächst die für die beteiligten Prozesse benötigten Matrizen
Need (= momentaner Restbedarf), Max (= Maimalbedarf bei Betreten
des Systems) und Allocation (= momentane Belegung) und den Vektor
Available (= momentane Verfügbarkeit) auf. Prüfen Sie anschließend (z.
B. mit dem Banker’s Algorithmus), ob das System in einem sicheren Zu-
stand ist (d. h. es existiert eine Reihenfolge, in der alle Prozesse terminie-
ren können). Falls der Zustand sicher ist, reicht die Auﬂistung einer mögli-
chen Terminierungsreihenfolge mit der jeweiligen Angabe des aus einer Ter-
minierung resultierenden Available Vektors. Falls der Zustand nicht sicher
ist, geben Sie einen Systemzustand an, in dem Prozesse nicht mehr erfolg-
reich terminieren können.

2. Ausgehend von obiger Situation benötige Prozess E statt einem nun zwei

CD-Brenner. Kann diese Anforderung erfüllt werden?

3. Erläutern Sie knapp, warum der Lösungsansatz aus a) in real existieren-

den Systemen schwierig umzusetzen ist!


------------------------------------------------------------------------
Herbst 04 - Thema 2

1. need =















1 1 0 0
1 1 1 2
3 1 0 0
0 0 1 0
2 1 1 0

(cid:0)

(cid:1)

max =















4 1 1 1
1 2 1 2
4 2 1 0
1 1 1 1
2 1 1 0

available =

1 0 2 0

265















3 0 1 1
0 1 0 0
1 1 1 0
1 1 0 1
0 0 0 0

allocation =



Prozess D kann als erster (und einziger) bedient werden. Dann stellt sich die
Situation so dar:

1 1 0 0
1 1 1 2
3 1 0 0
0 0 0 0
2 1 1 0

3 0 1 1
0 1 0 0
1 1 1 0
0 0 0 0
0 0 0 0

allocation =

available =

2 1 2 1

need =

























(cid:0)

(cid:1)

Nun können Prozess A und E bedient werden. Nach Bedienung von E ändert
sich an der Available-Tabelle nichts, da E momentan nichts belegt hält. Nach
anschließender Bedienung von A stellt sich die Situation so dar:









need =











allocation =











(cid:0)

(cid:1)

available =

5 1 3 2

Nun kann Prozess B oder C bedient werden. Nach Bedienung von B stellt
sich anschließend die Situation so dar:








need =











allocation =











(cid:0)

(cid:1)

available =

5 2 3 2

0 0 0 0
0 1 0 0
1 1 1 0
0 0 0 0
0 0 0 0

0 0 0 0
0 0 0 0
1 1 1 0
0 0 0 0
0 0 0 0

0 0 0 0
1 1 1 2
3 1 0 0
0 0 0 0
0 0 0 0

0 0 0 0
0 0 0 0
3 1 0 0
0 0 0 0
0 0 0 0

Abschließend kann nun Prozess C bedient werden. Das System beﬁndet sich
also in einem sicheren Zustand.

2. Die Ausgangssituation stellt sich wie folgt dar:









need =






1 1 0 0
1 1 1 2
3 1 0 0
0 0 1 0
2 1 2 0

(cid:0)






max =






(cid:1)

4 1 1 1
1 2 1 2
4 2 1 0
1 1 1 1
2 1 2 0






allocation =















3 0 1 1
0 1 0 0
1 1 1 0
1 1 0 1
0 0 0 0

available =

1 0 2 0

Auch hier kann wiederum nur Prozess D als erster bedient werden. Dann
stellt sich die Situation so dar:


------------------------------------------------------------------------
266

4 Betriebssysteme

need =















1 1 0 0
1 1 1 2
3 1 0 0
0 0 0 0
2 1 2 0

allocation =















3 0 1 1
0 1 0 0
1 1 1 0
0 0 0 0
0 0 0 0

(cid:0)

(cid:1)

available =

2 1 2 1

Es bleibt also dabei, dass als nächstes die Prozesse A oder E bedient werden
können, der weitere Ablauf sieht genauso aus wie bei Teilaufgabe a), der
Systemzustand ist wiederum sicher.

3. In real existierenden Systemen können folgende Schwierigkeiten das System

zum Scheitern verurteilen:

i. ein Prozess weiß nicht von vorne herein, welche Betriebsmittel er benöti-

gen wird

ii. es kommen laufend neue Prozesse hinzu
iii. ein Prozess fordert Betriebsmittel erst dann an, wenn er sie wirklich
braucht und gibt sie danach sofort wieder frei und nicht erst, wenn er
terminiert.

Ein mögliches Beispiel hierzu ist:
Ein User startet ein Textverarbeitungsprogramm; dies legt zu diesem Zeit-
punkt aber nicht sofort sämtliche Drucker lahm, weil der User ja irgendwann
mal was drucken könnte. Der Drucker wird vielmehr erst dann angefordert,
wenn der User drucken möchte.
Außerdem können von anderen Programmen auch Druckaufträge erfolgen,
selbst wenn die Textverarbeitung noch nicht beendet wurde.

Aufgabe 8

Seitenerset-
zungsstra-
tegien,
FIFO,
LRU, OPT,
paging,
Seitenfehler

Bei der Verwaltung von virtuellem Speicher werden Seitenverdrängungsalgo-
rithmen benötigt, da der virtuelle Adressraum i. A. erheblich größer ist als der
physikalisch tatsächlich vorhandene Speicher. Gegeben sei nun ein Prozess, der
auf die logischen Seiten 1 bis 4 in der folgenden Reihenfolge zugreift: l, 3, 2, 4,
3, 3, 4, 3, 1
Wie viele Seitenfehler werden produziert, wenn dem Prozess jeweils eine, zwei,
drei oder vier Kacheln zur Verfügung stehen? Beantworten Sie diese Fragen für
die Seitenverdrängungsalgorithmen:
a) OPT (Belady’s optimale Strategie)
b) FIFO (First-In-First-Out)
c) LRU (Least-Recently-Used)
Hinweis:
Beachten Sie dabei, dass die Kachel(n) zu Beginn leer ist/sind; d. h. der erste
Zugriﬀ auf eine logische Seite erzeugt auf jeden Fall einen Seitenfehler.)

Bei vier Seiten und vier Kacheln kommt es bei keiner Seitenersetzungsstrategie zu
Seitenfehlern, außer bei den anfänglichen Einlagerungen, d. h. es entstehen genau


------------------------------------------------------------------------
Herbst 04 - Thema 2

267

vier Seitenfehler.
Bei einer Kachel ist die Strategie egal, denn es kann keine Kachel gewählt werden.
Es kommt immer zu acht Seitenfehlern.

1

a) zwei Kacheln:
4
1
2
3
3
3
⇒ 5 Fehler.

1

drei Kacheln:
1
3

1
3
2
⇒ 4 Fehler.

1
3
4

1

b) zwei Kacheln:
2
1
2
3
4
3
⇒ 6 Fehler.

1

drei Kacheln:
1
3

1
3
2
⇒ 5 Fehler.

4
3
2

c) zwei Kacheln:
20
31

11
30

10

⇒ 6 Fehler.

10

drei Kacheln:
12
11
31
30
20

⇒ 5 Fehler.

4
3

1
3
4

3
4

4
3
2

4
3

1
3
4

3
4

4
3
2

4
3

1
3
4

3
4

4
3
2

4
3

1
3
4

3
4

4
3
2

1
3

1
3
4

3
1

4
1
2

21
40

30
41

30
42

31
40

30
41

31
10

40
32
21

41
30
22

42
30
23

40
31
24

41
30
25

42
31
10


------------------------------------------------------------------------
268

4 Betriebssysteme

Aufgabe 9

Semaphor,
Prozess-
koordina-
tion

Eine kleine PKW-Tankstelle besitze 4
Tankplätze (TP1, ... , TP4), wobei man
an jeder Säule alle gängigen Treibstoﬀ-
Sorten zapfen kann. Ferner existiert ein
Waschplatz zur Autowäsche, in dem zu
einem Zeitpunkt genau ein PKW gewa-
schen werden kann (Waschplatz WP).
Von der Straße her kommend können
bis zu 5 PKWs in der Zufahrt zur Tank-
stelle halten und warten (Halteplätze HPl, ... , HP5). Ein Kunde will immer
entweder tanken oder waschen - niemals beides. Weitere Warteplätze auf dem
Tankstellen-Gelände sind nicht nutzbar. Realisieren Sie nun den reibungslosen
Ablauf der Tankstelle mit Zähl-Semaphoren (Counting Semaphores).
a) Deﬁnieren Sie in einer beliebigen objektorientierten Sprache oder in Pseudo-
Code die benötigten Schnittstellen (Konstruktoren und Methoden) und die
internen Datenfelder einer Zähl-Semaphore Semaphore. Eine konkrete Im-
plementierung der Konstruktoren- und Methodenrümpfe ist nicht nötig.
b) Benutzen Sie Ihre Zähl-Semaphore aus Teil a), um den untenstehenden Pro-
grammcode zu vervollständigen. Es können in Ihrer Lösung einer, keiner
oder mehrere Semaphore-Aufrufe auf einer ...-Linie stehen.

class Tankstelle {

Semaphore Tankplatz
= new Semaphore(.......);
Semaphore Waschplatz
= new Semaphore(.......);
Semaphore Halteplatz
= new Semaphore(.......);
public void benutzeTankstelle (auto einAuto) {
..............................................
fahreWartestreifen (einAuto);
if (einAuto.willTanken()) {

..............................................
belegeTankplatz (einAuto);
..............................................
} else {
..............................................
belegeWaschplatz (einAuto);
..............................................
}
..............................................
fahreAusfahrt (einAuto);
..............................................

} // [...] }


------------------------------------------------------------------------
269

Herbst 04 - Thema 2

a) class Semaphore {
private int n;

//Konstruktor
public Semaphore (int n) {
this.n = n;
}

//Methoden
public void up() {
. . .
}

public void down() {
. . .
}

b) class Tankstelle {

Semaphore Tankplatz = new Semaphore(4);
Semaphore Waschplatz = new Semaphore(1);
Semaphore HaltePlatz = new Semaphore(5);

public void benutzeTankstelle (Auto einAuto) {

Halteplatz.down();
fahreWartestreifen (einAuto);
if (einAuto.willTanken()) {

Tankplatz.down();
belegeTankplatz(einAuto);
Halteplatz.up();
Tankplatz.up();

}
else {

Waschplatz.down();
belegeWaschplatz(einAuto);
Halteplatz.up();
Waschplatz.up();

}
fahreAusfahrt(einAuto);

}

}


------------------------------------------------------------------------
Prozess,
Betriebs-
mittel,
Prozess-
fortschritts-
diagramm,
unmögli-
cher
Bereich,
(un-)siche-
rer
Bereich,
Deadlock

270

4 Betriebssysteme

Frühjahr 05 - Thema 2

Aufgabe 10

Gegeben seien zwei Prozesse A und B. A benötigt zu seiner Ausführung 12
Zeiteinheiten, B benötigt 10 Zeiteinheiten. Es stehen insgesamt 5 verschiedene,
exklusive Betriebsmittel (BM) zur Verfügung, die von den Prozessen während
der Ausführung benötigt werden. Die folgende Tabelle zeigt, in welchen Inter-
vallen die beiden Prozesse BM belegen:

Prozess
A
B

BM1
1 - 3, 9 - 11
2 - 4

BM2
6 - 8
3 - 5, 7 - 9

BM3
4 - 5
4 - 6

BM4
7 - 11
4 - 5, 8 - 9

BM5
2 - 3, 9 - 10
1 - 4

a) Zeichnen Sie das Prozess-
fortschrittsdiagramm und
geben Sie die unmöglichen
und unsicheren Bereiche
an!

b) Erklären Sie die Bedeu-
tung von unmöglichen und
unsicheren Bereichen und
deren Zusammenhang mit
Deadlocks!

c) Zeichnen Sie 4 verschie-
dene Pfade im obigen Pro-
zessfortschrittsdiagramm
ein, die die Prozesse A und
B terminieren lasssen!

a) Sichere Bereiche sind als solche gekennzeichnet. Die umrahmten Bereiche
auf der Hauptdiagonalen des Diagramms stellen unmögliche Bereiche dar,
also solche in denen (mindestens) ein Betriebsmittel von beiden Prozessen
gleichzeitig benötigt wird. Alle anderen (schattierten) Bereiche sind unsiche-
re Bereiche.

b) Zeitbereiche, in denen mehrere Prozesse auf die gleiche Ressource gleichzei-
tig zugreifen wollen, sind unmögliche Bereiche, können also nie eintreten.
In einem unsicheren Zustand gibt es keine Ausführungsreihenfolge der Pro-
zesse, so dass diese terminieren; z. B. hält ein Prozess eine Ressource, die
ein anderer kurz darauf anfordert. In einem unsicheren Zustand kann es zu
einem Deadlock kommen, dies muss aber nicht zwangsläuﬁg geschehen.

c) (s. Graﬁk bei Teilaufgabe a))

Der grob gestrichelte Pfad deutet an, dass zuerst Prozess A mit allen benötig-
ten Betriebsmitteln versorgt wird während B erst wartet bis A terminiert


------------------------------------------------------------------------
Frühjahr 05 - Thema 2

271

und dann seine Betriebsmittel zugeteilt bekommt. Analog wird entlang des
grob gepunkteten Pfades zuerst Prozess B komplett versorgt bevor A an der
Reihe ist. Die beiden anderen Pfade erteilen wechselweise für die Prozesse A
und B die Betriebsmittel und umgehen unmögliche Bereiche.

Aufgabe 11

Der Second-Chance-Algorithmus (eine Va-
riante des Clock-Algorithmus) verwendet
für die Auswahl der zu verdrängenden Sei-
ten eine zyklische Datenstruktur wie die
rechts skizzierte.
Der einzige Unterschied zum Clock-Algo-
rithmus besteht darin, dass der Zeiger im-
mer auf die zuletzt eingelagerte Seite
verweist. Bei einem Zugriﬀ auf eine Seite
wird das zugehörige U-Bit (Use-Bit) von
der Hardware auf 1 gesetzt.

Clock-Algo-
rithmus,
second-
chance,
least
recently
used


------------------------------------------------------------------------
272

4 Betriebssysteme

Eine Seite mit der Nummer 10 soll in den Hauptspeicher geladen werden.
a) Erklären Sie die prinzipielle Funktionsweise des Clock-Algorithmus

(2-3 Sätze)!

b) Welche Seite wird in obigem Beispiel aus dem Hauptspeicher verdrängt

werden?

c) Skizzieren Sie die obige Datenstruktur nach dem Einlagern der neuen Seite!
d) Was passiert, wenn die U-Bits aller Seiten auf 1 gesetzt sind und ein Zugriﬀ

auf eine nicht im Hauptspeicher beﬁndliche Seite erfolgt?

e) Der Enhanced-Second-Chance-Algorithmus verwendet zusätzlich zum vom
Second-Chance-Algorithmus bekannten Use-Bit (U-Bit) noch ein Modiﬁed-
Bit (M-Bit), das angibt, ob eine im Hauptspeicher geladene Seite verän-
dert wurde oder nicht. Jede im Hauptspeicher enthaltene Seite fällt damit
in eine der folgenden Klassen:

• U = 0, M = 0
• U = 1, M = 1
• U = 0, M = 1
• U = 1, M = 0
i) In welcher Reihenfolge sollten Seiten dieser unterschiedlichen Klassen
für eine Verdrängung aus dem Hauptspeicher ausgewählt werden?
Begründen Sie kurz Ihre Entscheidung!

ii) Was erhoﬀt man sich durch diese Strategie zu verbessern?

f) Wie könnte der (einfache) Second-Chance-Algorithmus verbessert werden,
so dass der Least Recently Used (LRU) besser aproximiert? (1-2 Sätze)

y

a) (siehe Frühjahr 07 Thema 1 Aufgabe 1b) auf Seite 298)

b) Seite 3, denn das ist die nächste Seite, die der Zeiger ﬁndet, bei der das

Use-Bit 0 ist.

c)

d) Der Zeiger läuft alle Seiten ab und setzt dabei das Use-Bit auf 0. Da bei allen
Seiten das Use-Bit gesetzt war, wird nach einem Zeigerumlauf die älteste
Seite verdrängt. Der Algorithmus mutiert hier also zu FIFO.


------------------------------------------------------------------------
Herbst 05 - Thema 1

273

e)

i) (siehe [TAN], S. 236)

Es wird eine beliebige Seite aus der niedrigsten, nicht-leeren Klasse
genommen, wobei die Reihenfolge der Klassen lautet:

1. U = 0, M = 0
2. U = 1, M = 0
3. U = 0, M = 1
4. U = 1, M = 1

Nicht modiﬁzierte Seiten können einfach überschrieben werden, während
Seiten mit gesetztem M-Bit zurück in den Hauptspeicher geschrieben
werden müssen. Dies ist relativ aufwändig. Außerdem werden zuerst
ungenutzte Seiten und dann genutzte entfernt.

ii) Dadurch, dass zuerst nicht-modiﬁzierte Seiten ausgelagert werden, wird
der Algorithmus schneller, da die auszulagernde Seite nicht zurückge-
schrieben werden muss (siehe i)). Man erhoﬀt durch den Einsatz dieses
Verfahrens, eine höhere Geschwindigkeit beim Speicherzugriﬀ/bei der
Speichernutzung zu erreichen.

f) Eine Erweiterung/Verbesserung des Second-Chance-Algorithmus stellt das
sogenannte Aging dar. Anstatt eines einzelnen Use-Bits werden z. B. 8 Bits
genutzt. In jedem Zeitintervall wird dieser Zähler verringert, indem die Bits
um eine Position nach rechts geschoben werden. Wird die Seite benutzt, wird
auf das Bit ganz links 1 addiert. Die Seite mit dem niedrigsten Wert wird
ersetzt.

Herbst 05 - Thema 1

Aufgabe 1

Da die Aufgabenstellung identisch ist zu (Frühjahr 07 Thema 1 Aufgabe 1 auf
Seite 298) wird hier auf weitere Ausführungen verzichtet.

x

Aufgabe 2

Da die Aufgabenstellung identisch ist zu (Frühjahr 07 Thema 1 Aufgabe 2 auf
Seite 300) wird hier auf weitere Ausführungen verzichtet.

x

Aufgabe 3

Da die Aufgabenstellung identisch ist zu (Frühjahr 07 Thema 1 Aufgabe 3 auf
Seite 302) wird hier auf weitere Ausführungen verzichtet.

x

Aufgabe 4

Da die Aufgabenstellung identisch ist zu (Frühjahr 07 Thema 1 Aufgabe 4 auf
Seite 303) wird hier auf weitere Ausführungen verzichtet.

x

(cid:28)

------------------------------------------------------------------------
274

4 Betriebssysteme

Herbst 05 - Thema 2

Aufgabe 1

x

Da die Aufgabenstellung identisch ist zu (Frühjahr 07 Thema 2 Aufgabe 1 auf
Seite 304) wird hier auf weitere Ausführungen verzichtet.

Aufgabe 2

Da die Aufgabenstellung identisch ist zu (Frühjahr 07 Thema 2 Aufgabe 2 auf
Seite 306) wird hier auf weitere Ausführungen verzichtet.

y

Aufgabe 3

Da die Aufgabenstellung identisch ist zu (Frühjahr 07 Thema 2 Aufgabe 3 auf
Seite 307) wird hier auf weitere Ausführungen verzichtet.

y

Aufgabe 4

Da die Aufgabenstellung identisch ist zu (Frühjahr 07 Thema 2 Aufgabe 4 auf
Seite 308) wird hier auf weitere Ausführungen verzichtet.

y

Aufgabe 5

Da die Aufgabenstellung identisch ist zu (Frühjahr 07 Thema 2 Aufgabe 5 auf
Seite 309) wird hier auf weitere Ausführungen verzichtet.

y


------------------------------------------------------------------------
Frühjahr 06 - Thema 1

275

Frühjahr 06 - Thema 1

Aufgabe 1

Folgendes Szenario gilt für alle drei zu diesem Thema gehörenden Aufgaben:
A) Ein Programm zur Durchführung der Datensicherung auf einem Magnet-
bandgerät arbeite nach folgendem Schema: Eine Konﬁgurationsdatei
backup.conf“ enthält eine Liste von Dateikatalogen, die zu sichern sind.
”
B) Das Datensicherungsprogramm liest jeden dieser Dateikataloge durch und

schreibt nacheinander die Verwaltungsinformationen und den Inhalt der da-
rin enthaltenen Dateien in einen Speicherblock der Größe 4MB.

C) Das Magnetbandgerät arbeitet otpimal, wenn es mit möglichst großen

Schreibaufträgen versorgt wird. Deshalb wird ein zweiter Prozess erzeugt,
der Zugriﬀ auf den gleichen Speicherblock hat und der jeweils 1MB
große Datenbereiche daraus an das Magnetbandgerät überträgt.

Dateisys-
tem

a) Ziel der Datensicherung ist natürlich eine möglichst originalgetreue Re-
konstruktion im Fall von Datenverlust. Nennen Sie Dateiattribute (Ver-
waltungsinformationen des Dateisystems zu einer Datei), die Sie bei der
Datensicherung mit abspeichern würden. Begründen Sie dies jeweils.

b) Dateisysteme sind meist hierarchisch aufgebaut. Was bedeutet dies und wie

geht man damit in dem Datensicherungsprogramm um?

a) Siehe Herbst 07 Thema 1 Aufgabe 2c) auf Seite 315 - hier ﬁnden sich alle x
zu speichernden Dateiattribute und aus deren Beschreibung lässt sich die
Notwendigkeit sie mitzusichern jeweils leicht erkennen.

b) Eine Erläuterung des einfach strukturierten ﬂachen Namensraums, der sich
hinter der hierarchischen Sicht auf ein Dateisystem verbirgt, ﬁndet sich in
Herbst 07 Thema 1 Aufgabe 2a) auf Seite 315. Man muss dann bei der
Datensicherung nicht nur den Inhalt aller Dateien, sondern alle notwendigen
I-Nodes und sonstigen Verwaltungsinformationen mitspeichern.

Aufgabe 2

a) Der in den Schritten B und C erwähnte Speicherblock soll von dem in

Schritt B beschriebenen Prozess 1 gefüllt und von dem in Schritt C be-
schriebenen Prozess 2 ausgelesen werden. Wie erreicht man es, dass beide
Prozesse gemeinsam auf diesen Speicherblock zugreifen können - welches
Speicherverwaltungskonzept muss dafür von der Hardware und dem Be-
triebssystem unterstützt werden?

Dateisys-
tem


------------------------------------------------------------------------
276

4 Betriebssysteme

b) Beschreiben Sie für den Fall einer segmentierten Speicherverwaltung wie
die Abbildung der logischen Adressen der beiden Prozesse auf diesen ge-
meinsam erreichbaren Speicherblock funktioniert. Skizzieren Sie hierzu die
an dem Abbildungsvorgang beteiligten Datenstrukturen des Betriebssys-
tems.

a) Für beide Prozesse muss der gemeinsam genutzte Speicherbereich in deren
Adressraum liegen und kann dann mit normalen Speicherzugriﬀsoperationen
ausgelesen und verändert werden. Meist wird dies über Pagingmechanismen
realisiert, indem beide Prozesse gleiche Seitendeskriptoren verwenden, wo-
durch die gleiche Speicherseite (Kachel) im Hintergrundspeicher verwendet
wird. Das Betriebssystem muss diese shared-memory genannte Art der Inter-
prozesskommunikation unterstützen, damit beide Prozesse auf den Speicher-
bereich zugreifen können.

y

b) Eine allgemeine Beschreibung zur Abbildung von logischen auf physi(kali)sche

Adressen ﬁndet sich in Herbst 02 Thema 2 Aufgabe 8.2 auf Seite 241.

Die Seitentabellen der beiden Prozesse verweisen an einer Stelle auf den
Speicherblock, d. h. sie enthalten die gleiche physi(kali-)sche Adresse.

Aufgabe 3

Semaphor,
Prozess-
koordina-
tion,
Erzeuger-
Verbrau-
cher-
Problem

Grundsätzlich ist eine nebenläuﬁge Arbeit von Prozess 1 und Prozess 2 möglich.
gehen Sie jetzt davon aus, dass der Speicherblock von 4MB für die komplette
Datensicherung nicht ausreicht.
a) Wie organisieren Sie den Speicherblock, um die nebenläuﬁge Arbeit mög-

lichst gut zu ermöglichen?

b) An welchen Stellen werden die beiden Prozesse typischerweise in den Zu-
blockiert“ übergehen, so dass der jeweils andere Prozess die Zeit
”

stand
für seine Arbeit nutzen kann?


------------------------------------------------------------------------
Frühjahr 06 - Thema 1

277

c) Um die in Schritt C geforderte übertragung von jeweils 1MB an das Band-
gerät bei einem Schreibauftrag sicher zu gewährleisten, müssen die bei-
den Prozesse koordiniert werden. Welche Art von Prozesskoordinierung
ist hier erforderlich? Skizzieren Sie die Koordinierung für die beiden Pro-
zesse in einer programmiersprachlichen Form.

a) Der Zugriﬀ auf den gemeinsamen Speicherblock (evtl. als Ringpuﬀer umge-
setzt) kann über Semaphore gesteuert werden, durch die der wechselseitige
Ausschluss der beiden Prozesse gewährleistet ist.

b) Immer dann, wenn einer der beiden Prozesse auf den gemeinsamen Speicher-
block zugreift, geht der andere jeweils in den Zustand blockiert über. So kann
nicht während des Auslesens von Daten gleichzeitig in den Speicherblock ge-
schrieben werden und nicht während des Beschreiben des Speichers dieser
gleichzeitig ausgelesen werden.

//Zähler für freie Bereiche wird
//erniedrigt
//exklusiver Zugriff auf Speicher

P(sperren);
’Schreibe Daten in Speicher’;
V(sperren);
V1(belegt);

//Puffer freigeben
//belegte Bereiche erhöhen

c) void process1()

{

while (TRUE)
{

P1(frei);

}

}

void process2()
{

while (TRUE)
{

P(belegt);

//Zähler für belegte Bereiche wird
//erniedrigt
//exklusiver Zugriff auf Speicher

P(sperren);
’Lese Daten aus Speicher’ ;
V(sperren);
V(frei);

//Puffer freigeben
//freie Bereiche erhöhen

}

}

type semaphore = 0..n;
procedure P (var s: semaphore);
begin

if s ≥ 1 then s:= s-1;
else begin


------------------------------------------------------------------------
278

4 Betriebssysteme

’Stoppe den ausführenden Prozess’;
’Trage ihn in die Warteschlange W(s) ein’

end

end;

procedure P1 (var s: semaphore);
begin

if s ≥ 1 then s:= s-4;
else begin

’Stoppe den ausführenden Prozess’;
’Trage ihn in die Warteschlange W(s) ein’

end

end;

procedure V (var s: semaphore)
begin

s:= s+1
if ’Warteschlange W(s) nicht leer’ then

begin

’Wähle einen Prozess Q aus W(s) aus’;
’Springe zu der P-Operation in Q, die Q stoppte’;

end

end;
procedure V1 (var s: semaphore)
begin

s:= s+4
if ’Warteschlange W(s) nicht leer’ then

begin

’Wähle einen Prozess Q aus W(s) aus’;
’Springe zu der P-Operation in Q, die Q stoppte’;

end

end;

(siehe hierzu [DUD] Stichwort

Nebenläuﬁgkeit“)

”

(cid:27)

------------------------------------------------------------------------
Prozess,
Erzeuger-
Verbrau-
cher-
Problem

Frühjahr 06 - Thema 2

279

Frühjahr 06 - Thema 2

Aufgabe 1

a) Erläutern Sie bitte knapp im Zusammenhang mit Interprozesskommunika-

tion die Begriﬀe
Vor- und Nachteile der beiden Strategien?

sleep&wakeup“ und
”

busy-waiting“. Welches sind die
”

b) Erläutern Sie knapp das Problem, das entsteht, wenn mehrere Prozesse pa-
rallel und unkoordiniert auf eine gemeinsame Ressource - beispielsweise
eine globale Variable - lesend und schreibend zugreifen!

c) Korrigieren Sie die Fehler im unten stehenden Java-Programm, damit da-
raus ein Programm entsteht, welches parallele Prozesse koordiniert: ei-
nen Produzenten und eine beliebige Anzahl n von Konsumenten.
Der Produzent legt jeweils eine einzelne Zufallszahl in einer globalen Puf-
fer-Variablen ab. Die Konsumenten bedienen sich aus diesem globalen Puf-
fer, wenn dort eine Zahl zur Verfügung steht.
Die Fehler beﬁnden sich jeweils nur in den run()-Methoden der
beiden Klassen. Schreiben Sie in Ihrer Lösung die beiden run()-Metho-
den in korrigierter Fassung.

class Konsument implements Runnable
{

private Produzent myProduzent;
private BinSemaphore myBSVoll;
private BinSemaphore myBSLeer;
private BinSemaphore myBSExklusiverZugriff;
public Konsument (Produzent myProduzent, BinSemaphore myBSVoll,

BinSemaphore myBSLeer,
BinSemaphore myBSExklusiverZugriff)

this.myProduzent = myProduzent;
this.myBSVoll = myBSVoll;
this.myBSLeer = myBSLeer;
this.myBSExklusiverZugriff = myBSExklusiverZugriff;
public void run() //Bitte korrigieren

{

}
{

while (true)
{

myBSExklusiverZugriff.p();
myBSVoll.p();
System.out.println(‘‘konsumiert:’’+myProduzent.globalerPuffer);
myBSLeer.v();
myBSExklusiverZugriff.v();

}

}

}


------------------------------------------------------------------------
280

4 Betriebssysteme

class Produzent implements Runnable
{

public int globalerPuffer;
private BinSemaphore myBSVoll;
private BinSemaphore myBSLeer;
private BinSemaphore myBSExklusiverZugriff;
java.util.Random zufallszahlenGenerator;
public static void main (String[] args)
{

int n=10;
BinSemaphore bsVoll = new BinSemaphore(false);
BinSemaphore bsLeer = new BinSemaphore(true);
BinSemaphore bsExklusiverZugriff = new BinSemaphore(true);
Produzent derProduzent = new Produzent(bsVoll,
bsLeer,
bsExklusiverZugriff);

new Thread(derProduzent).start();
for (int i=0; i<n; i++)
{

new Thread(new Konsument(derProduzent,

bsVoll, bsLeer, bsExklusiverZugriff)).start();

}

}
public Produzent (BinSemaphore myBSVoll,
BinSemaphore myBSLeer,
BinSemaphore myBSExklusiverZugriff)

{

this.myBSVoll = myBSVoll;
this.myBSLeer = myBSLeer;
this.myBSExklusiverZugriff = myBSExklusiverZugriff;
zufallszahlenGenerator = new java.util.Random();

}
public void run() //Bitte korrigieren
{

while (true)
{

myBSLeer.v();
myBSExklusiverZugriff.v();
int neueZahl = zufallszahlenGenerator.nextInt(99);
System.out.println(‘‘produziert:’’+neueZahl);
globalerPuffer = neue Zahl,
myBSExklusiverZugriff.p();
myBSVoll.p();

}

}

}


------------------------------------------------------------------------
Frühjahr 06 - Thema 2

281

a)

busy-waiting:

sleep&wakeup: Ein schlafender Prozess bleibt bis zum wakeup gesperrt
und ist in dieser Zeit völlig inaktiv. Der Nachteil ist hier-
bei, dass Prozesse für den wakeup auf andere Prozesse an-
gewiesen sind, da sie sich nicht selbst aufwecken können.
Es kann also passieren, dass Prozesse endlos schlafen.
Ein Prozess überprüft permanent, ob er weiter arbeiten
darf, es kann also nicht mehr vorkommen, dass er endlos
schläft. Diese überprüfung führt zu Verschwendung der
CPU. Hierbei kann es auch zur Prioritätsumkehr kom-
men, wenn ein Prozess mit hoher Priorität auf die Ter-
minierung eines Prozesses mit niedriger Priorität wartet,
dieser aber nicht ausgeführt wird, weil noch Prozesse mit
höherer Priorität vorhanden sind. Dies kann dann zu ei-
ner Verklemmung führen. Desweiteren können Prozesse
mit niedriger Priorität aushungern.

b) Hierbei kann es zu sogenannten race conditions kommen, d. h. die Ausgabe
eines Prozesses oder der Wert einer Variable ist davon abhängig, welcher
Prozess den Wettlauf bei der Zugriﬀszeit
gewonnen“ hat. Prozess A benötigt
”
z. B. eine globale Variable, bevor er jedoch seine Berechnungen zu Ende
führen kann, wird er vom Scheduler unterbrochen und Prozess B kommt an
die Reihe. Dieser wiederum ändert den Wert der globalen Variable. Prozess
A arbeitet im folgenden mit einem falschen Variablenwert.

c) (siehe [DUD], Stichwort Nebenläuﬁgkeit“)

Run-Methode des Konsumenten:

public void run()
{

while (TRUE)
{

myBSVoll.p();
myBSExklusiverZugriff.p();
System.out.println(‘‘konsumiert:’’+myProduzent.globalerPuffer);
myBSExklusiverZugriff.v();
myBSLeer.v();

}

}

(cid:28)

------------------------------------------------------------------------
282

4 Betriebssysteme

Run-Methode des Produzenten:

public void run()
{

while (TRUE)
{

myBSLeer.p();
myBSExklusiverZugriff.p();
int neueZahl = zufallszahlenGenerator.nextInt(99);
System.out.println(‘‘produziert:’’+neueZahl);
globalerPuffer = neueZahl;
myBSExklusiverZugriff.v();
myBSVoll.v();

}

}

Aufgabe 2

Scheduling-
verfahren,
FCFS,
SJF,
Round-
Robin,
Gantt-Dia-
gramm

Zu einem bestimmten Zeitpunkt T kommen folgende Jobs in der gegebenen
Reihenfolge in einer Rechenanlage mit einer CPU zur Bearbeitung an. Der
zusätzliche Aufwand beim Umschalten zwischen den Jobs soll vernachlässigt
werden.

Job Bearbeitungszeit

1
2
3
4
5
6

10
1
2
1
5
9

a) Beschreiben Sie unter Verwendung von Gantt-Diagrammen (siehe Beispiel

unten) die Bearbeitung der Jobs für die Schedulingverfahren FCFS
(First-Come-First-served), SJF (Shortest-Job-First) und RR (q=2)
(Round-Robin mit Zeitquantum=2).

Beispiel für ein Gantt-Diagramm

Zeit
Prozessor#1

1

3

2
Job#1

4
Job#2

5

6
7
Job#3

8

9
leer

b) Geben Sie für alle drei Schedulingverfahren den

zeit im System) eines jeden Jobs an.

Turnaround“ (Gesamt-
”

c) Geben Sie für alle drei Schedulingverfahren die Anfangswartezeiten, d. h.
die Zeit eines jeden Jobs an, die er warten muss, bis er zum ersten Mal
die CPU zugeteilt bekommt.


------------------------------------------------------------------------
Frühjahr 06 - Thema 2

283

d) Welches Schedulingverfahren besitzt (angewandt auf das obige Beispiel und
über alle Jobs gerechnet) die geringste durchschnittliche Gesamtwartezeit,
d. h. bei welchem Verfahren ist die Zeit der Inaktivität der Prozesse
durchschnittlich am geringsten?

a)

b) Der Turnaround beträgt für jeden Job:


------------------------------------------------------------------------
284

4 Betriebssysteme

c) Die Anfangswartezeit beträgt für jeden Job:

d) Die Gesamtwartezeit ist bei FCFS und SJF gleich der Anfangswartezeit:

Die durchschnittliche Wartezeit beträgt:
FCFS: 67/6 = 11, 1
SJF: 34/6 = 5, 6
RR: 60/6 = 10
⇒ bei SJF ist die durchschnittliche Zeit der Inaktivität am Geringsten.

Aufgabe 3

a) Beschreiben Sie knapp die Speicherverwaltungsstrategien First-Fit, Best-
Fit und Worst-Fit. Nennen Sie (tabellarisch strukturiert) zu jeder Strate-
gie mindestens einen Vorteil und einen Nachteil.

b) Gegeben sei die Liste mit den folgenden, freien Speicherblöcken (in genau
dieser Reihenfolge, wobei 1MB = 1024KB). Diese Blöcke liegen nicht ne-
beneinander im RAM.
1000KB

200KB

110KB

1MB

4MB

Es werden nun an das Betriebssystem in folgender Reihenfolge Speicheran-
forderungen gestellt:
900MB
1000KB

200KB

110KB

100KB

2MB

Wie teilt jede der Strategien First-Fit, Best-Fit und Worst-Fit den
Speicher zu? Zur vollständigen Lösung gehört die Liste aller freien Blöcke
nach jeder erfüllten Anforderung.

Speicher-
verwaltung,
First Fit,
Best Fit,
Worst Fit


------------------------------------------------------------------------
Frühjahr 06 - Thema 2

285

c) Bezogen auf das obige Beispiel beantworten Sie bitte die folgenden Fragen

mit knapper Begründung:

• Welches Verfahren schneidet bzgl. Erfüllung der Anfragen am schlech-

testen ab?

• Welches Verfahren arbeitet bzgl. der Fragmentierung am eﬃzien-

testen?

a)

First-Fit

Vorteil:

Nachteil:

Best-Fit

Vorteil:

Nachteil:

durchsucht die Liste der freien Speicherblöcke bis eine ausreichend
große Lücke gefunden wird. Diese wird beschrieben und der ent-
stehende freie Rest bleibt weiterhin in der Liste bestehen.
First-Fit ist das schnellste der drei Verfahren, weil am wenigsten
gesucht wird.
Die freien Speicherblöcke werden nicht optimal genutzt.

durchsucht die gesamte Liste und wählt das kleinste, gerade noch
passende Loch aus.
Große Restbereiche werden nicht unnötig durch kleinere Einträge
belegt, so dass später auch größere Platz-Anforderungen noch be-
dient werden können.
Best-Fit muss in jedem Schritt die gesamte Liste durchlaufen und
ist deshalb langsamer. Außerdem entstehen viele kleine, unbrauch-
bare Lücken.

Vorteil:
Nachteil:

Worst-Fit will kleine Lücken vermeiden und belegt immer das größte noch
verfügbare Loch. Auch hierbei wird wieder die gesamte Liste
durchsucht.
Es bleiben mehr brauchbare Löcher übrig.
Ebenso wie bei Best-Fit wird die ganze Liste durchlaufen und
damit ist Worst-Fit ebenfalls langsamer als First-Fit. Außerdem
wird der größte Block ständig verkleinert, so dass größere Anfor-
derungen irgendwann nicht mehr erfüllt werden können, weil viele
kleine Anforderungen die größten Blöcke belegt haben.

b) First-Fit:

Segment:
1000KB
900KB
200KB
100KB
110KB
2MB

1000KB
0KB

1MB

200KB 110KB 4MB

124KB

24KB

0KB

0KB

2MB


------------------------------------------------------------------------
286

4 Betriebssysteme

Best-Fit:

Segment:
1000KB
900KB
200KB
100KB
110KB
2MB

Worst-Fit:
Segment:
1000KB
900KB
200KB
100KB
110KB
2MB

1000KB
0KB

1MB

200KB 110KB 4MB

124KB

14KB

0KB

10KB

1000KB 1MB 200KB 110KB

2MB

4MB
3096KB
2196KB
1996KB
1896KB
1786KB

kein ausreichend großes Segment mehr

c) Worst-Fit schneidet am schlechtesten ab, weil die letzte Speicheranforderung

nicht mehr erfüllbar ist.
First-Fit ist in der Fragmentierung ein kleines bisschen eﬃzienter, weil nur
ein unbrauchbares Speichersegment übrig bleibt, während es bei Best-Fit
zwei sind.

Herbst 06 - Thema 1

Aufgabe 1

Verklem-
mung,

1.1 Deﬁnieren Sie den Begriﬀ Verklemmung!
1.2 Welche Bedingungen müssen erfüllt sein, damit eine Verklemmung entsteht?


------------------------------------------------------------------------
Herbst 06 - Thema 1

287

1.3 Das Philosophenproblem

Fünf Philosophen sitzen an einem run-
den Tisch, in dessen Mitte ein immer
voller Teller mit Nudeln steht. Rechts
und links von jedem Philosophen liegt je-
weils eine Gabel. Zum Essen benötigt ein
Philosoph zwei Gabeln. Die Philosophen
sind nur mit zwei Dingen beschäftigt:
Denken und Essen. Ist einer hungrig, so
greift er zuerst nach der linken und dann
nach der rechten Gabel und fängt an zu
essen. Ist eine Gabel belegt, so wartet er,
bis sie wieder frei ist. Hat der Philosoph
sich satt gegessen, so legt er die Gabeln
wieder an ihren Platz und fährt fort mit
Denken.

Philoso-
phen-
problem,
ganzzahli-
ger
Semaphor

a) Betrachten Sie unten stehenden Pseudocode, der einen einzelnen Philo-
sophen simuliert! Erläutern Sie in einem Satz, wie es in dieser Lösung
zu einer Verklemmung kommen könnte!
N=5; Procedure phil(i:INTEGER)
WHILE (TRUE) DO

think;
take fork(i);
take form((i+1)%N);

//Philosoph denkt nach
//nimm die linke Gabel
//nimm die rechte Gabel,
% ist Modulo-Operator

eat;
put fork(i);
put fork((i+1)%N);

//essen
//lege linke Gabel zurück
//lege rechte Gabel zurück

END;

END phil;

b) Neben einer Verklemmung könnte noch eine weiteres Problem auftau-

chen. Erläutern Sie kurz welches!

1.1 Mit Deadlock oder Verklemmung bezeichnet man in der Informatik einen
Zustand, bei dem ein oder mehrere Prozesse auf Betriebsmittel warten, die
dem Prozess selbst oder einem anderen beteiligten Prozess zugeteilt sind.
(vgl. [TAN])

1.2 (siehe Herbst 01 Thema 1 Aufgabe 2.2 auf Seite 230)

x

1.3

a) Wenn die Prozesse aller fünf Philosophen gleichzeitig starten, dann
nimmt jeder Philosoph zuerst die linke Gabel auf, kann dann aber nicht
mehr die rechte Gabel nehmen, da diese bereits sein Nachbar hat. Damit
liegt eine Verklemmung vor.

b) Es handelt sich hierbei um das Fairness-Problem, d. h. es ist nicht ga-
rantiert, dass jeder Philosoph zum Essen kommt. Es kann vorkommen,

(cid:28)

------------------------------------------------------------------------
288

4 Betriebssysteme

dass immer der selbe Philosoph warten muss und er dadurch aushun-
gern kann.

1.4 An einem Flughafen gibt es eine Lagerhalle, an der Transportﬂugzeuge ihre
Ware abliefern und aufnehmen können. Lieferanten bringen jeweils zwei Kis-
ten, während Abholer jeweils nur eine Kiste abholen. Zum Be- und Entla-
den ﬂiegen die Flugzeuge zuerst über eine Start- und Landebahn ein und
fahren dann vor die Lagerhalle. Dort steht ein Kran, der die Flugzeuge be-
und entlädt. Danach ﬂiegen die Flugzeuge wieder von der gleichen Start-
und Landebahn weg. Beachten Sie folgende Bedingungen:

• Die Start- und Landebahn kann jeweils nur von einem Flugzeug befah-

ren werden.

• Vor der Lagerhalle ist unbegrenzt Platz, so dass dort mehrere Lieferan-

ten und Abholer stehen können.

• Die Lagerhalle hat eine Kapazität von höchstens 30 Kisten.
• Lieferanten dürfen nur zur Lagerhalle fahren, wenn die Lagerhalle
noch für alle Kisten Kapazitäten hat. Ansonsten müssen sie nach
dem Landen warten.

• Abholer dürfen nur zur Lagerhalle fahren, wenn noch mindestens
eine Kiste in der Lagerhalle ist. Ansonsten müssen sie nach dem
Landen warten.

• Es gibt nur einen Kran, der Flugzeuge nacheinander be- und entla-

den kann.

• Der Kran kann erst zu einem Flugzeug fahren, wenn es zur Lagerhalle

gefahren ist.

• Ein Flugzeug darf erst zur Startbahn fahren, nachdem der Kran vom

Flugzeug abgefahren ist.

• Die Lagerhalle ist zu Beginn leer.

1.5 Die Prozesse sehen folgendermaßen aus:

Lieferant
{

while (TRUE)
{

Abholer
{

while (TRUE)
{

Kran
{

while (TRUE)
{

<auf Start-/Landebahn landen> <auf Start-/Landebahn landen> <Anfahrt zu Flugzeug>
<zur Lagerhalle fahren>
<2 Pakete abliefern>

<zur Lagerhalle fahren>
<1 Paket holen>

<be-/entlade Flugzeug>
<Abfahrt von Flugzeug>

}
<auf Start-/Landebahn starten> <auf Start-/Landebahn starten> }
}

}

}

}

Vervollständigen Sie mit Hilfe von Semaphoren die obigen Prozesse so, dass
es zu keiner Verklemmung kommen kann! Verwenden Sie ganzzahlige Se-
maphore und geben Sie zu den verwendeten Semaphoren die Startwerte
an! Sperrphasen sind möglichst kurz zu halten.

1.4 var landebahn,nochFreiePlaetze,belegtePlaetze,kran:semaphore;

landebahn := 1;

//Definition der Semaphoren
//die Landebahn ist zu Beginn leer


------------------------------------------------------------------------
Herbst 06 - Thema 1

289

nochFreiePlaetze := 30;
belegtePlaetze := 0;
kran := 1;

//der Kran ist frei

Lieferant
{ while (TRUE)
{

down(landebahn);

//exklusiver Zugriff auf die
//Start-/Landebahn

//Start-/Landebahn freigeben

<landen> ;
up(landebahn);
nochFreiePlaetze = nochFreiePlaetze - 2;
<zur Lagerhalle fahren>;//nur wenn noch 2 Plätze frei
down(kran);
Kran();
<zwei Pakete abliefern>;
up(kran);
belegtePlaetze = belegtePlaetze + 2;

//exklusive Belegung des Krans

//Kran freigeben

//Sperrzeit für Kran gering

<zur Start-/Landebahn fahren>;
down(landebahn);

//exklusiver Zugriff auf die
//Start-/Landebahn

<starten>;
up(landebahn);
}

}

Abholer
{ while (TRUE)
{

down(landebahn);

<landen>;
up(landebahn);
down(belegtePlaetze);

//Start-/Landebahn freigeben

//exklusiver Zugriff auf die
//Start-/Landebahn

//nur zur Halle fahren,
//wenn noch mind. 1 Kiste da ist

//exklusive Belegung des Krans

<zur Lagerhalle fahren>;
down(kran);
Kran();
<ein Paket abholen>;
up(kran);
up(nochFreiePlaetze);
<zur Start-/Landebahn fahren>;
down(landebahn);

//Kran freigeben

//exklusiver Zugriff auf die
//Start-/Landebahn

<starten>;
up(landebahn);
}
}
Kran
{ while (TRUE)

//Start-/Landebahn freigeben


------------------------------------------------------------------------
290

4 Betriebssysteme

{

}

<Anfahrt zu Flugzeug>;
<be-/entlade>;
<Abfahrt von Flugzeug>;
}

Aufgabe 2

Programm,
Prozess,
Prozesszu-
stand,
Zustands-
diagramm,
Scheduling-
verfahren,
Round-
Robin,
First-come,
First-
served,
priority
scheduling

2.1 Erklären Sie kurz den Unterschied zwischen einem Programm und einem

Prozess!

2.2 Nennen Sie die Zustände, die ein Pro-
zess aus Betriebssystemsicht einnehmen
kann! übertragen Sie dafür rechts abge-
bildetes Zustandsdiagramm auf Ihr Ar-
beitsblatt! Tragen Sie die Zustände in
die Kreise ein und benennen Sie die Zu-
standsübergänge 1 bis 4!

2.3 Erläutern Sie kurz die Vorgehensweisen der folgenden Scheduling-Algorith-

men:

• Round Robin
• First-come, First-served
• priority scheduling (statisch)

Gehen Sie auch auf die Kriterien Fairness, Echtzeitfähigkeit und unterbre-
chend ein!

2.4 Fünf Stapelverarbeitungsaufgaben A bis E kommen in einem Rechenzen-
trum an. Die folgende Tabelle zeigt für jede Stapelverarbeitungsaufgabe
die Ankunftszeit, die Laufzeit sowie die Priorität. Die Priorität wächst
mit steigenden Zahlen.

Ankunftszeit Laufzeit Priorität

A
B
C
D
E

0ms
1ms
2ms
3ms
4ms

10ms
6ms
2ms
4ms
8ms

3
5
2
1
4

a) Bestimmen Sie für jeden der in Aufgabe 2.3 genannten Scheduling-Al-

gorithmen die durchschnittliche Prozessdurchlaufzeit (Verweilzeit)! Ver-
nachlässigen Sie dabei den Overhead des Prozesswechsels! Die Zeit-
scheibe für Round Robin betrage 2ms.

b) Welchen Algorithmus würden Sie auswählen? Begründen Sie kurz Ihre

Entscheidung!


------------------------------------------------------------------------
Herbst 06 - Thema 1

291

2.1 (siehe Frühjahr 07 Thema 2 Aufgabe 1 auf Seite 304)

2.2

a) Prozess blockiert z. B. wegen Ein-

gabe

b) Scheduler wählt anderen Prozess
c) Scheduler wählt diesen Prozess
d) Eingabe

vorhanden, Blockade

aufgehoben

2.3

Round Ro-
bin:

First-come,
First-served:

priority
scheduling
(statisch):

2.4

a)

Dabei werden alle rechenbereiten Jobs in einer War-
teschlange angeordnet. Jeweils der vorderste Job wird
aus der Schlange genommen, bekommt für eine be-
stimmte, kurze Zeitspanne den Prozessor zugeteilt und
wird dann, falls er mehr Zeit benötigt, erneut hinten
an die Warteschlange angestellt. Neu hinzukommende
Jobs werden ebenfalls an das Ende der Schlange ge-
stellt. Die Zeitspanne, oder auch Zeitscheibe genannt,
ist immer gleich groß, typischerweise in Größenordnun-
gen von 10 bis 50 Millisekunden. Round Robin ist fair,
unterbrechend und im Allgemeinen nicht echtzeitfähig.

Hierbei werden alle Prozesse in der Reihenfolge ihres
Eingangs bearbeitet. Dabei werden einzelne Prozesse
immer komplett verarbeitet, bevor der nächste Pro-
zess an die Reihe kommt. Diese Strategie erzielt eine
gute Auslastung bezüglich der CPU, allerdings nicht
bezüglich der Ressourcen, die längere Zeit für eine An-
forderung benötigen können, wie z. B. Ein-/Ausgabe
oder Massenspeicher. FCFS ist nicht fair, arbeitet oh-
ne Priorität, und ist weder unterbrechend noch echt-
zeitfähig.

Bei dieser Strategie wird jedem Prozess eine Priorität
zugeordnet. Die Abarbeitung erfolgt dann in der Rei-
henfolge der Prioritäten. Priority scheduling ist echt-
zeitfähig, die Fairness wird durch die Prioritäten gere-
gelt. Wir gehen im folgenden von der unterbrechenden
Variante dieser Strategie aus - je nach Literaturquelle
ist auch eine nicht-unterbrechende Variante möglich.

Round Robin: (28 + 21 + 4 + 15 + 26)/5 = 94/5 = 18, 8


------------------------------------------------------------------------
292

4 Betriebssysteme

First-come, First-served: (10 + 15 + 16 + 19 + 26)/5 = 86/5 = 17, 2

priority scheduling: (24 + 6 + 24 + 27 + 11)/5 = 92/5 = 18, 4

b) Für Stapelverarbeitung sind keine unterbrechenden Verfahren geeignet,
so dass FCFS ausgewählt wird. Ginge man beim priority scheduling von
der nicht-unterbrechenden Variante aus, müsste als zweites Argument
die durchschnittliche Verweilzeit (die möglichst kurz sein sollte) hinzu-
gezogen werden.

Aufgabe 3

dynamische
Segmentie-
rung, Best
Fit, First
Fit, Worst
Fit

3.1 Eine Arbeitsspeicherverwaltung wende dynamische Segmentierung an und

habe in der Freispeicherliste noch drei Segmente von 700, 450 und 300 Spei-
chereinheiten zur Verfügung (Reihenfolge wie Aufzählung). Es treﬀen nun
nacheinander Anforderungen von 100, 300, 400, 300 und 250 Speichereinhei-
ten an. Wie würden mit dem ﬁrst ﬁt- und dem best ﬁt-Verfahren die Spei-
chereinheiten auf die Segmente verteilt werden? Stellen Sie Ihr Ergebnis in
einer zu unten stehender äquivalenten Tabelle dar, vergleichen Sie die Er-
gebnisse und erläutern Sie die Unterschiede! Geben Sie hierbei jeweils die
noch freien Speichergrößen an!

Segm. 1
700

First Fit
Segm. 2
450

Segm. 3
300

Segm. 1
700

Best Fit
Segm. 2
450

Segm. 3
300

Anforderung
Segment
Initial
100
300
400
300
250

3.2 Als weitere Möglichkeit gibt es das Verfahren worst ﬁt. Erläutern Sie kurz

die Verfahrensweise, Vor- und Nachteile!

3.1 First Fit verwendet die erste ausreichend große Lücke und ist damit schneller
als Best Fit, das die kleinste, gerade noch ausreichende Lücke sucht. Best
Fit testet also immer alle Segmente. Außerdem liefert Best Fit in der Praxis


------------------------------------------------------------------------
Herbst 06 - Thema 2

293

schlechtere Ergebnisse, da sehr viele kleine, unbrauchbare Lücken entstehen,
also Speicherplatz verschwendet wird.

Anforderung
Segment
Initial
100
300
400
300
250

First Fit
Seg. 2
450
450
450
50
50
50

Seg. 3
300
300
300
300
300
50

Seg. 1
700
600
300
300
0
0

Seg. 1
700
700
700
300
0

Best Fit
Seg. 2
450
450
150
150
150
kein ausreichend
großes Segment mehr

Seg. 3
300
200
200
200
200

3.2 Worst Fit verwendet immer die größte Lücke, um möglichst große Restlücken
zu lassen. Auch Worst Fit liefert in der Praxis keine guten Ergebnisse (es
sind schneller als bei anderen Verfahren nur noch Reste übrig, die zu klein
sind für große Teile) und ist ebenfalls nicht so schnell wie First Fit.

Herbst 06 - Thema 2

Aufgabe 1

a) Skizzieren Sie (graﬁsch) die Abbildung einer logischen Adresse in eine physi-

kalische Adresse in einem System mit Segmentierung!

b) Was muss das Betriebssystem tun, wenn aufgrund von Hauptspeicherman-
gel ein Segment ausgelagert werden soll? Beschreiben Sie den Ablauf und
welche änderungen in welchen der in Teilaufgabe a) beschriebenen Daten-
strukturen vorgenommen werden müssen!

c) Was passiert, wenn der Prozess nach dem Auslagern erneut auf die Daten
des Segments zugreift? Beantworten Sie in Ihrer Beschreibung vor allem
die Fragen:

• Welche Einheit des Systems erkennt, dass das Segment nicht vorhan-

den ist?

• Woran wird das erkannt?
• Welche Aktivitäten ﬁnden daraufhin im Betriebssystem oder in der

Anwendung statt?

• Welche Datenstrukturen werden in diesem Zusammenhang wie modi-

Speicher-
verwaltung,
Seiten-
adressie-
rung,
logische,
physi(kali-)
sche
Adresse,
Segmentie-
rung,
ganzzahli-
ger
Semaphor,
Prozesszu-
stand

ﬁziert?

• Welche Prozesszustände nimmt der betroﬀene Prozess in welcher

Phase ein?

d) Ein Segment soll von zwei Prozessen gemeinsam genutzt werden. Was muss

das Betriebssystem hierfür tun?

e) Nennen Sie drei wesentliche Unterschiede zwischen Segmentierung und Sei-

tenadressierung!


------------------------------------------------------------------------
294

4 Betriebssysteme

a) (siehe Herbst 02 Thema 2 Aufgabe 8.2 auf Seite 241)

b) Das Betriebssystem wählt ein ausreichend großes Segment aus und entfernt
dieses nach Schutz- und Zugriﬀsprüfungen aus dem Speicher. Hierbei wird
das entsprechende Präsenzbit auf 0 gesetzt. Der zugehörige Prozess, der die-
ses Segment benutzt, muss vorher gestoppt werden. Je nach Inhalt des Seg-
ments müssen eventuell geänderte Daten in den Hintergrundspeicher zurück-
geschrieben werden. Hierzu muss entsprechend Platz im Hauptspeicher ge-
funden werden. Am Ende der Wartezeit werden die ausgelagerten Segmente
dann später in den Hauptspeicher zurückgeschrieben.
Das neue Segment wird mit seiner Startadresse und seiner Länge in die Seg-
menttabelle (wiederum nach Schutz- und Zugriﬀsprüfungen) aufgenommen,
das entsprechende Bit für die Anwesenheit im Hauptspeicher wird gesetzt.
In der Regel entsteht zu diesem Zeitpunkt eine Lücke zum nächsten Seg-
ment, da die Segmente selten genau gleich groß sind. Falls die Speicherver-
waltung kein passendes Segment zum Ersetzen ﬁndet, weil sehr viele kleine
Lücken im Speicher sind, so kann der Speicher verdichtet oder ein weiteres
Segment ausgelagert werden. Die Speicherverdichtung ist allerdings sehr re-
chenaufwändig.
Die Wiedereinlagerung kann auf Grund der logischen Adressierung an be-
liebiger passender Stelle des Hauptspeichers erfolgen, es muss lediglich die
Segmenttabelle (insbesondere Setzen des entsprechenden Präsenzbits) ange-
passt werden.

c) Das Betriebssystem stellt anhand des nicht gesetzten Präsenzbits dieses Seg-
ments in der Segmenttabelle fest, dass es sich nicht im Hauptspeicher beﬁn-
det. Der enstprechende Prozess der Anwendung wird vom Betriebssystem
unterbrochen (beﬁndet sich dann also im Zustand wartend/blockiert). Das
Betriebssystem übernimmt die Kontrolle und sucht nun im Hintergrund-
speicher nach dem entsprechenden Namenseintrag (der Name des Segments
ﬁndet sich auch in der Segmenttabelle). Ist das Segment ermittelt prüft das
Betriebssystem Schutz- und Zugriﬀseinstellungen und sucht nach einem pas-
senden Platz zum Einlagern des Segments in den Hauptspeicher. Falls es
keinen ﬁndet, wird erst einmal ein anderes passendes Segment ausgelagert.
Die Segmenttabelle wird angepasst und insbesondere das Präsenzbit des ein-
weckt“ nun den
gelagerten Segments gesetzt. Das Betriebssystem
schla-
”
”
fenden“ Prozess, der sich daraufhin im Zustand
bereit“ beﬁndet. Nach
”
einem Resume läuft er dann weiter, die Kontrolle liegt jetzt wieder beim
Anwendungsprogramm.

d) Um gemeinsam auf Daten zugreifen zu können wird ein sogenanntes Shared-
Memory Segment angelegt, auf das beliebig viele Prozesse zugreifen können.
Damit es hierbei nicht zu Konﬂikten und somit zu inkonsistenten Daten
bei gleichzeitigen Schreib- sowie Schreib-Lesezugriﬀen kommen kann, ist die
Synchronisation (z. B. mittels Semaphoren) sehr wichtig. Da der Bezeich-
ner des Speicherbereichs für dieses Shared Memory Segment vom Betriebs-
system verwaltet wird, ist es für jeden Prozess auf dem gleichen Rechner


------------------------------------------------------------------------
Herbst 06 - Thema 2

295

verfügbar und steht auch verschiedenen Threads innnerhalb eines Prozesses
zur Verfügung.

e) Dadurch, dass Segmente eine inhaltliche Einheit bilden, können bei der Seg-
mentierung Programmcode und Daten getrennt voneinander geschützt wer-
den. Insbesondere wird dadurch gewährleistet, dass der Code nicht verändert
wird und wenn ein Code-Segment ausgelagert wird, muss es (da sicher nicht
modiﬁziert) nicht in den Hauptspeicher zurückgeschrieben werden. Bei der
Seitenadressierung kann eine Seite sowohl Daten als auch Code enthalten.
Da das Betriebssystem den Inhalt der Seite nicht kennt, kann der Code nicht
geschützt werden.
Bei der Segmentierung können Segmente während der Programmausführung
wachsen und schrumpfen, da die Segmentgröße geändert werden kann. Insbe-
sondere der Stack wird zu Beginn der Programmausführung wachsen. Bei der
Seitenadressierung muss immer eine ganze Seite belegt werden, auch wenn
nur ein kleiner Teil davon benötigt wird.
Die Segmentierung bietet außerdem den Vorteil, dass Code-Segmente ge-
meinsam genutzt werden können. Dies wird z. B. bei Bibliotheken häuﬁg
genutzt (s. Teilaufgabe d)). Bei der Seitenadressierung kann der Code nicht
gemeinsam genutzt werden, da das Betriebssystem nicht weiß, in welchen
Seiten der Code steht.

Aufgabe 2

Gegeben sei folgendes Szenario: Ein Prozess P0 erzeugt Daten, die er zur Vor-
verarbeitung einem Prozess P1 übergibt. Das Ergebnis der Vorverarbeitung
übergibt P1 dann an Prozess P2, der eine Weiterverarbeitung vornimmt. Das
Ergebnis der Weiterverarbeitung wird entweder an Prozess P3 zur Ausgabe
übergeben oder muss - falls es bestimmten Kriterien noch nicht genügt - noch-
mals an Prozess P1 zur erneuten Vorverarbeitung übergeben werden.
Die Prozesse P1 bis P3 verfügen jeweils über einen FIFO-Puﬀer (B1 - B3) mit n
Speicherplätzen über den sie ihre Eingaben entgegen nehmen. P1 hat nur einen
solchen Puﬀer (B1), über den sowohl P0 als auch P2 die Daten bei ihm anlie-
fern. Die Prozesse geben ihre Daten grundsätzlich in Form von Datenpaketen
weiter, ein Puﬀer-Speicherplatz kann ein solches Datenpaket aufnehmen.

Prozessko-
ordination,
Erzeuger-
Verbrau-
cher-
Problem,Ver-
klemmung

a) Beschreiben Sie an welchen Stellen Koordinierungsbedarf in diesem Szena-
rio besteht und mit welchen Koordinierungsmechanismen man die Zugriﬀe
jeweils koordinieren kann!


------------------------------------------------------------------------
296

4 Betriebssysteme

b) Skizzieren Sie nun in einer programmiersprachlichen Form die Operationen

put und get:
void put(message m) nimmt eine Nachricht entgegen und kopiert sie in
den Puﬀer. Falls gerade kein Platz in dem Puﬀer frei ist, blockiert die Ope-
ration so lange, bis wieder ein Speicherplatz für die Nachricht frei wird.
message get() entnimmt die nächste Nachricht aus dem Puﬀer. Falls der
Puﬀer leer ist, blockiert die Operation so lange, bis wieder eine Nachricht
vorliegt.

c) Ist Ihre Lösung verklemmungsgefährdet? Begründen Sie Ihre Antwort, in-
dem Sie beschreiben, wann eine Verklemmung auftreten kann bzw. warum
Verklemmungen nicht auftreten werden!

a) Auf die einzelnen Puﬀerplätze darf immer nur ein Prozess gleichzeitig zu-
greifen. Da beim Zugriﬀ auf einen aber zusätzlich Puﬀerplätze freigegeben
bzw. belegt werden, muss dieser exklusiv erfolgen. Dieses Problem kann mit
Semaphoren koordiniert werden. Dazu benötigt man jeweils einen Semaphor
für die belegten und freien Puﬀerplätze, sowie einen binären Semaphor für
den exklusiven Zugriﬀ.

b) Dieses typische Erzeuger-Verbraucher-Problem wurde ausführlich in Frühjahr
03 Thema 2 Aufgabe 5 auf Seite 245 gelöst. Die dortige erzeugen-Methode
entspricht der hier verlangten put-Methode, get wird durch verbrauchen
wiedergegeben.

c) Dadurch, dass P1 nur einen Puﬀer besitzt, auf dem P0 und P2 gleichberech-
tigt Daten erzeugen, kann es zu einer Verklemmung kommen, wenn B1 und
B2 voll sind und P2 ein Datenpaket auf B1 schreiben will. Damit wieder ein
Puﬀerplatz frei wird, müsste P1 sein aktuell bearbeitetes Datenpaket in B2
speichern, was aber nicht möglich ist.
(siehe hierzu auch Frühjahr 03 Thema 2 Aufgabe 5 auf Seite 245)

Aufgabe 3

Prozessko-
ordination,
Erzeuger-
Verbrau-
cher-
Problem,
Verklem-
mung

Gehen Sie von folgendem, gegenüber Aufgabe 2 veränderten Szenario aus:
Die Puﬀer können jeweils nur eine Nachricht aufnehmen. Die Prozesse verar-
beiten die Nachricht direkt aus dem Eingangspuﬀer und schreiben das Ergebnis
direkt in den Puﬀer des empfangenden Prozesses. Beide Puﬀer werden erst dann
wieder freigegeben, wenn die Verarbeitung beendet ist. Der Prozess P2 stellt
dabei zu Beginn der Verarbeitung fest, ob eine neue Vorverarbeitung durch P1
oder die Ausgabe durch P3 erfolgen wird (noch bevor die ersten Ergebnisdaten
produziert werden). Bevor ein Prozess seinen Eingabepuﬀer belegt, überprüft
er, ob überhaupt Daten darin vorhanden sind. Liegen keine Daten vor, wartet
er 10 Sekunden bevor er es erneut versucht.


------------------------------------------------------------------------
Frühjahr 07 - Thema 1

297

a) Skizzieren Sie den Ablauf und die Koordinierung in den Verarbeitungs-

funktionen der Prozesse P1 (Funktion work1()) und P2
(Funktion work2()).

b) Welche Bedingungen für Verklemmungen treﬀen in dem geschilderten Szena-
abstrakter Be-
”

rio zu? Beschreiben Sie jeweils den Zusammenhang zwischen
dingung“ und konkreter Situation!

c) Welche Möglichkeiten zur Verklemmungsvermeidung gibt es in dem geschil-
derten Szenario ganz konkret? Wie müssten Sie Ihre Funktionen work1
und work2 dafür jeweils ändern?

a) work1 ()

work2 ()

if (not(isempty(B1))) {
B1.belegt = true;
verarbeite Daten;
B2.belegt = true;
schreibe Ergebnis in B2;
B2.belegt = false;
B1.belegt = false;}

else {wait 10 s};

Ausgang = B1 or B3;
if (not(isempty(B2))) {
B2.belegt = true;
verarbeite Daten;
Ausgang.belegt = true;
schreibe Ergebnis in Ausgang;
Ausgang.belegt = false;
B2.belegt = false;}

else {wait 10 s};

b) Die Betriebsmittel sind nachforderbar. Solange die Belegung der zwei Puﬀer
nicht durch eine unteilbare Operation gesperrt wird, sondern aus zwei ein-
zelnen Anweisungen besteht, kann es dadurch zu Verklemmungen kommen.
Außerdem enthält das Szenario den Zyklus B1 → P 1 → B2 → P 2 → B1.
Solche Zyklen in der Betriebsmittelbelegung sind eine Bedingung für Ver-
klemmungen.
Das Kriterium der exklusiven Belegbarkeit triﬀt für die Puﬀer ebenso zu.
Dies ist auch sinnvoll, da nicht gleichzeitig lesend und schreibend auf den
Speicher zugegriﬀen werden kann.
Nach der Aufgabenstellung ist auch kein Entzug von Betriebsmitteln möglich.
Die Puﬀer werden jeweils erst dann wieder freigegeben, wenn die Verarbei-
tung abgeschlossen ist.

c) Die einfachste Variante ist die Vermeidung des Zyklus. Hierbei müsste nur
work1 so abgeändert werden, dass zuerst B2 und dann B1 belegt werden.

Frühjahr 07 - Thema 1

Aufgabe 1

a) Beschreiben Sie die Seitenersetzungsstrategie LRU (Least Recently Used).
Gehen Sie dabei ein auf Funktionsweise und Motivation der Strategie so-
wie auf Probleme bei der Realisierung!

Speicher-
verwaltung,
Seitenerset-
zungsstra-


------------------------------------------------------------------------
298

4 Betriebssysteme

tegien,
LRU, Sei-
tenﬂattern,
Clock-Algo-
rithmus,
second-
chance

c) Welche Strategien zur näherungsweisen Realisierung von LRU gibt es? Er-
läutern Sie an einem Beispiel detailliert die Funktionsweise! Warum und
wie werden durch die von Ihnen beschriebene Strategie die Probleme von
LRU vermieden?

d) Was versteht man unter Seitenﬂattern (Thrashing)? Was sind die Ursa-

chen? Welche Möglichkeiten gibt es Seitenﬂattern zu vermeiden?

a) Bei LRU wird die Seite ersetzt, die am wenigsten genutzt wurde. Es muss
also zu jeder Kachel ein Zähler implementiert werden, der die Seitenzugriﬀe
zählt. LRU stellt eine gute Näherung an das optimale Verfahren dar. Dieses
verdrängt die Seite, die am längsten nicht mehr genutzt wird. Da ein Com-
puter aber nicht in die Zukunft sehen kann, stellt LRU eine gute Alternative
dar. Problematisch ist allerdings die Implementierung, da nach jedem Sei-
tenzugriﬀ der Zähler einer Kachel erhöht werden muss und die Liste aller
Kacheln aufsteigend nach den Zählern neu sortiert werden muss.

b) Zur Näherung von LRU kann der second-chance- bzw clock-Algorithmus
eingesetzt werden. (Diese beiden unterscheiden sich nur in der Implemen-
tierung.)
Der Clock-Algorithmus ist eine Variante von FIFO um zu verhindern, das
häuﬁg benutzte Seiten ausgelagert werden. Jede Seite besitzt ein Referenz-
Bit. Muss eine Seite ausgelagert werden, werden diese Referenz-Bits über-
prüft, angefangen von der ältesten Seite. Ist dieses Bit nicht gesetzt, wird die
Seite ausgelagert, weil sie am längsten nicht mehr referenziert wurde. Ist das
Bit gesetzt, bedeutet dies, dass die Seite in letzter Zeit genutzt wurde und
deshalb wird sie nicht ausgelagert (zweite Chance), aber das Referenz-Bit
wird zurückgesetzt. Der Algorithmus prüft in diesem Fall der Reihe nach
alle Referenz-Bits bis er eines ﬁndet, das nicht gesetzt ist. Sind alle Bits ge-
setzt, löscht der Algorithmus nacheinander alle und ersetzt dann die älteste
Seite, bei der er angefangen hat die Bits zu prüfen. Second-chance degene-
riert in diesem Fall zu FIFO.
Der Vorteil dieses Verfahren besteht darin, dass bei einem Seitenzugriﬀ nur
ein einziges Bit geändert werden muss, im Gegensatz zum Hochsetzen al-
ler Zähler in jedem Schritt bei LRU. Der Verwaltungsoverhead wird also
deutlich kleiner, das Verfahren hat nur sehr geringen Aufwand.

c) (siehe [TAN])

Was ist Seitenﬂattern?

• Wenn ein Prozess nicht so viele Rahmen hat, wie benötigt werden, muss

er Seiten ersetzen.

• Wenn auch noch alle seine Seiten in aktivem Gebrauch sind, muss er

eine Seite ersetzen, welche später noch einmal benötigt wird.

• Folglich gibt es sehr schnell wieder und immer wieder Seitenfehler.
• Der Prozess produziert immer mehr Fehler, indem er Seiten ersetzt, für

welche sich dann Fehler ergeben.

(cid:27)

------------------------------------------------------------------------
Frühjahr 07 - Thema 1

299

• Dieser Vorgang heißt Seitenﬂattern. Ein Prozess ﬂattert, wenn er mehr

Zeit für das Seitenaustauschen benötigt als für das Ausführen.

Ursachen für Seitenﬂattern
Seitenﬂattern resultiert aus schwierigen Ausführungsproblemen:

• Das Betriebssystem überwacht die CPU-Nutzung.
• Wenn die CPU-Nutzung zu niedrig ist, wird der Multiprogrammbetrieb

erhöht.

• Ein neuer Prozess wird gestartet, für den nicht genügend Seiten vor-
handen sind. → Er nimmt sich Seiten, die eigentlich anderen Prozessen
zugeteilt wurden.

• Da die Seiten von den anderen Prozessen wieder benötigt werden, be-

ginnen auch sie Seiten zu

stehlen“.
”

• Dadurch entstehen Fehlprozesse, welche vor dem Seitenaustauschbau-

stein warten müssen.

• Je größer die Warteschlange wird, desto mehr leert sich die ready queue,

d. h. die CPU-Nutzung sinkt.

• Es werden also immer neue Prozesse gestartet und der

ist geschlossen.

Das Working-Set Modell

Teufelskreis“
”

• Wenn eine Seite im aktiven Gebrauch ist, dann ist sie auch im Working-

Set.

• Wenn sie nicht mehr genutzt wird, wird sie nach ∆ Zeiteinheiten aus

dem Working-Set genommen.

• Das Working-Set ist der minimale Anteil an Seiten, der sich während

des Programmlaufs im Speicher beﬁnden muss.
• Die Genauigkeit ist abhängig von der Wahl von ∆.
• Die wichtigste Eigenschaft eines Working-Set ist seine Größe.

Seitenfehlerrate

• Seitenﬂattern hat eine Seitenfehlerrate. Diese Fehlerrate möchte man

kontrollieren.

• Wenn sie zu hoch ist, benötigt der Prozess mehr Rahmen.
• Wenn sie zu niedrig ist, hat der Prozess zu viele Rahmen.
• Man kann eine Höchst- und Untergrenze für die Seitenfehlerzahl festle-

gen.

• Wenn die Zahl der Seitenfehler die obere Grenze überschreitet, wird

dem Prozess ein neuer Rahmen zugewiesen.

• Sinkt die Zahl der Fehler unter die Untergrenze, wird dem Prozess ein

Rahmen weggenommen.

• Auf diese Weise kann man die Seitenfehlerrate direkt messen und kon-

trollieren, um Seitenﬂattern zu vermeiden.


------------------------------------------------------------------------
Prozess,
Prozesszu-
stand,
LRU, Sei-
tenﬂattern,
Clock-Algo-
rithmus,
second-
chance,
Scheduling-
verfahren,
Round-
Robin,
First-come,
First-
served

y

300

4 Betriebssysteme

Aufgabe 2

a) Skizzieren Sie die Zustände, die ein Prozess unter einem Mehrbenutzer-Be-

triebssystem wie z. B. UNIX typischerweise einnehmen kann!

b) Ein Prozess habe folgenden Ablauf (grob skizziert):

1. Start, Variablen initialisieren
2. Konﬁgurationsdatei einlesen
3. kurze Vorberechnungen durchführen (Dauer: 2ms)
4. Berechnungsdaten aus Datei einlesen
5. Berechnung durchführen (Dauer: 800ms)
6. Ergebnis in Datei ausgeben
7. Ende
• Nehmen Sie zunächst an, das Betriebssystem arbeitet mit einer

First
”

Come First Served“ - Scheduling-Strategie. Welche Zustände nimmt
der Prozess während dieses Ablaufs ein, wodurch werden welche Zu-
standsübergänge ausgelöst?

• Nehmen Sie nun an, das Betriebssystem arbeitet mit der Strategie

Round Robin“ und es gibt weitere, laufbereite Prozesse im System.
”
Die Zeitscheibenlänge sei 300ms. Wie sieht der Ablauf des Prozes-
ses (Zustände, Zustandsübergänge, Ursachen) aus?

c) In vielen Betriebssystemen wird zwischen einem Benutzermodus und ei-
nem Systemmodus unterschieden. Beschreiben Sie die Eigenschaften und
Unterschiede der beiden Modi. Wie erfolgt die Umschaltung zwischen den
Modi? Was sind die Ziele dieser Unterscheidung? In welchen Rechensyste-
men ist die Unterscheidung sinnvoll oder sogar wichtig und in welchen Sys-
temen ist sie verzichtbar?

a) (vgl. hierzu auch (mit anderer Anzahl der möglichen Zustände) Herbst 01
Thema 1 Aufgabe 3.3, Herbst 02 Thema 1 Aufgabe 4.2, Herbst 02 Thema 2
Aufgabe 7.1; s. auch [DUD], Stichwort

Prozess“)

”

b)

• Im Zustand

aktiv“ wird der Prozess auf einem
”
Prozessor ausgeführt. Prozesse im Zustand
bloc-
”
kiert“ warten auf bestimmte Ereignisse, die für
den weiteren Ablauf der Prozesse notwendig sind,
z. B. auf die Zuteilung von Speicherplatz, die Ant-
wort auf eine Anfrage usw. Prozesse, die ihren
Ablauf fortsetzen können, beﬁnden sich im Zu-
bereit“. Sie warten auf das Freiwerden ei-
stand
”
nes Prozessors, der momentan noch mit der Be-
arbeitung eines anderen Prozesses beschäftigt ist. Prozesse, die die Re-
chenanlage gerade betreten, bzw. sie nach vollständiger Verarbeitung

(cid:27)

------------------------------------------------------------------------
Frühjahr 07 - Thema 1

301

verlassen, gelangen in die Zustände
initiiert“ bzw.
”
Zustandsübergänge steuert die Prozessorverwaltung.

terminiert“. Die
”

• Zu Beginn beﬁndet sich der Prozess im Zustand

initiiert“, wird dann in
”
bereit“ versetzt und wartet auf die Zuteilung des Prozes-
den Zustand
”
aktiv“ und initialisiert die
sors. Erfolgt diese Zuteilung, ist der Prozess
”
Variablen. Außerdem gibt er den Auftrag, die Konﬁgurationsdatei ein-
zulesen. Während der Wartezeit auf die Rückmeldung der Datei, ist der
Prozessor nicht aktiv, der Prozess wird aber wegen der FCFS-Strategie
aktiv“ bis das Ergebnis in die
nicht verdrängt. Er bleibt im Zustand
”
Datei ausgegeben wurde und er damit in den Zustand
terminiert“ ver-
”
setzt werden kann.

Start, Variablen einlesen

Konﬁgurationsdatei
sen

einle-

Vorberechnungen

kurze
durchführen
Berechnungsdaten aus Da-
tei einlesen

Berechnung durchführen

initiiert“,
”

bereit“ und
”

Der Prozess wird wiederum nacheinander in die
Zustände
aktiv“ ver-
”
setzt.
Nachdem der Prozess die Datei angefordert hat,
blockiert“ versetzt, denn
wird er in den Zustand
”
das Lesen der Datei dauert relativ lange, da
dafür in der Regel Festplattenzugriﬀe nötig sind.
Während dieser Zeit bekommen andere Prozes-
se die CPU zugeteilt. Wenn die Datei eingelesen
bereit“
ist, wechselt der Prozess in den Zustand
”
und reiht sich in die Warteschlange ein.
Der Prozess bekommt eine Zeitscheibe zugeteilt
und wird
aktiv“.
”
blockiert“ der Prozess bis die ange-
Wiederum
”
forderten Daten verfügbar sind. Danach beﬁndet
er sich im Zustand
bereit“ und wird hinten in
”
die Warteschlange eingereiht.
Für die Berechnung benötigt der Prozess insge-
samt 3 Zeitscheiben, er muss also mehrfach vom
Zustand

aktiv“ wechseln.
”

bereit“ in
”

aktiv“ bis die
”

Datei ausgegeben ist.
aktiv“
Der Prozess beﬁndet sich im Zustand
”
und wird in den Zustand
terminiert“ versetzt.
”
Damit wird der Speicherplatz, den der Prozess
belegt, freigegeben und die zugehörigen Register
gelöscht.

Ergebnis in Datei ausgeben Der Prozess bleibt im Zustand

Ende

c) Benutzermodus (User-Mode):

Programmcode wird von einem Prozess im Benutzermodus ausgeführt (nicht
privilegiert!).

Systemmodus (Kernel-Mode):
Alle Funktionen des Betriebssystems werden im Systemmodus im privile-


------------------------------------------------------------------------
302

4 Betriebssysteme

gierten Modus (supervisor) ausgeführt. In der Umgebung des Systemkerns
gibt es für jeden Prozess einen eigenen Stack (lokale Daten), jedoch nur ein
Datensegment (globale Daten) für alle Prozesse gemeinsam. Prozesswechsel
im Systemmodus sind nur an fest deﬁnierten Stellen möglich, an denen die
globalen Datenstrukturen in konsistentem Zustand sind. Daraus können sich
Probleme bei Multiprozessorsystemen ergeben.

Wechsel zwischen Benutzer- und Systemmodus:
Betriebssystemdienste werden durch einen Prozess durchgeführt. Zunächst
wird ein Wechsel vom Benutzer- in den Systemmodus (privilegiert!) vorge-
nommen und anschließend Funktionen des Systemkerns aufgerufen. Es for-
dert also ein Prozess nicht einen Betriebssystemdienst von einem Kernprozess
an, sondern sein Aktivitätsträger wechselt in den Systemkern und führt dort
den Systemdienst selbst aus.
Der Wechsel zwischen Benutzer- und Kernelmodus geschieht durch Traps
(system calls, SVCs) und Exceptions (z. B. Division durch 0), die ebenfalls
einen Wechsel in den Systemkern bewirken, wo die Fehlerbehandlung veran-
lasst wird.

Aufgabe 3

Verklem-
mung,
sicherer
Zustand,
Banker’s
Algorith-
mus

a) Welche Bedingungen müssen gegeben sein, damit eine Verklemmung auftre-

ten kann?

b) Welche drei grundsätzlichen Verfahren gibt es, um mit der Verklemmungs-
problematik umzugehen? Beschreiben Sie jedes Verfahren! Wie ist jeweils
die grundsätzliche Vorgehensweise? Geben Sie ein Beispiel für einen Algo-
rithmus an, der bei einem dieser Verfahren zum Einsatz kommt und be-
schreiben Sie den Algorithmus!

y

a) (siehe Herbst 01 Thema 1 Aufgabe 2.2 auf Seite 230)

b) Deadlocks können entweder erkannt und behoben, vermieden oder verhindert

werden.

• Erkennung und Behebung von Deadlocks:

Deadlocks können z. B. mit Ressourcenallokationsgraphen erkannt wer-
den. Liegt nach der Reduktion ein Zyklus vor, ist ein Deadlock vor-
handen. Als Reaktion darauf können nacheinander die am Deadlock
beteiligten Prozesse abgebrochen werden, bis der Deadlock aufgehoben
ist. Diese Methode ist aber nicht unbedingt empfehlenswert.

• Deadlock-Verhinderung:

Bei diesem Ansatz wird kein prinzipiell verklemmungsfreies System ga-
rantiert. Deadlocks können in realen Systemen nicht verhindert werden,
da Informationen über zukünftige Betriebsmittelanforderungen nicht


------------------------------------------------------------------------
Frühjahr 07 - Thema 1

303

verfügbar sind. In realen Systemen versucht man, Deadlocks zumindest
prinzipiell zu vermeiden, indem man eine der vier Deadlock-Bedingungen
nicht zulässt, z. B. die zyklische Wartebedingung: Alle Betriebsmittel
werden global nummeriert und Prozesse bekommen nur neue Betriebs-
mittel, die eine höhere Nummer haben als die bereits zugeteilten Be-
triebsmittel. Damit kann kein Zyklus entstehen → kein Deadlock.

• Deadlock-Vermeidung:

überwachung der Betriebsmittelvergabe, um unsichere, d. h. verklem-
mungsbedrohte Zustände zu vermeiden. Die Deadlock-Vermeidung be-
nötigt also Wissen über die zukünftigen Ressourcenanforderungen der
Prozesse. Hierbei gibt es zwei mögliche Verfahren: Ein Prozess darf
nicht gestartet werden, falls seine Anforderungen zu einem Deadlock
führen könnten und eine Ressourcenanfrage darf nicht befürwortet wer-
den, falls sie zu einem Deadlock führen könnte. Für den zweiten Fall
existiert der Banker’s Algorithmus von Djikstra (zu diesem Thema siehe
auch Herbst 04 Thema 2 Aufgabe 7 auf Seite 264):
Der Banker’s Algorithmus von Djikstra:
Gesamtressourcen: E = (E1, . . . , Em)
Verfügbare Ressourcen: A = (A1, . . . , Am)
von Prozess i belegte Ressourcen: Ci = (Ci1, . . . , Cim)
von Prozess i benötigte Ressourcen: Ri = (Ri1, . . . , Rim)
Zu Beginn sind alle Prozesse i nicht markiert.

x

while ( ∃unmarkiertes i ∧ ∀j|1≤j≤mRij ≤ Aj) {
⇒ i kann abgearbeitet werden
⇒ Ressourcen freigeben: Aj = Aj + Cij
⇒ i markieren

}
if (alle i markiert) {

⇒ sicherer Zustand }

else { ⇒ schlechter Zustand }

Aufgabe 4

a) Was sind die grundlegenden Aufgaben eines Dateisystems?
b) Wie ist ein Dateisystem unter UNIX oder Windows prinzipiell strukturiert?

Dateisystem

Welche Verwaltungseinheiten gibt es?

a) (siehe Frühjahr 07 Thema 2 Aufgabe 4a))

b) (siehe Frühjahr 07 Thema 2 Aufgabe 4b))

x

x


------------------------------------------------------------------------
304

4 Betriebssysteme

Frühjahr 07 - Thema 2

Aufgabe 1

Programm,
Prozess,
Thread

a) Erläutern Sie die Begriﬀe Programm, Prozess und Thread!
• Wie entstehen Programme, Prozesse bzw. Threads?
• Wie werden sie vom Betriebssystem verwaltet?
• Welche Eigenschaften, Attribute etc. werden für die Verwaltung be-

nutzt?

b) Was haben diese Konzepte miteinander zu tun, wo liegen die Unterschiede?
c) Beschreiben Sie unterschiedliche Möglichkeiten zur Realisierung von

Threads! Was sind jeweils die Vor- und Nachteile?

a) Ein Prozess ist im Prinzip ein Programm, das gerade ausgeführt wird. Al-
lerdings ist jedem Prozess ein Adressraum zugeordnet, der außer dem in
Ausführung beﬁndlichen Programm, die Programmdaten und den zugehöri-
gen Stack enthält. Zusätzlich sind noch der Programmzähler, der Zeiger auf
den Stack (Stapelzeiger) und andere Register vorhanden sowie weitere In-
formationen, die zur Ausführung des Programms benötigt werden. All dies
ist innerhalb des Adressraums in einer Liste von Speicherstellen mit einem
minimalen und einem maximalen Wert abgelegt, in denen der Prozess lesen
und schreiben darf. In einem Text-Segment ﬁnden sich Maschineninstruktio-
nen des Programms; dieser Bereich ist in der Regel schreibgeschützt und wird
von mehreren Prozessen gemeinsam benutzt. Das Daten-Segment enthält die
Daten des Programms (global und static) und ist dynamisch erweiterbar. Lo-
kale Daten und Aufrufparameter von Funktionen sowie Sicherungsbereiche
für Registerinhalte und Rücksprungadressen werden im bei Bedarf wachsen-
den Stack-Segment abgelegt.
Jedem Prozess ist ein sogenannter Prozesskontrollblock (Process control block;
PCB) zugeordnet. Er ist eine Datenstruktur, die alle nötigen Daten für
einen Prozess enthält. Dazu gehören in UNIX beispielsweise Prozessnum-
mer (PID), verbrauchte Rechenzeit, Erzeugungszeitpunkt, Kontext (Register
etc.), Speicherabbildung, Eigentümer (UID, GID), Wurzelkatalog, aktueller
Katalog, oﬀene Dateien.
Im Speicherbereich der user area des gerade aktiven Prozesses, die auf eine
feste Adresse des virtuellen Adressraums des Systemkerns abgebildet oder
über einen festen Zeiger im Systemkern adressiert wird, werden als Verwal-
tungsdaten für jeden Prozess Daten zur Verwaltung des Programmablaufs
durch den Systemkern, z. B. die Segmenttabelle bzw. ein Verweis auf die
Seiten-Kachel-Tabelle, Verweise auf Einträge in der Prozesstabelle, Statistik-
Daten (Laufzeiten, ...), das aktuelle Directory (current working directory),
die aktuelle Root, die user ﬁle descriptor table, Adressen der signal-handler-
Funktionen, der Bereich zum Sichern des Prozesszustands (Register) bei Pro-
zesswechsel und der Puﬀer für Systemaufruf-Parameter und -Rückgabewerte
gespeichert.


------------------------------------------------------------------------
Frühjahr 07 - Thema 2

305

Globale Prozessverwaltungsdaten werden in der Prozesstabelle gehalten. Hier
ﬁnden sich also alle wichtigen Verwaltungsdaten über einen Prozess, die
immer verfügbar sein müssen; sie werden in proc-Strukturen gehalten. Al-
le proc-Strukturen bilden zusammen die Prozesstabelle, die beim Booten
statisch als Feld angelegt oder dynamisch als Liste verwaltet wird. Eine
proc-Struktur enthält u. a. folgende Daten: Prozesszustand (laufend/bereit,
blockiert, ausgelagert, ...), Verweise auf die Segmente des Prozesses (meist
über page table), einen Verweis auf die user area, einen Verweis auf die
credential-Struktur mit den Zugriﬀsrechten (User-Ids, Gruppen-Rechte), Spei-
cher für Daten zur Signalverarbeitung, Scheduling-Parameter (z. B. Prio-
rität), Informationen über Ereignissse, auf die der Prozess wartet.
Erzeugung von Prozessen:
Jeder UNIX-Prozess kann mit einem Systemaufruf (fork()) einen neuen Pro-
zess erzeugen. Hierbei erzeugt fork( ) eine nahezu identische Kopie des aufru-
fenden Prozesses. Der fork( ) aufrufende Prozess wird Vaterprozess (parent
process) genannt, der durch fork( ) neu erzeugte Prozess wird als Sohnpro-
zess (child process) bezeichnet. Der Sohnprozess erbt alle Rechte und Ein-
schränkungen vom Vaterprozess. Wesentlicher Unterschied zwischen Vater-
und Sohnprozess ist z. B. die PID.

Ein Prozess kann aus einem oder mehreren Threads bestehen. Eine Gruppe
von Threads nutzt gemeinsam eine Menge von Betriebsmitteln, z. B. Instruk-
tionen, Datenbereiche, Dateien, Semaphoren. Jeder Thread repräsentiert ei-
ne eigene Aktivität mit eigenem Programmzähler, eigenem Registersatz und
eigenem Stack. Das Umschalten zwischen zwei Threads einer Gruppe ist er-
heblich billiger als eine normale Prozessumschaltung. Denn es müssen nur die
Register und der Programmzähler gewechselt werden. Die Speicherabbildung
muss nicht geändert werden und alle Systemressourcen bleiben verfügbar. So-
mit ist der Verwaltungsaufwand für Threads üblicherweise geringer als der
für Prozesse. Ein Prozess kann aus genau einem Thread des Betriebssystems
bestehen, wenn bei dem Programmablauf keine Parallelverarbeitung vorge-
sehen ist.

b) Threads können entweder im Benutzer-Adressraum oder im System-Adress-

raum realisiert werden.
(vgl. hierzu auch Herbst 04 Thema 1 Aufgaben 3.3 und 3.4 auf Seite 259 x
sowie Frühjahr 07 Thema 1 Aufgabe 2c) auf Seite 300)


------------------------------------------------------------------------
306

4 Betriebssysteme

Aufgabe 2

Scheduling,
Scheduling-
verfahren

a) Beschreiben Sie die grundlegenden Scheduling-Strategien und ihre Eigen-

schaften!

b) Wie könnte eine realistische Scheduling-Strategie für ein Mehrbenutzer-

und Mehrprogramm-Betriebssytem aussehen?

• Welche Ziele sollte solch eine Scheduling-Strategie haben?
• über welche Parameter muss man bei der Strategie entscheiden und

was sind die Auswirkungen der Paramter?

• Welche Probleme können unter sehr starker Systemlast entstehen und

was kann man dagegen tun?

y

y

a) (vgl. hierzu auch Herbst 06 Thema 1 Aufgabe 2.3 und Herbst 07 Thema 1

Aufgabe 3a))

b) Jede Scheduling-Strategie sollte fair sein, d. h. jeder Prozess bekommt Re-
chenzeit von der CPU, kein Prozess verhungert. Es muss Policy Enforcement
durchgesetzt werden, d. h. Richtlinien werden sichtbar durchgeführt. Gelten
grundsätzlich für eine Reihe von Prozessen Sonderregeln, so muss der Sche-
duler gewährleisten, dass diese berücksichtigt werden. Außerdem sollten alle
Teile des Systems ausgelastet sein. In Mehrbenutzer-Systemen werden heut-
zutage komplexere Verfahren als Round Robin eingesetzt.
(siehe hierzu auch Herbst 07 Thema 1 Aufgabe 3c auf Seite 317)
Bei der Berechnung der Priorität spielt auch die CPU usage eine Rolle, d.
h. wieviel CPU-Zeit der Prozess in der letzten Zeit zugeteilt bekommen hat.
Um das Scheduling fair zu gestalten, erhalten Prozesse mit viel CPU usage
eine niedrigere Prioriät. Ist die Systemlast sehr hoch durch sehr viele lauf-
bereite Prozesse, erhalten die Prozesse, die noch nicht weiter abgearbeitet
sind, eine hohe Priorität, während diejenigen, die schon fast fertig sind, sehr
niedrig eingeordnet werden. Die einzelnen Prozesse terminieren nicht und im
Normalfall kommen laufend neue hinzu, die wiederum eine hohe Priorität
erhalten. Um diesem Problem entgegenzuwirken, wird die Priorität in re-
gelmäßigen Abständen (z. B. 1 Sekunde) neu berechnet und die CPU usage
verfällt mit der Zeit. Beispielsweise wird der Wert des alten CPU usage hal-
biert (also ein Rechtsshift gemacht) und die Anzahl der CPU-Zeit des letzten
Zeitraums hinzuaddiert. Prozesse, die einmal eine sehr hohe CPU usage hat-
ten und fast fertig abgearbeitet sind, wandern somit nach und nach in der
Priorität wieder nach oben und können terminieren.

Aufgabe 3

logische
Adresse,
physikali-
sche

a) Skizzieren und beschreiben Sie den Ablauf einer Adressumrechnung von ei-
ner virtuellen Adresse in eine reale Hauptspeicheradresse in einem seiten-
adressierten System!


------------------------------------------------------------------------
Frühjahr 07 - Thema 2

307

b) Wie ist der Ablauf, wenn sich die adressierte Seite nicht im Hauptspeicher

beﬁndet?

c) Wie groß ist heute typischer Weise eine Seite?
d) Welche Probleme würden sich ergeben, wenn man die Adressabbildung in
ihrer einfachsten Form auf einem heute gebräuchlichen PC realisieren wür-
de? Welche Konzepte gibt es, diese Probleme zu mildern?

Adresse,
Seite, Sei-
tenadres-
sierung,
Seiten-Ka-
chel-Tabelle

a)

Der erste Teil der virtuellen Adresse ist die Nummer der Seitenkachel. In der
Seitenkacheltabelle ﬁndet sich unter dieser Nummer zu jeder Kachel jeweils
die zugehörige Adresse im Hintergrundspeicher. Der zweite Teil der virtuellen
Adresse ist die Adresse innerhalb der Kachel bzw. der Seite im Hintergrund-
speicher. Kombiniert mit der Adresse aus der Seitenkacheltabelle ergibt sich
dann die physikalische Adresse.

b) Wenn sich die adressierte Seite nicht im Hauptspeicher beﬁndet, kommt es
zu einem Seitenfehler. Falls der Hauptspeicher voll ist - die Seite also nicht
einfach nachgeladen werden kann - muss nun ein Seitenwechsel vorgenom-
men werden. Dabei wird eine Seite aus dem Hauptspeicher verdrängt und
falls sie geändert wurde, in den Hintergrundspeicher zurück geschrieben. Die
angeforderte Seite wird dann an die frei gewordene Stelle aus dem Hinter-
grundspeicher kopiert. Welche Seite aus dem Hauptspeicher verdrängt wird,
entscheidet die Seitenersetzungsstrategie, z. B. LRU oder FIFO. (s. [DUD])

c) Praktische Größenordnungen für Seiten liegen heute bei 2 - 64 KByte. (s.

[DUD], Stichwort
”
von 512 Bytes - 8192 Bytes eingesetzt.

Speicherverwaltung“) Am häuﬁgsten werden wohl Größen (cid:28)

d) Heutige PCs verfügen über relativ viel Speicher. Teilt man diesen in kleine
Kacheln auf, wird die Seitentabelle extrem groß und die Suche nach einem


------------------------------------------------------------------------
308

4 Betriebssysteme

Eintrag in der Tabelle wird sehr zeitaufwändig. Vergrößert man die Kacheln,
erzeugt man aber mehr internen Verschnitt, da die jeweils letzte Seite even-
tuell nicht vollständig genutzt werden kann. Durchschnittlich bleibt hierbei
die Hälfte der Seiten ungenutzt.
Eine Verbesserung stellen die Kombination von Seitenadressierung mit Seg-
mentierung und mehrstuﬁge Seitenadressierung mit Ein- und Auslagerung
dar.

Aufgabe 4

Dateisys-
tem,
Dateiattri-
but

a) Was sind die grundlegenden Aufgaben eines Dateisystems?
b) Wie ist ein Dateisystem unter UNIX oder Windows prinzipiell struktu-

riert? Welche Verwaltungseinheiten gibt es?

c) Welche Informationen und Attribute werden zu einer Datei von einem Be-

triebssystem typischerweise verwaltet?

a) (s. [DUD], Stichwort

Dateiverwaltung“)
Dateisystem, auch Dateiverwaltung:
Komponente eines Betriebssystems, die den gesamten Speicherplatz auf Ter-
tiärspeichern verwaltet. Zu den Aufgaben der Dateiverwaltung gehört u. a.:
• Lokalisierung von Dateien, die von Benutzern der Rechenanlage ange-

”

fordert werden;

• Zuweisung von Speicherplatz an Programme, die neue Dateien anlegen

möchten;

• übersicht über die Dateien der einzelnen Benutzer sowie die im System

insgesamt vorhandenen und zur Zeit montierten Datenträger.

y

b) (für UNIX siehe hierzu Herbst 02 Thema 1 Aufgabe 3 auf Seite 237)

c) Zur Wahrnehmung der o. g. Aufgaben legt die Dateiverwaltung zu jeder
Datei eine Tabelle (den sogenannten Dateideskriptor) an, die folgende Infor-
mationen über die Datei enthält:

• den Namen der Datei
• die Adresse des Datenträgers, auf dem die Datei gespeichert ist
• die Adresse der Datei auf dem Datenträger (z. B. Spurnummer und

Sektor einer Floppy Disk),

• die Organisation der Datei (z. B. sequenziell, indexsequenziell),
• den Schutzstatus (welcher Benutzer darf auf diese Datei zugreifen?)

Aufgabe 5

kritischer
Bereich,

a) Welche Verfahren/Konzepte zur Absicherung eines kritischen Abschnitts

gibt es?

(cid:27)

------------------------------------------------------------------------
Frühjahr 07 - Thema 2

309

b) Charakterisieren Sie diese Verfahren jeweils (Vor- und Nachteile, wo werden

sie eingesetzt?)!

c) Wie funktionieren die P- und V-Operationen von Semaphoren? Skizzieren
Sie den Ablauf der Operationen in einer programmiersprachlichen Form!
Was ist bei der Implementierung der P-Operation zu beachten?

d) Skizzieren Sie in einer programmiersprachlichen Form die Abläufe in ei-

nem Erzeuger-Verbraucher-System, das die vollen und leeren Puﬀerplätze
über zählende Semaphore koordiniert!

Semaphor,
zählender
Semaphor,
Erzeuger-
Verbrau-
cher-
Problem

a)

• Aktives Warten: Ein Prozess, der nicht in seinen kritischen Bereich ein-
treten darf, überprüft in regelmäßigen Abständen, ob er weiterarbeiten
kann. Dies verschwendet sehr viel CPU-Zeit.

• Sleep & Wakeup: Prozesse, die nicht weiterarbeiten können, werden
schlafen gelegt, also inaktiv gesetzt. Erst wenn sie von einem anderen
Prozess aufgeweckt werden, können sie prüfen, ob sie weiterarbeiten
können. Prozesse können auch ewig schlafen, wenn sie von keinem an-
deren Prozess aufgeweckt werden.

• Semaphor: Ein Semaphor ist eine ganzzahlige, nichtnegative Variable
verbunden mit einer Warteschlange. Auf einen Semaphor kann nur
mit zwei Operationen zugegriﬀen werden, der Warteoperation und der
Signaloperation. Die Warteoperation wird im Allgemeinen zu Beginn
eines kritischen Abschnitts, die Signaloperation am Ende eines kriti-
schen Abschnitts ausgeführt. Der Anfangswert des Semaphors legt fest,
wie viele Prozesse sich gleichzeitig in dem kontrollierten kritischen Ab-
schnitt beﬁnden dürfen. Damit der Zugriﬀ auf die Semaphoroperationen
nicht selbst wieder zu Konﬂikten führt, müssen diese eigene kritische
Abschnitte bilden. (s. [DUD])

• Monitor: Ein Monitor verwaltet einen eigenen Speicherbereich und stellt
ihn auf Anforderung einem Prozess zur Verfügung. Zu jedem Zeit-
punkt darf höchstens ein Prozess den Monitor belegen. Die Monitor-
Operationen werden unter gegenseitigem Ausschluss ausgeführt, ohne
dass im Programmcode Synchronisationsanweisungen notiert werden
müssen. Ein Programmierer kann sich somit auf die Funktionalität des
Moduls konzentrieren und das Synchronisationsproblem außer Acht las-
sen. (s. [DUD])

b) Vorteile von Semaphoren sind, dass sie einfach und eﬃzient zu realisie-
ren sind. Außerdem muss kein aktives Warten eingesetzt werden, wodurch
der Prozessor nicht unnötig blockiert wird. Nachteile entstehen durch das
niedrige Abstraktionsniveau. Desweiteren ist die Programmierung sehr feh-
leranfällig: eine fehlende P-Operation bewirkt, dass kein wechselseitiger Aus-
schluss stattﬁndet; eine fehlende V-Operation kann zum Deadlock führen.
Insgesamt wird die Programmierung sehr unstrukturiert, da die P- und V-
Operationen über das ganze Programm verstreut sind.

(cid:28)
(cid:28)

------------------------------------------------------------------------
310

4 Betriebssysteme

Das Monitorkonzept bietet den Vorteil, dass der gegenseitige Ausschluss hier
automatisch durch den Compiler gewährleistet wird. Ein Nachteil ist, dass
Monitore von einer Programmiersprache angeboten werden müssen, d. h. der
Compiler mit dem Sprachkonstrukt Monitor umgehen können muss, während
Semaphore über Systemaufrufe realisiert werden können, wenn das Betriebs-
system Semaphore anbietet.
Setzt man zum Beispiel das Monitorprinzip zur Verwaltung eines Druckers
ein, so hat man zwar keine Warteschlange wie bei Semaphoren zur Verfügung,
aber den Vorteil, dass bei belegtem Betriebsmittel die Freigabe des Monitors
und das Warten auf das frei werden des Betriebsmittel eine atomare Einheit
bilden.
In der Realität werden Monitore oft mittels Semaphoren realisiert.

c) (s. [DUD], Stichwort

Nebenläuﬁgkeit“)

”

type semaphore = 0..n;
procedure P (var s: semaphore);
begin

if s ≥ 1 then s:= s-1;
else begin

’Stoppe den ausführenden Prozess’;
’Trage ihn in die Warteschlange W(s) ein’

end

end;

procedure V (var s: semaphore)
begin

s:= s+1
if ’Warteschlange W(s) nicht leer’ then

begin

’Wähle einen Prozess Q aus W(s) aus’;
’Springe zu der P-Operation in Q, die Q stoppte’;

end

end;

y

d) (vgl. hierzu Herbst 07 Thema 1 Aufgabe 4b) auf Seite 318)

(cid:27)

------------------------------------------------------------------------
Speicher-
verwaltung,
Seitende-
skriptor,
Seitenrah-
men,
Seiten-Ka-
chel-Ta-
belle,
Dispatch-
ing,
Seiten-
adressie-
rung

Herbst 07 - Thema 1

311

Herbst 07 - Thema 1

Aufgabe 1

Gegeben sei folgendes C-Programm:
char feld[5000];
int main() {
int i;
for (i=0); i<10000; i++) {feld[i] = ’x’; }

}

Dieses Programm wird für einen 16-Bit-Prozessor mit MMU für Seitenadres-
sierung übersetzt und gebunden. Die Seitengröße sei 4096 Byte. Der logische
Adressraum sei so organisiert, dass die erste Seite immer ungenutzt bleibt (um
Fehlzugriﬀe auf NULL-Zeiger zu erkennen). Für den Programmcode wird eine
Seite benutzt, die ggf. auch von mehreren Prozessen gemeinsam genutzt werden
kann. Die Daten liegen dahinter, der Stack wie üblich am Ende des Adressraums.
Für den Stack wird die minimal mögliche Speichermenge angelegt. Die MMU
unterstützt Zugriﬀsschutz (lesen, schreiben, ausführen) für die einzelnen Seiten,
Auslagerung von Seiten, die Bildung von Freiseitenpuﬀern und einen Clock-
(Second-Chance)-Algorithmus.

a) Beschreiben Sie den Aufbau eines Seitendeskriptors einer solchen MMU
(Skizze mit Erläuterung der verschiedenen Daten und ihrem Verwen-
dungszweck)!

b) In einer Liste freier Kacheln (Seitenrahmen) des Hauptspeichers sind aufge-
führt (jeweils die Anfangsadresse der Kachel): 0x4000, 0x7000, 0x2000,
0x9000, 0x6000, 0xa000, 0x3000. Obiges Programm wird nun geladen. Skiz-
zieren Sie den Aufbau der kompletten Seiten-Kachel-Tabelle des Prozes-
ses! (Lassen Sie in Ihrer Zeichnung um die Tabelle herum Platz für die Er-
weiterungen der Skizze in den Teilaufgaben c) und d)!)

c) Wenn der Prozess in den Zustand laufend versetzt wird, muss die MMU in
der Lage sein, die entsprechenden Adressumsetzungen vorzunehmen. Was
muss das Betriebssystem beim Dispatching tun, damit dies funktioniert?
Erweitern Sie die Skizze um die hierfür erforderlichen Elemente und mar-
kieren Sie diese mit c)!

d) Die Adresse &f eld[0] sei 0x1008. Beschreiben Sie, wie die Adressumset-
zung bei der Anweisung feld[0]=’x’; erfolgt, so dass der Wert ’x’ an eine
Stelle im Hauptspeicher des Rechners geschrieben wird! Ergänzen Sie
auch Ihre Skizze entsprechend und markieren Sie die Elemente mit d)!

e) In welcher Seite liegt die Variable i?
f) Die for-Schleife überschreitet das Ende des Feldes feld. Was hat dies für

Folgen? Bei welchem Schleifendurchlauf treten diese Folgen auf?


------------------------------------------------------------------------
4 Betriebssysteme

Im Seitendeskriptor ist natürlich die Seitenrahmenadresse enthalten. Hierbei
wird nur die physikalische Basisadresse der Seite gespeichert, die erst durch
Hinzufügen der entsprechenden logischen Adresse dann die komplette phy-
sikalische Adresse der Seite ergibt.
Das Present/Absent-Bit zeigt an, ob eine Seite momentan im Speicher liegt.
Wird auf einen Tabelleneintrag zugegriﬀen, bei dem an dieser Stelle eine 0
steht, kommt es zu einem Seitenfehler.
Die nächsten drei Bits (Schutzbits) enthalten Informationen über die lesenden
(R), schreibenden (W) und ausführenden (X) Zugriﬀsrechte auf die Seite.
Im Modiﬁed-Bit wird notiert, ob ein Programm eine Seite geändert hat. Ist
dies der Fall, so muss bei der Auslagerung der Seite das Betriebssystem den
Seitenrahmen zurückschreiben, während bei unveränderter Seite diese ein-
fach überschrieben werden kann.
Das Referenced-Bit wird bei jedem Lese- oder Schreibzugriﬀ gesetzt. Es un-
terstützt das Betriebssystem bei einigen Seitenersetzungstrategien.
Bei abgeschaltetem Caching-Bit wird nicht immer die gleiche Kopie der Re-
gister eines Gerätes im Cache benutzt, sondern bei jedem Schleifendurchlauf
der Registerinhalt neu ausgelesen; dies ist zum Beispiel bei Ein-/Ausgabe-
geräten von großer Bedeutung.

312

a)

b)

Die in Teilaufgabe a) erwähnte Basisadresse besteht jeweils aus den ersten
beiden Stellen des Adresseintrags, die letzten beiden ergeben sich durch Ad-
dition der Werte der zugehörigen logischen Adresse. Da für den Programm-


------------------------------------------------------------------------
Herbst 07 - Thema 1

313

code eine Seite genutzt werden soll, beginnen die Daten auf der zweiten Seite
(an der Stelle 7008 wegen Teilaufgabe d) und benötigen noch eine weitere
Seite, um die 5000 Feldeinträge komplett zu speichern. Wie gefordert wird
der Stack ans Ende des Adressraumes geschoben und bekommt eine Seite
zugewiesen.

c) Das Betriebssystem schreibt alle Seiten mit gesetztem Modiﬁed-Bit zurück
und ändert den Wert des Seiten-Kacheltabellen-Basisregisters (in der Graﬁk
dunkelgrau dargestellt). Dadurch wird die Startadresse für die Seitenkachel-
tabelle des alten Prozesses durch die des neuen ersetzt. Das Vorhandensein
von Code und Daten des neuen Prozesses wird vom Betriebssystem überprüft
und diese gegebenenfalls geladen.

d) Bemerkung: Da sich die Adresse 0x1008 im Programmcodebereich befände,
in den keine Daten gespeichert werden dürfen, gehen wir bei der weiteren
Lösung von der logischen Adresse 0x2008 aus.
Um feld[0] den Wert ’x’ (wohl den ASCII-Wert für x, also 120) zuzuordnen,
muss der zugehörigen Speicherzelle der Wert zugewiesen werden. Zuerst wird
die logische Adresse 2008, wie in der Graﬁk hellgrau dargestellt, umgesetzt
in die physikalische Adresse von feld[0] - hier 7008. Dort wird dann der Wert
120 eingetragen.

e) Als lokale Variable wird i auf dem Stack gespeichert, liegt hier also auf der

Seite 0x9xxx und wird wie alle Integerwerte in 2 Byte gespeichert.

f) Im 5001. Schleifendurchlauf ist i=5000 (0x1388). Es müsste nun feld[5000]
mit ’x’ gefüllt werden. Da zwar das Feld selbst nur 5000 Einträge hat, aber
die gesamte Seite 0x2xxx für Daten reserviert ist, beschreibt das Betriebssy-
stem einfach nach dem letzten Feldeintrag die nächsten Speicherzellen 2390
bis 2FFF mit ’x’. Dann gilt i = 8192 (2 Seiten) - 8 (Startbytes s. Anga-
be) + 1 (folgender Schleifendurchlauf) = 8185. In diesem Schleifendurchlauf
müsste auf eine dritte Seite zugegriﬀen werden, die nicht alloziert wurde -
das Betriebssystem liefert einen segmentation fault.


------------------------------------------------------------------------
UNIX-Da-
teisystem,
Hard-Link,
Symbolic-
Link

314

4 Betriebssysteme

Aufgabe 2

a) Hinter der hierarchischen Sicht auf ein Dateisystem wie es typischerweise
unter UNIX oder WindowsNT eingesetzt wird, verbirgt sich ein einfach
strukturierter ﬂacher Namensraum (die eigentlichen
Namen“ sind die
”
Inode-Nummern unter UNIX bzw. die Indizes in die Master-File-Table
bei WindowsNT). Beschreiben Sie für ein solches Dateisystem Ihrer Wahl,
wie das Betriebssystem es organisiert, dass der Inhalt der Datei
/home/user/datei1 bzw. \home\user\datei1 (Dateigröße sei ca.
1MByte) aufgefunden werden kann! Skizzieren Sie hierzu alle Datenstruktu-
ren, die hierfür auf dem Hintergrundspeicher angelegt sind, und beschrei-
ben Sie für jeden Typ einer solchen Datenstruktur, wofür sie konzeptio-
nell vorgesehen ist!

b) Zu jeder Datei verwaltet das Betriebssystem eine Menge von Attributen.

Wo werden diese Attribute verwaltet?

c) Beispiele für solche Dateiattribute sind: Dateityp, Zugriﬀsrechte, Dateigrö-
ße, Zeit der letzten änderung, Zeit des letzten Zugriﬀs, Link-Zähler und
Eigentümer. Beschreiben Sie für jedes dieser Attribute jeweils möglichst
ausführlich, wofür das Betriebssystem das Attribut verwaltet (was sagt
das Attribut im Detail aus, in welchen Situationen ändert es sich ggf.,
auf welche Operationen hat es Auswirkungen etc.)!

d) UNIX- und auch neuere Versionen von WindowsNT-Dateisystemen unter-
Symbolic-Links“. Was ist der Unter-
”

scheiden zwischen
schied und warum benötigt man diese unterschiedlichen Arten von Links?

Hard-Links“ und
”

a)

Mit Hilfe von I-Nodes wird eine strikte Tren-
nung von Dateiinhalt und Verwaltungsinfor-
mationen (Dateityp, Dateigröße, Eigentümer,
Gruppe, Zugriﬀsrechte, etc.) erreicht. In der
Graﬁk links ist z. B. ein System dargestellt,
bei dem jeder I-Node 10 Felder für direk-
te Adressierung von Datenblöcken enthält,
während die restlichen drei zur indirekten
Adressierung dienen.
Um den Inhalt der Datei /home/user1/datei1
zu ﬁnden, muss zuerst der I-Node für das root-
Verzeichnis (2) gelesen werden. Anschließend
werden die Datenblöcke (hier 13) und nach
dem nächsten geforderten Eintrag (hier ho-
me) durchsucht. Ist der zugehörige I-Node (z.
B. 3) gefunden, wird analog vorgegangen, um
die jeweilig passenden I-Nodes für user1 (z. B.
8) und schließlich datei1 (z. B. 6) zu ﬁnden.
Anschließend kann dann der hierzu gehörige
Datenblock gelesen werden.


------------------------------------------------------------------------
Herbst 07 - Thema 1

315

b) im zugehörigen I-Node

c)

Dateityp

Zugriﬀsrechte

Dateigröße

in welchem Format
Hier wird angegeben,
üblichen“: Verzeichnis,
(zusätzlich zu den
”
Gerät,...) die Datei vorliegt. Um insbesonde-
re die UNIX-speziﬁschen
Dateitypen“ korrekt
”
und schnell ansprechen zu können, muss die-
se Information hier verwaltet werden. Der Typ
ändert sich im allgemeinen nicht.
Hier wird angegeben, wer
(Gruppe, Ei-
gentümer, alle) welche Art von Zugriﬀ (Le-
sen, Schreiben, Ausführen) auf diese Datei hat.
Die einmal
festgelegten Rechte werden ggf.
z. B. während eines schreibenden Zugriﬀs im
Mehrbenutzerbetrieb für die anderen Benutzer
geändert.
Dieses Attribut bleibt beim lesenden Zugriﬀ
auf die Datei gleich und wird beim schreiben-
den Zugriﬀ evtl. geändert. Das Betriebssystem
verwendet diesen Wert für die Verwaltung der
Speicherung der Datei.

Zeit des letzten Zugriﬀs

Zeit der letzten änderung Das Betriebssystem verwendet diese Informa-
tion zur Synchronisation im Mehrbenutzerbe-
trieb. Eine änderung dieses Wertes erfolgt bei
jedem schreibenden Zugriﬀ.
Das Betriebssystem kann diesen Wert verwen-
den, um die Verwaltung nicht genutzter Datei-
en und die Identiﬁzierung von
Dateileichen“ zu
”
realisieren. Dieses Attribut wird auch bei jedem
lesenden Zugriﬀ geändert.
Gibt die jeweils aktuelle Anzahl der Hard-
Links auf diese Datei an. Löschung der Da-
tei
ist erst möglich, wenn dieser Wert beim
Rückwärtszählen gleich Null ist.
Das Betriebssystem benötigt diesen Eintrag,
um die Zugriﬀsrechte korrekt zu verwalten und
z. B. nur dem Eigentümer das Löschen einer
Datei zu gestatten.

Eigentümer

Linkzähler


------------------------------------------------------------------------
316

4 Betriebssysteme

d) symbolische Links

enthalten einen Verweis auf einen
Verzeichniseintrag
können von einem Dateisystem in
andere verweisen
beim Löschen wird nur der Link
gelöscht, keine Daten

Hardlinks
enthalten einen Verweis auf einen I-
Node
sind nur innerhalb eines Dateisy-
stems einsetzbar
falls es sich um den letzten Hardlink
auf eine Datei handelt, wird diese
komplett gelöscht - genau, wie der
zugehörige I-Node

Aufgabe 3

Scheduling-
verfahren

a) Nach welchen Kriterien kann man Auswahlstrategien zur Prozessorvergabe

(Scheduling) klassiﬁzieren?

b) Welche Strategie würden Sie für das Scheduling in einem Betriebssystem
einsetzen, das für die überwachung und Steuerung von Abläufen in einem
Kernkraftwerk eingesetzt ist? Welche Parameter sind hierbei für die Sche-
dulingstrategie primär entscheidend und wie werden sie in der von Ihnen
gewählten Strategie eingesetzt?

c) Welche Strategie wird heutzutage üblicherweise in Mehrbenutzer-/Mehrpro-
gramm-Betriebssystemen wie z. B. UNIX eingesetzt? Welche Ziele werden
mit solch einer Strategie verfolgt? Bei solch einer Strategie spielen mehre-
re Parameter eine Rolle - teilweise haben diese Parameter sehr gegensätz-
liche Wirkungen. Beschreiben Sie die Parameter und ihre Wirkung auf
das Systemverhalten!

a) Ein Merkmal von Scheduling-Verfahren ist, ob sie unterbrechend sind. Bei
nicht unterbrechenden Verfahren laufen Prozesse bis zur Terminierung oder
Blockade, während bei unterbrechenden Verfahren, wie z. B. Round Robin
jedem Prozess nur ein Zeitslot zugeteilt wird und danach ein Prozesswechsel
stattﬁndet, obwohl der Prozess weiterhin laufbereit wäre.
Ein weiteres Kriterium ist die Vergabe von Prioritäten. Bei einer solchen
Einteilung werden wichtigere Prozesse bevorzugt und unwichtigere müssen
länger warten. Die Vergabe der Prioritäten kann statisch oder dynamisch er-
folgen. Statisch bedeutet hierbei, dass der Prozess, wenn er das erste Mal in
den Zustand bereit kommt, eine Priorität bekommt und diese sich dann nicht
mehr ändert. Bei dynamischer Prioritätenvergabe werden die Prioritäten
nach bestimmten Kriterien während der Prozessausführung geändert (z. B.
verbrauchte CPU-Zeit). Weiterhin kann bei prioritätenbasiertem Scheduling
zwischen verdrängenden und nicht verdrängenden Verfahren unterschieden
werden. Bei nicht verdrängenden Verfahren wird ein Prozess gemäß seiner
Priorität in die Warteschlange eingereiht. Im anderen Fall kann es passie-
ren, dass ein neuer Prozess mit der aktuell höchsten Priorität den gerade
laufenden Prozess von der CPU verdrängt.


------------------------------------------------------------------------
Herbst 07 - Thema 1

317

b) Es handelt sich hierbei um ein Echtzeit-System. Deshalb sind Prioritäten für
die einzelnen Prozesse wichtig. Es gibt Prozesse, die innerhalb einer gewissen
Zeitspanne ausgeführt werden müssen, es muss also eine Deadline eingehalten
werden.

c) (siehe [TAN] S. 753ﬀ

Scheduling in UNIX“)

”

UNIX verwendet einen zweistuﬁgen Algorithmus. Die höhere Ebene dient
dazu, die Prozesse zwischen Speicher und Platte zu transportieren und da-
mit zu gewährleisten, dass jeder Prozess einmal in den Speicher gelangt.
Die niedrigere Ebene verwaltet alle bereiten Prozesse, die auch im Spei-
cher liegen müssen. Hier werden dynamisch Prioritäten vergeben und für
jede Prioritätsklasse gibt es eine eigene Warteschlange. Innerhalb der War-
teschlangen wird mit Round Robin gearbeitet. Dieses Scheduling-Verfahren
wird auch mit multi-level-feedback-scheduling bezeichnet. (multi-level, weil
zweistuﬁg, feedback, weil die Prozesse ein Feedback bekommen, indem ihre
Prioritäten angepasst werden.) Der Scheduler durchsucht alle Prioritäten-
klassen aufsteigend (die niedrigsten Nummern haben die höchste Priorität)
bis er eine Warteschlange ﬁndet, die nicht leer ist. Dort arbeitet er den er-
sten Prozess mit der Zeitscheibe z. B. 100ms ab und dieser Prozess reiht sich
wieder hinten ein.
Prozesse im Kernmodus bekommen negative Prioritätswerte zugeteilt, Pro-
zesse im Benutzermodus positive.
Durch die Verwendung von Round Robin können mehrere Programme/Be-
nutzer gleichzeitig Prozesse laufen lassen. Bei einer FIFO-Warteschlange
könnte es passieren, dass einzelne Benutzer sehr lange Wartezeiten hätten
während bei Round Robin alle Prozesse gleichgestellt sind.
Um zu vermeiden, dass sehr unwichtigen Prozessen sehr viel CPU-Zeit zu-
geteilt wird, muss man vermeiden, dass allen Prozessen die gleiche Priorität
eingeräumt wird. Damit laufende Prozesse im Kernmodus möglichst schnell
aus dem Kern wieder entfernt werden können, werden die Prioritäten dy-
namisch angepasst. Prozesse, die fast vollständig abgearbeitet sind, erhalten
eine höhere Priorität.
Wichtige Parameter bei dieser Strategie sind die Zeitscheibe von Round
Robin und die Zeitdauer für einen Prozesswechsel. Wird bei Round Ro-
bin die Zeitscheibe zu kurz gewählt, ist die CPU mehr mit Prozesswechseln
beschäftigt als mit den eigentlichen Rechenoperationen. Wird die Zeitscheibe
hingegen zu lange gewählt, mutiert Round Robin zu FIFO und die Prozesse
am Ende der Warteliste haben wieder relativ lange Wartezeiten.

Aufgabe 4

Zwei Threads implementieren ein klassisches Erzeuger-Verbraucher-System:
Thread T1 liest von einem Eingabekanal (blockierendes Lesen, falls dort gerade
keine Daten anstehen) und schreibt die Daten in einen Ringpuﬀer. Thread T2
entnimmt die Daten aus dem Ringpuﬀer und gibt sie auf einem Ausgabekanal
aus.

Thread,
Erzeuger-
Verbrau-
cher-
Problem,
User-Level-
Thread,

(cid:28)

------------------------------------------------------------------------
318

4 Betriebssysteme

Kernel-Le-
vel-Thread

a) Wählen Sie zur Synchronisation der beiden Threads ein geeignetes Verfah-

ren und begründen Sie diese Wahl kurz!

b) Skizzieren Sie in einer Programmiersprache Ihrer Wahl die Funktion

producer(), die die Aufgabe von Thread T1 realisiert, sowie eine Funktion
consumer(), die die Aufgabe von Thread T2 realisiert!

c) Warum funktioniert die beschriebene Aufgabe mit User-Level-Threads nicht
einwandfrei, sondern nur mit Kernel-Level-Threads? Beschreiben Sie hierzu
kurz den grundsätzlichen Unterschied zwischen den beiden Kategorien und
arbeiten Sie dabei heraus, welcher Umstand das korrekte Verhalten des be-
schriebenen Erzeuger-Verbraucher-Szenarios verhindert!

a) Um die Koordination der beiden Threads zu organisieren, damit sie nicht
gleichzeitig auf die gleiche Stelle im Ringpuﬀer zugreifen, können Semapho-
ren verwendet werden. Dadurch kann gewährleistet werden, dass immer nur
ein Thread auf den Puﬀer zugreift.

b) (siehe hierzu [DUD] Stichwort

Nebenläuﬁgkeit“)

”

void producer()
{

while (TRUE)
{

’Erzeuge Datum’;
P(nichtvoll);

//ein Datenelement wird erzeugt
//Zähler für freie Plätze wird
//erniedrigt
//exklusiver Zugriff auf Puffer

P(gesperrt);
’Schreibe Datum in Puffer’;
V(gesperrt);
V(nichtleer);

//Puffer freigeben
//belegte Plätze erhöhen

void consumer()
{

while (TRUE)
{

P(nichtleer);

}

}

}

}

//Zähler für belegte Plätze wird
//erniedrigt
//exklusiver Zugriff auf Puffer

P(gesperrt);
’Entnimm Datum aus Puffer’ ;
V(gesperrt);
V(nichtvoll);
’Verarbeite Datum’

//Puffer freigeben
//freie Plätze erhöhen

(cid:27)

------------------------------------------------------------------------
Herbst 07 - Thema 2

319

c) User-Level-Threads werden nur auf der Anwendungsebene realisiert, das Be-
triebssystem sieht nur einen Thread, auch wenn er eigentlich aus mehreren
besteht. Blockiert ein Thread innerhalb einer Gruppe, so sind alle anderen
auch blockiert. Wenn nun Thread T1 in den Zustand
blockierendes Le-
”
sen“ kommt, wird Thread T2 ebenfalls blockiert. Bei Kernel-Level-Threads
managed das Betriebssystem die einzelnen Threads. Ein blockierender Sy-
stemaufruf blockiert nur diesen einen Thread und hat keine Auswirkungen
auf die übrigen Threads. Für Kernel-Level-Threads muss das Betriebssy-
stem angepasst/erweitert werden, während User-Level-Threads auf jedem
System realisiert werden können. Der Wechsel zwischen User-Level-Threads
ist schneller, da hierfür nicht in den Kern gewechselt werden muss.

Herbst 07 - Thema 2

Aufgabe 1

Scheduling-
verfahren,
FCFS,
SJF,
Preemptive
SJF, RR,
Multi-Le-
vel-Sche-
duling,
Gantt-Dia-
gramm

Die folgenden drei Jobs stehen zu den angegebenen Zeiten (in Minuten) zur
Ausführung an:

Job Ankunftszeit Bearbeitungsdauer

1
2
3

0
4
10

20
10
6

2.1. Stellen Sie die zeitlichen Abläufe in Gantt-Diagrammen (Balkendiagramme

über der Zeitachse) dar und berechnen Sie dazu den Turnaround eines je-
den Jobs, sowie den Average Turnaround bei den folgenden Scheduling-
Strategien:

• First-Come-First-Served (FCFS)
• Shortest-Job-First (SJF)
• Preemptive Shortest-Job-First (Preemptive SJF)
• Round-Robin (RR) mit Zeitquantum q = 8

2.2. Zusätzlich zu den obigen Jobs 1 bis 3 (von der Kategorie Batch) sollen zu

den Zeitpunkten 6 und 12 die Jobs Nummer 4 und 5 (von der Kategorie In-
teractive) mit jeweils einer Laufzeit von 10 Zeiteinheiten zur Bearbeitung
anstehen. Nun soll eine Multi-Level-Scheduling-Strategie verfolgt werden
derart, dass jeweils eine Warteschlange für die Kategorien Interactive und
Batch existiert, wobei das Scheduling bei interaktiven Jobs mit dem
Round-Robin-Verfahren mit Zeitquantum q = 4 und bei den Batch-Jobs
nach FCFS abläuft. Die Warteschlange der interaktiven Jobs hat Priori-
tät über die Warteschlange der Batch-Jobs, d. h. falls gerade ein Batch-
Job bearbeitet wird und es kommt ein neuer interaktiver Job an, so wird
der Batch-Job solange angehalten, bis keine interaktiven Jobs mehr im Sys-
tem sind. Geben Sie die Wartezeit eines jeden Jobs an!


------------------------------------------------------------------------
320

1.1) FCFS:

4 Betriebssysteme

durchschnittlicher Turnaround: 24

SJF:

durchschnittlicher Turnaround: 22,7

PSJF:

durchschnittlicher Turnaround: 18,7

RR:

durchschnittlicher Turnaround: 28

1.2)


------------------------------------------------------------------------
Herbst 07 - Thema 2

321

Aufgabe 2

Sie sind gerade an einen neuen Wohnort gezogen und wollen dies nun dort
bei der zuständigen Meldebehörde anzeigen. Bei dieser Meldebehörde gibt es
einen Warteraum, der maximal 20 Personen fasst. Sobald Sie in den Warteraum
eintreten können, ziehen Sie aus einem Automaten eine fortlaufend vergebene
Nummer, mit der Sie später von einem der drei Schalter aus aufgerufen werden.
Ein Schalterbeamter wählt jeweils aus den (maximal 20) wartenden Personen
diejenige mit der niedrigsten Nummer aus und bearbeitet diese Anmeldung
vollständig.
Implementieren Sie Ihr obiges Vorgehen zur Anmeldung und die Arbeit eines
Schalterbeamten in Pseudo-Code! Die Synchronisation der beteiligten Prozesse
soll ausschließlich über allgemeine Semaphore (Counting Semaphore) geschehen.
Hinweis: Die obige Aufgabenstellung beinhaltet im Wesentlichen ein Erzeuger-
Verbraucher-Schema mit beschränktem Puﬀer.

Semaphor,
Erzeuger-
Verbrau-
cher-
Problem

(s. [DUD], Stichwort
var frei,

”

Nebenläuﬁgkeit“)

besetzt,
gesperrt : semaphore;

frei := 20;
besetzt := 0;
gesperrt := 1;

neuePerson {
while TRUE {

’Ziehe Nummer’;
frei.down();
gesperrt.down();
’gehe in Wartehalle’
gesperrt.up();
besetzt.up();
}

}

Schalterbeamter {
while TRUE {

besetzt.down();
gesperrt.down();
’Rufe Person mit niedrigster Nummer auf’
gesperrt.up();
frei.up();
’bearbeite Antrag’
}

}

(cid:28)

------------------------------------------------------------------------
322

4 Betriebssysteme

Aufgabe 3

Speicher-
verwaltung,
First Fit,
Best Fit,
Worst Fit

In der Freispeicherliste zu einem Arbeitsspeicher existieren die freien Blöcke in
der angebenen Reihenfolge mit den Größen:
10KB, 4KB, 20KB, 9KB, 12KB
Geben Sie für jeden Vergabeschritt die verbleibenden freien Speicherblöcke für
die Anfragen an (ebenfalls in dieser Reihenfolge) nach Blöcken der Größe:
12KB, 10KB, 9KB
Verwenden Sie dabei die folgenden Speichervergabe-Verfahren:
3.1) First-Fit
3.2) Best-Fit
3.3) Worst-Fit

3.1) First-Fit:

Segment:
12KB
10KB
9KB

10KB 4KB 20KB 9KB 12KB
8KB

0KB

0KB

3.2) Best-Fit:

Segment:
12KB
10KB
9KB

10KB 4KB 20KB 9KB 12KB
0KB

0KB

0KB

3.3) Worst-Fit:

Segment:
12KB
10KB
9KB

10KB 4KB 20KB 9KB 12KB
8KB

2KB

1KB


------------------------------------------------------------------------
Frühjahr 08 - Thema 1

323

Frühjahr 08 - Thema 1

Aufgabe 1

Speicher-
verwaltung,
Seitenrah-
men,
Seiten-Ka-
chel-Ta-
belle,
Seiten-
adressie-
rung,
Prozesszu-
stand

In einem System mit Seitenadressierung (paged adress space), Adresslänge =
16 Bit, Seitengröße = 4KByte, Hauptspeichergröße = 64 KByte wird ein Pro-
gramm durch einen Prozess ausgeführt zur Erinnerung: 409610 = 100016).
Die erste Seite des virtuellen Adressraums wird nicht genutzt. Das Textsegment
des Prozesses umfasst 2 Seiten, das Datensegment umfasst ebenfalls 2 Seiten,
direkt im Anschluss daran. Das Stack-Segment umfasst eine Seite ganz am Ende
des virtuellen Adressraums. Die Seiten des Textsegments liegen im Hauptspei-
cher in den Seitenrahmen (=Kacheln) auf Adresse 0x4000 und 0x7000, die erste
Seite des Datensegments liegt in Seitenrahmen 0x6000, die zweite Seite ist aus-
gelagert und liegt auf der Platte im Block 0x37000. Die Seite des Stacks liegt im
Seitenrahmen 0x9000. Das (sehr kleine) Betriebssystem belegt die ersten 4 Sei-
tenrahmen. Die Seitenrahmen von 0xa000 bis 0xf000 sind durch einen anderen
Prozess belegt.
1. Skizzieren Sie den Aufbau des virtuellen Adressraums des Prozesses sowie

den Aufbau und die Belegung des Hauptspeichers und die Abbildungen da-
zwischen!

2. Die Seiten des Textsegments seien read-only in den Adressraum abgebildet,
alle anderen Seiten zum Lesen und Schreiben. Die Ausführung von Maschi-
nenbefehlen aus dem Daten- oder Stack-Segment ist nicht zulässig.
Skizzieren Sie die Datenstrukturen, die die MMU für die Umsetzung des be-
schriebenen virtuellen Adressraums benötigt und wie dabei die logische
Adresse 0x3240 umgesetzt wird!

3. In dem Programm stehen folgende Anweisungen:

void f1() {

static int *p = (int *)0x4018;
int i;
...
*p = 41;
i = 5;
...

Beschreiben Sie, was bei der Ausführung des Prozesses passiert, wenn er
die beiden obigen Zuweisungen ausführt:

a) Welche Aktivitäten laufen der Reihe nach in der Anwendung und im

Betriebssystem ab? (Nummerieren Sie diese Schritte!)


------------------------------------------------------------------------
4 Betriebssysteme

b) Welche Wechsel des Prozesszustandes ﬁnden hierbei bei welchen

Schritten statt?

c) Tragen Sie in Ihre Skizzen zu den Teilaufgaben 3a) und 3b) die ände-
rungen ein, die im Laufe der Ausführung der Anweisungen erfolgen,
und markieren Sie die entprechenden Stellen mit c)! Tragen Sie auch
die Orte ein (ungefähr), an denen die Werte 41 und 5 im Hauptspei-
cher hingeschrieben werden!

324

1.

(Siehe Graﬁk!)
Die Informationen über die Zugriﬀsrechte sind zusätzlich in den in der Seiten-
Kachel-Tabelle aufgeführten Seitendeskriptoren enthalten.
Die logische Adresse 0x3240 wird so abgebildet, dass zuerst wegen der 3 auf
den Eintrag 3 in der Seiten-Kachel-Tabelle zugegriﬀen wird. Dort erfährt
das System dann, dass die zugehörige Seite präsent ist und dass sowohl ein
Lese- auch ein Schreibzugriﬀ möglich ist. Um die Adresse im Hauptspeicher
zu berechnen, wird die 0x6000 addiert mit der 0x0240 (hinterer Teil der
logischen Adresse), was schließlich zur Adresse 0x6240 führt.


------------------------------------------------------------------------
Frühjahr 08 - Thema 1

325

2.

a) Schritt 1: Der Zahl 0x4018 wird die Seitennummer 4 entnommen.

Schritt 2: In der Seitenkacheltabelle wird im Deskriptor der entspre-
chenden Seite festgestellt, dass diese momentan nicht präsent ist, son-
dern im Hintergrundspeicher ausgelagert ist.
Schritt 3: Um die Seite (wieder) einlagern zu können wird ein passender
Platz im Hauptspeicher gesucht (z. B. 0x5xxx).
Schritt 4: Jetzt wird die Seite eingelagert und dazu die Seiten-Kachel-
tabelle angepasst.
Schritt 5: Der Versatz und der Inhalt der Seiten-Kachel-Tabelle werden
addiert und man erhält die Adresse 0x5018.
Schritt 6: Sowohl für *p (ab 0x5018) als auch für die Integervariable i
(auf dem Stack ab 0x9000) wird jetzt Speicherplatz alloziert.
Schritt 7: Nun werden der Wert für i und die Zahl 41 für *p an den
jeweiligen Stellen gespeichert.

b) Bei Schritt 2 wird der Prozess blockiert, das Betriebssystem übernimmt
die Kontrolle. Nach Schritt 4 wird der schlafende Prozess in den Zustand
bereit überführt und das Programm übernimmt wieder die Kontrolle.

c) (Siehe Graﬁk in Teilaufgabe a)!)

Die 41 wird nach der Stelle 0x5018 im Hauptspeicher abgelegt, 5 wird
in den Bereich 0x9xxx geschrieben.

Aufgabe 2

1. Welche Bedingungen müssen gegeben sein, damit eine Verklemmung auftre-

ten kann?

2. Welche drei grundsätzlichen Verfahren gibt es, um mit der Verklemmungs-

problematik umzugehen?

a) Beschreiben Sie jedes Verfahren! Wie ist jeweils die grundsätzliche

Vorgehensweise?

b) Geben Sie ein Beispiel für einen Algorithmus an, der bei einem -
dieser Verfahren zum Einsatz kommt und beschreiben Sie den
Algorithmus!

Verklem-
mung,
sicherer
Zustand,
Banker’s
Algorith-
mus

Siehe Frühjahr 07 Thema 1 Aufgabe 3 auf Seite 302!)

x


------------------------------------------------------------------------
326

4 Betriebssysteme

Aufgabe 3

Dateisys-
tem

Für die folgenden Teilaufgaben 3, 4 und 5 wird das Datensicherungs- und Ar-
chivsystem eines Unternehmens betrachtet. Hierzu besitzt das unternehmens-
eigene Rechenzentrum einen Bandroboter mit fünf Bandlaufwerken und einem
Regallager für die Bänder. Das System wird zur täglichen Datensicherung sowie
zur gezielten Archivierung von Datenbeständen genutzt.
a) Wie würden Sie den Dateibestand eines großen Softwareentwicklungspro-

jekts auf der Festplatte organisieren, damit die Programmquellen (mehrere
Anwendungsprogramme sowie Funktionsbibliotheken), die Dokumentation,
sowie mehrere, aktuell an Kunden ausgelieferte Binärversionen der Soft-
ware sowohl als Ganzes, als auch in den beschriebenen Teilen einfach ar-
chiviert werden können? Erläutern Sie Ihre Entscheidung am besten an-
hand einer Skizze!

b) Welche Informationen über Dateien bzw. über Kataloge würden Sie archi-

vieren? Wozu werden welche Informationen im Archiv bzw. bei oder
nach einem Restaurieren des Archivs benötigt?

a) Hierfür eignet sich am Besten ein hierarchisches Dateisystem. Die Dateien
werden dort nach ihrem Inhalt und nicht z. B. nach ihrem Erzeugungsdatum
sortiert abgelegt.

b) Siehe Frühjahr 06 Thema 1 Aufgabe 1d) auf Seite 275


------------------------------------------------------------------------
Prozess,
Thread,
Ringpuﬀer,
logische,
physi(kali-)
sche
Adresse

Frühjahr 08 - Thema 1

Aufgabe 4

327

Da von modernen Plattensystemen schneller gelesen wird, als auf ein Bandgerät
geschrieben werden kann, sollen die Daten auf mehrere Bänder parallel geschrie-
ben werden. Hierzu soll das Archivierungsprogramm folgendermaßen organisiert
werden:

• Ein Prozess P0 leistet die oben in Teilaufgabe 3 beschriebene Funktionali-
tät und schreibt die Daten in einen großen Speicherbereich (10MB), der
in Blöcken zu je 1MB organisiert ist und als Ringpuﬀer betrieben wird.

• Für jedes Bandgerät i (i=1...5) gibt es einen Prozess Pi, der jeweils

den nächsten verfügbaren Block aus dem Ringpuﬀer entnimmt und auf
das Bandgerät schreibt.

1. Wie kann der Ringpuﬀer als gemeinsamer Speicher in einem Betriebssys-
tem mit Seitenadressierung realisiert werden? In welchen Datenstruktu-
ren müssen hierzu welche Einträge erfolgen?

2. Skizzieren Sie die logischen Adressräume der Prozesse P0 und P1 und den

Zusammenhang zu dem physikalischen Hauptspeicher!

3. Die beschriebene Realisierung mit Hilfe von Prozessen ist teuer. Wodurch

entstehen diese Kosten (Speicher, Laufzeit)?

4. Eine Realisierung mit Hilfe von Threads wäre günstiger. Welche Arten

von Threads kennen Sie, wodurch unterscheiden sie sich, was ist der Un-
terschied zu Prozessen?

5. Welche Thread-Art ist für die beschriebene Aufgabe geeignet und sollte
statt einer Realisierung mit Prozessen genutzt werden? Welche Kosten
spart man dadurch ein, welche Abläufe werden eﬃzienter?

6. Warum ist die andere Thread-Art für die Aufgabe nicht geeignet?

1. Siehe Frühjahr 06 Thema 1 Aufgabe 2a) auf Seite 276!

2. Siehe Frühjahr 06 Thema 1 Aufgabe 2b) auf Seite 276!

3. Da viele Betriebsmittel zur Verwaltung (wie z. B. Dateideskriptoren, Pro-
zesskontrollblöcke) eines Prozesses notwendig sind und beim Prozesswech-
sel jeweils ganze Speicherbereiche und der Adressraum abgebildet werden
müssen, sind Prozessumschaltungen sehr aufwändig. Die hohen Kosten ent-
stehen im Hinblick auf den Speicher an mehreren Stellen, da Prozesse z.
B. keinen gemeinsamen Adressraum und andere gemeinsame Datenbereiche
nutzen. Außerdem entstehen dann wegen der daraus resultierenden höheren
Umschaltzeiten auch Kosten im Hinblick auf die Laufzeit.

4. Siehe Frühjahr 07 Thema 1 Aufgabe 2c) auf Seite 300 und Frühjahr 07 The-

ma 2 Aufgabe 1a) auf Seite 304!

5. User-Level werden vom Prozessor als ein einziger Thread gesehen. Dadurch
werden immer alle Threads gleichzeitig blockiert und eine parallele Program-
mierung ist nicht möglich. Somit sollten hier Kernel-Level-Threads eingesetzt

x

x

x


------------------------------------------------------------------------
328

4 Betriebssysteme

werden. Außerdem kennt das Betriebssystem die Kernel-Level-Threads und
schaltet zwischen ihnen um. Dies ist kostengünstiger als die Prozessumschal-
tung, da kein Adressraumwechsel vorgenommen werden muss.

6. Erzeugung und Umschaltung sind bei User-Level-Threads zwar extrem billig,
aber wie oben beschrieben wird zwischen ihnen nicht durch das Betriebssy-
stem, sondern durch das Anwendungsproramm umgeschaltet - das Betriebs-
system betrachtet sie als Einheit und blockiert im Bedarfsfall die gesamte
Einheit.

Aufgabe 5

Prozess,
Thread,
Ringpuﬀer,
Verklem-
mung

Unter der Annahme, dass mehrere Archivierungen bzw. Restaurierungen gleich-
zeitig anfallen können und dabei jeweils parallel zwei bis fünf Laufwerke genutzt
werden, gibt es eine ganze Reihe von Koordinierungsproblemen:

• Zugriﬀ auf einzelne Bänder
• Zugriﬀ auf Bandlaufwerke
• Zugriﬀ auf Ringpuﬀer
1. Welche Art von Koordinierungsproblem liegt in den obigen drei Situationen

jeweils vor?

2. Die Archivierung von vier unterschiedlichen Softwareprojekten wird fast
gleichzeitig gestartet. Entsprechend der Aufgabe 4 soll jeweils auf drei
Laufwerken parallel geschrieben werden. Welche Problematik hinsichtlich
Verklemmungen existiert hier?

3. Nennen Sie zwei unterschiedliche Maßnahmen zur Verklemmungsvorbeu-
gung im obigen (in Teilaufgabe 2 beschriebenen) Szenario! Welche der
für Verklemmungen notwendigen Bedingungen werden dadurch jeweils
entkräftet?

4. Skizzieren Sie in einer programmiersprachen-ähnlichen Form zwei Funktio-

nen put und get, die den Zugriﬀ auf den Ringpuﬀer realisieren!

1.

• Da jedes Band jeweils nur von einem Bandlaufwerk gleichzeitig belegbar

ist, herrscht hier exklusiver Ausschluss.

• Ein vom Prozess Pi aus dem Ringpuﬀer entnommenes Datenpaket wird
an das i-te Bandlaufwerk weitergeleitet. Wir nehmen an, das Bandlauf-
werk besitze genau genug Speicherplatz für ein Datenpaket. Pi dürfte
zwar sofort das nächste Datenpaket vom Ringpuﬀer entnehmen, aber
bei einer konkreten Umsetzung mit Semaphoren würde wegen möglichst
geringer Blockade-Zeit ein Zugriﬀ erst dann möglich sein, wenn das Da-
tenpaket vom Bandlaufwerk aufs Band geschrieben worden ist und das
Bandlaufwerk wieder ein neues Datenpaket aufnehmen kann.

• Der Prozess Pi löscht ein Datenpaket vom Ringpuﬀer und übergibt
es an ein Bandlaufwerk. Der Prozess kann nun zwar sofort wieder ein


------------------------------------------------------------------------
Frühjahr 08 - Thema 2

329

Datenpaket am Ringpuﬀer entnehmen, muss aber ggf. warten, bis das
Bandlaufwerk wieder aufnahmefähig ist. Beim Ringpuﬀer selbst ent-
steht zusätzlich dadurch ein klassisches Erzeuger-Verbraucher-Problem,
dass P0 Daten evtl. schneller erzeugt, als die Pi diese wieder entfernen.
2. Das hier beschriebene Szenario stellt im Prinzip ein abgewandeltes Philo-

sophen-Problem (siehe Herbst 06 Thema 1 Aufgabe 2a) auf Seite 287) dar. x
Hier benötigen 4 Prozesse (
Philosophen“) gleichzeitig die drei Laufwerke
”
(
Gabeln“) und somit geht einer leer aus. Wenn immer der selbe Prozess
”
warten muss, kann er

aushungern“, also seine Daten nie sichern.
”

3. Eine Möglichkeit der Verklemmungsvermeidung ist es, die vier Prozesse durch-

zunummerieren und den Laufwerken fest zuzuordnen.
Die Bedingung der exklusiven Belegung könnte man dadurch beheben, dass
jeder Prozess das Laufwerk nur für eine bestimmte Datenmenge oder Zeit-
einheit zugeteilt bekommt.

4. Mit entsprechend geänderter Puﬀergröße ﬁndet sich eine Lösung in Frühjahr

03 Thema 2 Aufgabe 5 auf Seite 245.

x

Frühjahr 08 - Thema 2

Aufgabe 1

UNIX-Filesysteme implementieren das Konzept der I-Nodes. Dabei ﬁndet eine
strikte Trennung des eigentlichen Dateiinhalts von den Verwaltungsinformatio-
nen (z. B. Dateigröße, Dateityp, Eigentümer, Gruppe, Zugriﬀsrechte) statt. Die
Anzahl der I-Nodes sowie die Größe der Blöcke werden bei der Formatierung
des Dateisystems festgelegt.

UNIX-Da-
teisystem,
Hard-Link,
Symbolic-
Link


------------------------------------------------------------------------
330

4 Betriebssysteme

Gehen Sie in dieser Aufgabe von folgenden Annahmen aus:
• Jeder I-Node enthält 10 Felder für direkte Adressen auf Datenblöcke der Da-
tei, sowie jeweils einen Verweis auf den ersten, zweiten und dritten Indirekt-
ionsblock - insgesamt also 13 Adressfelder (siehe Graﬁk).

• Der erste Indirektionsblock (Indirektionsblock erster Stufe) enthält Adres-
sen von Datenblöcken. Der zweite Indirektionsblock (Indirektionsblock
zweiter Stufe) enthält Adressen von weiteren Indirektionsblöcken erster Stu-
fe, die ihrerseits Adressen von Datenblöcken enthalten. Analog für den drit-
ten Indirektionsblock mit wieder einer zusätzlichen Stufe.

• Alle Adressen sind 4 Bytes lang.
• Die Blockgröße beträgt einheitlich 4KBytes (gilt sowohl für Daten- als auch

für Indirektionsblöcke).

Beantworten Sie die folgenden Fragen!
a) Wie groß ist der Inhalt einer Datei mindestens (genaue Angabe in

Bytes), wenn ihr I-Node auf genau zwei Datenblöcke direkt verweist?

b) Wie groß ist der Inhalt einer Datei höchstens (genaue Angabe in

Bytes), wenn ihr I-Node auf genau zwei Datenblöcke direkt verweist?
c) Es soll auf die Datei /baum/zweig/ast zugegriﬀen werden. Wie viele
I-Nodes und Datenblöcke müssen dazu mindestens gelesen werden?

d) Warum ist es sinnvoll, den Dateityp im I-Node festzuhalten?
e) Mit Hilfe des Befehls ln lassen sich in UNIX Verknüpfungen (Links) auf
eine Datei erstellen. Dabei wird zwischen Hardlinks (ln quellDatei
zielDatei) und symbolischen Links (ln -s quellDatei zielDatei) un-
terschieden. Wodurch unterscheiden sich diese beiden Varianten?


------------------------------------------------------------------------
Frühjahr 08 - Thema 2

331

Auf einem Rechner wird das Dateisystem Ext2 (ohne Journaling) mit einer
Blockgröße von 4 KBytes verwendet. Folgende Situation ist gegeben:

• Der I-Node mit der Nummer 332 adressiert die Datenblöcke mit den
Adressen 0xA0A8AFA0, 0xA0A8AFA4 und 0xA0A8AFA8 direkt. Die
verbleibenden sieben Felder für direkte Adressen, sowie die drei Felder
für die Adressierung von Indirektionsblöcken enthalten keine Adressen
(NULL). Der Referenzzähler (Linkzähler) steht auf 1.

• Der Datenblock 0xA8124AAA0 beschreibt das Verzeichnis studies, wel-
ches unter anderem die Datei notes.txt enthält. Der entsprechende Ver-
zeichniseintrag verweist auf den I-Node 332.

• Der Datenblock 0x011100B0 beschreibt das Verzeichnis info, welches un-
ter anderem die Datei notes copy.txt enthält. Der entsprechende Verzeich-
niseintrag verweist auf den I-Node 332.

f) Worin besteht in diesem Beispiel die Inkonsistenz?
g) Können die Dateien notes.txt und notes copy.txt in den jeweiligen
Verzeichnissen vom Nutzer gelesen werden, auch wenn die Inkonsistenz
nicht behoben wird? Geben Sie an, ob keine, eine oder beide Dateien gele-
sen werden können und begründen Sie Ihre Antwort!

h) Was passiert mit dem I-Node 332, wenn der Nutzer nur die Verknüp-

fung notes copy.txt aus dem Verzeichnis info entfernt
(rm notes copy.txt)? (Mit Begründung!)

a) 4KB + 1B = 4096B + 1B = 4097B

b) 8KB = 8192B

c) Zu den Dateitypen von UNIX zählen außer den

normalen“ Dateien:
”

• Verzeichnis
• symbolische Links
• zeichenorientierte Geräte
• blockorientierte Geräte
• named pipes (gepuﬀerter uni- oder bidirektionaler Datenstrom zwischen
zwei Prozessen nach dem
First In – First Out“-Prinzip; named pipes
”
können auch zur Kommunikation zwischen Prozessen eingesetzt werden,
die nicht miteinander verwandt sind und sich darüber hinaus auf un-
terschiedlichen Rechnern innerhalb eines Netzwerkes beﬁnden dürfen)
• Sockets (bidirektionale Software-Schnittstelle zur Interprozess- (IPC)
oder Netzwerk-Kommunikation; sie stellen eine vollduplexfähige Alter-
native zu pipes dar)

Um diese korrekt und schnell ansprechen zu können, ist es notwendig zu
wissen, um welchen Dateityp es sich handelt.


------------------------------------------------------------------------
332

d)

4 Betriebssysteme

symbolische Links
enthalten einen Verweis auf einen
Verzeichniseintrag
können von einem Dateisystem in
andere verweisen
beim Löschen wird nur der Link
gelöscht, keine Daten

Hardlinks
enthalten einen Verweis auf einen
I-Node
sind nur innerhalb eines Dateisys-
tems einsetzbar
falls es sich um den letzten Hard-
link auf eine Datei handelt, wird
diese komplett gelöscht - genau,
wie der zugehörige I-Node

e) Unter den beiden letzten Spiegelstrichen wird beschrieben, dass zwei Hard-
links auf I-Node 332 verweisen. Unter dem ersten Spiegelstrich wird aber
erwähnt, dass der Referenzzähler nur auf 1 (nicht auf 2) steht.

f) Es können beide Dateien gelesen werden, da der inkonsistente Wert des Re-
ferenzzählers erst beim Löschen (s. u.) zum Tragen kommt. Zum Lesen des
Dateiinhalts ist es lediglich notwendig, dass die Datei mit ihrem Namen an-
gesprochen werden kann, was der I-Node-Eintrag hier bewerkstelligt.

g) Wird notes copy.txt gelöscht, so wird wegen des Wertes 1 des Referenz-
zählers sowohl der Dateiinhalt als auch der zugehörige I-Node 332 gelöscht.

Aufgabe 2

Prozesszu-
stand,
Prozesszu-
standsgraph

Diese Aufgabenstellung beschäftigt sich mit dem gängigen 7-Zustands-Modell
zur Beschreibung möglicher Ausführungszustände eines Prozesses sowie deren
übergänge. Die fünf Grundzustände sind Erzeugt, Bereit, Rechnend, Blockiert
und Beendet, wobei in den beiden Zuständen Bereit und Blockiert jeweils unter-
schieden wird, ob der jeweilige Prozess sich aktuell im Hauptspeicher beﬁndet
(resident) oder ausgelagert wurde (swapped/supended).
a) Geben Sie für jede der folgenden Transitionen an, ob es sich um einen gül-
tigen übergang handelt! Falls ja, geben Sie ein Beispiel an, welches den
jeweiligen Zustandswechsel auslösen könnte! Falls nein, begründen Sie,
warum dieser Zustandsübergang nicht sinnvoll ist!

Beispiel: Erzeugt → Bereit: Gültig; Beispiel: Das Prozess-Image liegt vollständig
im Speicher, und der Prozess ist nun rechenbereit. Er wartet darauf, vom Sche-
duler zur Ausführung ausgewählt zu werden.


------------------------------------------------------------------------
Frühjahr 08 - Thema 2

333

i) Bereit → Rechnend
ii) Rechnend → Bereit
iii) Rechnend → Blockiert
iv) Blockiert → Rechnend
v)Blockiert → Bereit

vi) Rechnend → Beendet
vii) Bereit → Bereit-Ausgelagert
viii) Bereit-Ausgelagert → Rechnend
ix) Blockiert → Blockiert-Ausgelagert
x) Blockiert-Ausgelagert → Bereit-Ausgelagert

b) Welche(r) der Zustände Bereit, Rechnend und Blockiert könnte(n) einge-

spart werden, wenn das Betriebssystem in reinem Batch-Betrieb (d. h. kein
Multiprogramming) arbeitet)? (Mit Begründung.)

a)

i) gültig: ein bereiter Prozess wird vom Scheduler ausgewählt und be-

kommt die CPU zugeteilt.

ii) gültig: ein gerade aktiv rechnender Prozess bekommt die CPU entzogen,

ist aber weiterhin bereit.

iii) gültig: ein rechnender Prozess blockiert z. B. weil er auf eine Eingabe

wartet.

iv) ungültig: der Scheduler teilt die CPU nur bereiten Prozessen zu. Der
Prozess muss also erst in den Zustand bereit wechseln und warten, bis
er an die Reihe kommt.

v) gültig: die Blockade eines Prozesses wird aufgehoben, z. B. weil er eine

Eingabe erhält.

vi) gültig: ein Prozess terminiert nachdem seine Berechnungen ausgeführt

sind.

vii) gültig: ein Prozess wird wegen Platzmangels aus dem Hauptspeicher

ausgelagert.

viii) ungültig: der Prozess muss zuerst wieder eingelagert werden, bevor er

in den Zustand rechnend wechseln kann.

ix) gültig: ein blockierter Prozess wird wegen Platzmangel ausgelagert.
x) gültig: die Blockade eine ausgelagerten Prozesses, z. B. eine von einem

anderen Prozess genutzte Ressource wird frei, ist aufgehoben.

b) Der Zustand

blockiert“ könnte eingespart werden, da in einem Batch-System
”
kein Prozesswechsel im Falle einer Blockade stattﬁndet. Ein Prozess, der ein-
mal im Zustand
rechnend“ ist, bleibt darin so lange, bis er terminiert, auch
”
wenn er zwischenzeitlich phasenweise blockiert.


------------------------------------------------------------------------
Prozess-
wechsel,
Prozesskon-
text,
Scheduling-
verfahren,
RR,
Verweilzeit,
Wartezeit

334

4 Betriebssysteme

Aufgabe 3

Beim Scheduling nach der Round-Robin-Strategie wird eine FIFO-Warteschlan-
ge von Prozessen verwaltet, wobei jeweils dem in der Schlange ersten Prozess
für eine feste Zeitdauer Q (die Länge der sog. Zeitscheibe) die CPU zugeteilt
wird. Ein Prozess, dessen Zeitscheibe abgelaufen ist, wird am Ende der Warte-
schlange wieder eingereiht. Die mittlere Bedienzeit T eine Prozesses bezeichne
die Zeitspanne, für die ein Prozess im Mittel die CPU benötigt, bevor er das
Warteschlangensystem aufgrund einer angestoßenen E/A-Operation bzw. bei
Prozessende freiwillig verlässt. Es handelt sich bei T also um die reine Rechen-
zeit des Prozesses. Die mittlere Verweilzeit V hingegen bezeichne die gesamte
Zeitspanne, die ein Prozess im Mittel im System verweilt (ggf. wechselnd zwi-
schen den Zuständen Bereit und Rechnend). Die mittlere Wartezeit W sei die
durchschnittliche Summe der Zeiträume, in denen ein Prozess zwar im System
verweilt, aber nicht rechnet. Ein Prozesswechsel benötige eine Zeitdauer S, die
als Overhead verloren geht, aber unvermeidbar ist. Zusammenfassend ergeben
sich die folgenden Zusammenhänge:

• Größe der Zeitscheibe: Q
• Mittlere Bedienzeit (reine Rechenzeit) eines Prozesses: T
• Mittlere Verweilzeit eines Prozesses: V, V ≥ T
• Mittlere Wartezeit eines Prozesses: W, W = V − T
• Zeit für Prozesswechsel: S
a) Beschreiben Sie kurz, was beim Prozesswechsel passiert und welche Aufga-
be das Betriebssystem dabei erfüllt! Erklären Sie in diesem Zusammenhang
in kurzen Stichworten den Begriﬀ des Prozesskontextes!

b) Die Zeitdauer S wird also wesentlich von der Komplexität des Prozesswech-

sels beeinﬂusst. Wovon hängt diese Komplexität maßgeblich ab?

c) Gegeben sind die Prozesse P1 bis P4 mit den in der folgenden Tabelle ange-
gebenen Ankunfts- und Bedienzeiten. Es gelte Q = 2 und vereinfachend
S = 0 (also vernachlässigbar klein). Eine Zeitscheibe muss nicht voll ausge-
nutzt werden. Terminiert ein Prozess vor Ablauf von Q, so wird diese eine
Zeitscheibe entsprechend verkürzt und der nächste Prozess kann sofort ak-
tiviert werden.

Prozess Ankunftszeitpunkt Bedienzeit

P1
P2
P3
P4

0
1
3
6

4
5
2
4


------------------------------------------------------------------------
Frühjahr 08 - Thema 2

335

i) Ermitteln Sie für jeden Prozess die individuelle Verweil- und
Wartezeit! Erstellen Sie ein Tabelle nach folgendem Muster!
Tipp: Machen Sie sich dazu die Ausführungsreihenfolge der Prozes-
se durch ein Diagramm (z. B. Gantt-Chart) klar, und zeichnen Sie
auch die Warteschlange (separates Blatt)! Für die Bewertung spielen
die Zeichnungen allerdings keine Rolle.

Prozess Verweilzeit Wartezeit

P1
P2
P3
P4

ii) Berechnen Sie die mittlere Verweil- und Wartezeit für dieses Sys-

tem!

d) Unter der Annahme, dass in einem System stets rechenbereite Prozesse
zur Verfügung stehen, lässt sich die CPU-Auslastung ρ wie folgt deﬁnie-
ren: ρ = T
T +n·S , wobei n die Anzahl der pro Prozess durchschnittlich anfal-
lenden Prozesswechsel ist. Dabei soll gelten: Ein Prozesswechsel gehört zu
dem Prozess, der zuletzt (also unmittelbar vor dem Prozesswechsel) gerech-
net hat. Terminiert ein Prozess, so gehört der anschließende Wechsel zu ei-
nem rechenbereiten Prozess also auch noch zu dem gerade terminierten
Prozess.

a) Wie wirkt sich ein hoher Wert für S auf die CPU-Auslastung aus?
b) Geben Sie für n eine Formel in Abhängigkeit von T und Q an!
c) Welche CPU-Auslastung ergibt sich, wenn gilt: Q > T ? Gegen wel-

che Ihnen bekannte Scheduling-Strategie konvergiert Round Robin in
diesem Fall?

d) Welche CPU-Auslastung ergibt sich, wenn gilt: Q = S?

a) Prozesswechsel: Prozess wird unterbrochen, das Betriebssystem ordnet ei-
aktiv“ zu und gibt diesem Prozess die
”

nem anderen Prozess den Zustand
Kontrolle.
Folgende Schritte werden dabei vom Betriebssystem durchgeführt:

1.
2.

3.
4.
5.
6.

7.

Sicherung des Prozesskontextes des aktiven Prozesses
Aktualisierung des Prozesskontrollblocks (PCB - näheres dazu s. u.)
des rechnenden (aktiven) Prozesses (z. B. neuer Zustand)
Einordnung des PCBs in die entsprechenden Warteschlangen
Auswahl eines anderen Prozesses (Scheduling) für die Ausführung
Laden des Kontextes des ausgewählten Prozesses
Aktualisierung des PCBs des ausgewählten Prozesses
(Zustand → aktiv)
Aktualisierung der speicherrelevanten Datenstrukturen

Der Prozesskontrollblock, auch Prozesskontext genannt, beinhaltet Informa-
tionen über den Zustand des Prozesses, die Inhalte der CPU-Register (etwa


------------------------------------------------------------------------
336

4 Betriebssysteme

Befehlszählregister, Akkumulator usw.) zum Zeitpunkt der Ausführung des
Prozesses, sowie ergänzend die Seitentabelle, seinen Stackpointer sowie seine
Speicherbelegung und den Zustand seiner geöﬀneten Dateien. Weitere In-
halte im Datensatz sind beispielsweise die Prozessnummer, die vom Prozess
geöﬀneten Dateien, Information über Eltern- oder Kindprozesse, Prioritäten,
in Anspruch genommene Zeit, Scheduling- und Verwaltungsinformationen so-
wie alle Informationen, welche abgespeichert werden müssen, wenn der Pro-
zess vom Zustand
blockiert“
”
übergeht, um ein nahtloses Weiterlaufen nach der Unterbrechung zu garan-
tieren.

rechnend“ in die Zustände
”

rechenbereit“ oder
”

b) Je umfangreicher der PCB (Anzahl Kindprozesse, beteiligte Dateien...), de-

sto teurer wird der Prozesswechsel.

c)

i)

ii) mittlere Verweilzeit: 32/4 = 8

mittlere Wartezeit: 17/4 = 4, 25

d)

i) Weil S im Nenner des Bruchs vorkommt, bewirkt ein hoher Wert für S

ein geringeres ρ, also eine geringere CPU-Auslastung.

ii) n ist die Anzahl der Prozesswechsel, die nötig sind bis ein Prozess abge-
arbeitet ist. Bei einer Rechenzeit T benötigt der Prozess n Zeitscheiben
der Länge Q. ⇒ n = d T
Q

e

iii) Wenn Q > T bedeutet dies, dass der Prozess innerhalb einer Zeitscheibe
abgearbeitet werden kann, n ist also 1. Für ρ gilt dann ρ = T
T +S wenn
S klein ist, dass ρ gegen 100% konvergiert. Round Robin konvergiert
dann gegen First Come First Served, da die Prozesse in der Reihenfolge
ihres Eintreﬀens abgearbeitet werden.

iv) ρ = T

T +n·S = T
T + T

Q ·Q

= T

T +T = 1

2


------------------------------------------------------------------------
Frühjahr 08 - Thema 2

Aufgabe 4

337

In dieser Aufgabe sollen verschiedene Seitenersetzungsstrategien (Paging-Strate-
gien) am konkreten Beispiel verglichen werden. Dabei sei die Menge der Seiten
gegeben durch N = {0, 1, 2, 3, 4}. Die Menge der Seitenrahmen, die für die Spei-
cherung der Seiten im Arbeitsspeicher zur Verfügung stehen, sei gegeben durch
F = {f0, f1, f2}. Auf die 5 Seiten der Menge N werde in folgender Reihenfolge
zugegriﬀen:

Seitenerset-
zungsstra-
tegien,
LRU, LFU,
Seitenﬂat-
tern

w = 0 4 3 4 3 1 3 4 0 3 2 1 0
Ein Seitenfehler liegt immer dann vor, wenn sich eine referenzierte Seite nicht
im Arbeitsspeicher beﬁndet. Dieser ist zu Beginn leer.
a) Ermitteln Sie die Anzahl der Seitenfehler für die Paging-Strategie LRU

(Least Recently Used), indem Sie den Zustand des Speichers nach jedem
Zugriﬀ in einer Tabelle nach folgendem Muster dokumentieren! Informatio-
nen, die aufgrund der Paging-Strategie zusätzlich noch benötigt werden, tra-
gen Sie ebenfalls ein!

f0

f1

f2

Summe Seitenfehler

Referenzierte Seiten
0
4
3
4
3
1
3
4
0
3
2
1
0


------------------------------------------------------------------------
338

4 Betriebssysteme

b) Ermitteln Sie nun die Anzahl der Seitenfehler für die Paging-Strategie

LFU (Least Frequently Used), indem Sie den Zustand des Speichers nach je-
dem Zugriﬀ in einer Tabelle nach folgendem Muster dokumentieren! Infor-
mationen, die aufgrund der Paging-Strategie zusätzlich benötigt werden,
tragen Sie ebenfalls wieder ein!

f0

f1

f2

Summe Seitenfehler

Referenzierte Seiten
0
4
3
4
3
1
3
4
0
3
2
1
0

c) In der Praxis ergibt sich ein signiﬁkantes Problem beim Einsatz der zwei-

ten Strategie (Least Frequently Used). Welches? Wie könnte man LFU mo-
diﬁzieren, um dieses Problem zu minimieren?
Tipp: überlegen Sie sich, was passiert, wenn auf eine Seite zunächst über ei-
nen langen Zeitraum häuﬁg zugegriﬀen wird, später dann die Seite nicht
mehr benötigt wird (da z. B. der zugehörige Prozess terminiert wurde)!

a) Least Recently Used

Referenzierte Seiten
0
4
3
4
3
1
3
4
0
3
2
1
0

f0
00
01
02
03
04
10
11
12
00
01
02
10
11

f1

40
41
40
41
42
43
40
41
42
20
21
22

f2

30
31
30
31
30
31
32
30
31
32
00

Summe Seitenfehler
0
0
0
0
0
1
1
1
2
2
3
4
5


------------------------------------------------------------------------
Frühjahr 08 - Thema 2

339

b) Least Frequently Used

Referenzierte Seiten
0
4
3
4
3
1
3
4
0
3
2
1
0

f0
01
01
01
01
01
11
11
11
01
01
21
11
01

f1

41
41
42
42
42
42
43
43
43
43
43
43

f2

31
31
32
32
33
33
33
34
34
34
34

Summe Seitenfehler
0
0
0
0
0
1
1
1
2
2
3
4
5

c) Häuﬁg verwendete Seiten besitzen einen hohen Referenzzähler und werden
dadurch nicht ersetzt. Es bleiben also weniger freie Kacheln für die aktuell
häuﬁg verwendeten Seiten. Es kann passieren, dass es zum Seitenﬂattern
kommt, dass also eine Seite abwechselnd ein- und ausgelagert wird.
Eine Lösung für dieses Problem besteht darin, die Zähler bei jedem Schritt
zu dekrementieren. D. h. in Binärdarstellung werden die Zähler um ein Bit
nach rechts geschoben.

Aufgabe 5

Gegeben sind die drei Prozesse P1, P2 und P3 sowie die vier Betriebsmittel R1
bis R4. Zum betrachteten Zeitpunkt t gilt:
• P1 nutzt R3 und fordert R1 an.
• P2 nutzt R4 und fordert R3 an.
• P3 nutzt R1 und fordert R2 und R4 an.

Prozess,
Betriebs-
mittel-
graph,
Verklem-
mung

a) Zeichnen Sie den Resource-Allocation-Graph (Betriebsmittelgraph)
für den Zeitpunkt t unter Berücksichtigung aller vorhandenen Betriebsmit-
tel!

b) Welche Betriebsmittelanforderung(en) ist (sind) sofort erfüllbar?
c) Entscheiden und begründen Sie anhand des Resource-Alloction-Graphen,
ob nach Erfüllung der erfüllbaren Anforderung(en) ein Deadlock vorliegt!


------------------------------------------------------------------------
340

a)

4 Betriebssysteme

b) Die einzige Anforderung, die sofort erfüllbar ist, ist dass P3 R2 zugeteilt
bekommt, da R2 als einzige Ressource von keinem anderen Prozess genutzt
wird.

c)

Entfernt man die erfüllbaren An-
forderungen aus dem Graphen,
so,
sieht man, dass ein Zy-
klus vorhanden ist. Aus diesem
Grund liegt ein Deadlock vor.


------------------------------------------------------------------------
5

Datenbanken

Frühjahr 01 - Thema 1

Aufgabe 2

2.1. Die Entwicklung eines großen Programmsystems soll durch eine Datenbank
unterstützt werden. Sie soll festhalten, welche Komponenten von den einzel-
nen Entwicklern beigesteuert werden und auf welchen Rechnern die Kom-
ponenten gespeichert sind. Außerdem soll sie Auskunft über die Zerlegung
von Komponenten in Teilkomponenten geben. Zur Lösung dieser Aufgabe
wurde folgendes Entity-Relationship-Diagramm entwickelt.

ER-Model-
lierung,
relationales
Schema,
Schlüssel,
Datenbank-
anfrage,
relationale
Algebra

E n t w i c k l e r

p

n

t r a e g t _ b e i

m

R e c h n e r

K o m p o n e n t e

b e s t e h t _ a u s

n

m

2.1.1. Entwerfen Sie ein Schema nach dem Relationenmodell, das diesem

Diagramm entspricht. Bestimmen Sie die Primär- und Fremdschlüssel.
Entwickler (E) habe die Attribute ENR, Name (ENAME) und Ort
(EORT). Komponente(K) habe die Attribute KNR, Bezeichnung
(KBEZ), Programmiersprache (KSPRA) und verwendeter Compiler
(KCOMP). Rechner (R) bestehe aus IP-Adresse (RADR) und Kom-
ponentennummer (KNR). Beitrag (B) wird durch ENR, KNR und
Datum (DATUM) beschrieben. Komponentenliste (KL) hat die Attri-
bute Ober-Komponente (OKN) und Teilkomponente (TKN).
2.1.2. Drücken Sie die folgenden beiden Anfragen in umgangssprachlicher

Formulierung aus:

1. πT KN (KL ./OKN =T KN πT KN (KL ./OKN =T KN πT KNσOKN =0 Abrechnung0 KL))
2. πRADR (R ./KN R=KN R (B ./OKN =T KN σEORT =0Banghalore0 E))


------------------------------------------------------------------------
342

5 Datenbanken

2.2. Zur Verwaltung des Ausleihwesens benutzt eine Universitäts-Bibliothek

L(LSNR, NAME, VORNAME, WOHNORT)
B(ISBN, TITEL, VERLAG, EXEMPLARE)

folgende Datenbank:
LESER:
BUCH:
EXEMPLAR: E(ISBN, EXPNR, STANDORT)
AUSLEIHE: A(LSNR, ISBN, EXPNR, DATUM)
Formulieren Sie folgende Anfragen in SQL:

2.2.1. Welche Bücher sind an mehreren Standorten vorhanden?
2.2.2. Von welchen Buchtiteln sind sämtliche Exemplare ausgeliehen?

2.3. Zur Organisation des Prüfungswesens werde folgende Datenbank benutzt:

P (PNAME, FBNR)
Professor:
S
Student:
Fachbereich: F
Prüfung:

(MATRNR, NAME, VORNAME, FBNR)
(FBNR, FNAME, DEKAN)

PR (PNAME, MATRNR, NOTE)

2.3.1. Folgende Anfrage soll nach den Heuristiken

Selektion möglichst früh“
”

Projektion möglichst spät“ optimiert werden.
und
”
πMAT RN R,N AM E,V ORN AME σF N AM E=0Inf ormatik0 S ./ F
(Liste der Studenten, die im Fachbereich Informatik eingeschrieben
sind.)

2.3.2. Erläutern Sie an dem Beispiel, inwiefern obige Heuristiken (evtl. ab-

hängig vom Mengengerüst) zu einer Optimierung der Anfrage führen.

2.1.1. E(ENR, ENAME, EORT)

K(KNR, KBEZ, KSPRA, KCOMP)
R(RADR, KNR)
B(ENR, KNR, DATUM)
KL(OKN, TKN)
1.

2.1.2.

Alle Teilkomponenten der dritten Ebene (vgl.
Abbildung links) der Komponente ’Abrech-
nung’.

2. Es werden die Rechneradressen selektiert, wo auf den zugehöri-
gen Rechnern Komponenten von Entwicklern aus Banghalore ent-
wickelt werden.

2.2.1. SELECT DISTINCT ISBN

FROM
WHERE E1.ISBN = E2.ISBN

E AS E1, E AS E2

AND E1.Standort 6= E2.Standort;

2.2.2. SELECT DISTINCT Titel

FROM

B, E


------------------------------------------------------------------------
Herbst 01 - Thema 1

343

WHERE

B.ISBN = E.ISBN
AND E.EXPNR = ALL

(SELECT EXPNR

FROM
WHERE E.ISBN = A.ISBN);

A

2.3.1. πMAT RN R,N AM E,V ORN AME S ./ (σF N AM E=0Inf ormatik0 F )

2.3.2. Ohne Optimierung entstehen beim Join S ./ F sehr viele Tupel, die
hinterher wieder verworfen werden, nämlich alle Tupel, in denen an-
dere Fachbereiche vorkommen. Angenommen es gäbe 1000 Studenten,
dann liefert der Join ebenfalls 1000 Tupel. Wird zuerst der Fachbereich
selektiert, ergibt der Join nur so viele Tupel, wie es Informatikstudenten
gibt. Dies sind in der Regel deutlich weniger.

Herbst 01 - Thema 1

Aufgabe 1

ER-Model-
lierung,
Relation-
ship,
Entität,
Schlüssel-
kandidat

Es soll eine Datenbank für ein Kino- und Film-Auskunftssystem für eine Stadt
entworfen werden. Das System soll vergangene und zukünftige Spielpläne ent-
halten können.
Entity Mengen:

Regisseure/Innen mit den Attributen NAME, VORNAME,

Filme
Schauspieler

Kinos

Relationsships:

spielt
führt
läuft

GEB-DATUM, VITA
mit dem Attribut TITEL
mit denselben Attributen wie Regisseure/Innen aber
zusätzlich dem künstlichen Schlüssel S# vom Typ
integer
mit den Attributen BEZEICHNUNG, STRASSE,
HAUSNR, TELEFON-NR

Ein Schauspieler spielt in einem Film.
Ein Regisseur führt Regie in einem Film.
Ein Film läuft in einem Kino.

Integritätsbedingungen:

Neben den oﬀensichtlichen Integritätsbedingungen sollen folgende gelten:
I1
I2

In einem Film führt nur 1 Person Regie.
In einem Kino können mehrere Filme laufen. aber nur zu verschiede-
nen Zeiten (es gibt nur 1 Vorführraum).
TITEL, BEZEICHNUNG sowie die Kombination NAME, VORNAME
sind eindeutig für Filme, Kinos bzw. Regisseure. Für Schauspieler sei
die Kombination NAME, VORNAME, GEB-DATUM eindeutig.

I3


------------------------------------------------------------------------
344

5 Datenbanken

1.1.

• Entwerfen Sie für die Datenbank ein E/R Diagramm entsprechend den

obigen Speziﬁkationen und Integritätsbedingungen.
• Geben Sie die Kardinalitäten für die Relationships an.
• Geben Sie für jede Entität die Menge der Schlüsselkandidaten an.
• Geben Sie die Attribute der Relationships an.
• Geben Sie mindestens zwei verschiedene Varianten für die Relation-

ship läuft an, treﬀen Sie eine Modellierungsentscheidung und begrün-
den Sie Ihre Entscheidung.

V i t a

V o r n a m e

G e b - D a t u m

1.1.

N a m e

T i t e l

V i t a

V o r n a m e

N a m e

G e b - D a t u m

S #

R e g i s s e u r

1

f u e h r t

n

F i l m

n

s p i e l t

m

S c h a u s p i e l e r

1

l a e u f t

n

K i n o

D a t u m

U h r z e i t

T e l e f o n - N r

B e z e i c h n u n g

H a u s - N r

S t r a s s e

Schlüsselkandidaten:
Regisseur: {(Name, Vorname)}
Film: {(Titel)}
Schauspieler: {(S#), (Name, Vorname, Geb-Datum)}
Kino: {(Bezeichnung), (Strasse, Haus-Nr), (Telefon-Nr)}
Eine Modellierungsvariante der Relation läuft lässt sich mit einer ternären
Relationship erzeugen:

T i t e l

F i l m

1

l a e u f t

m

T e r m i n

n

K i n o

D a t u m

U h r z e i t

B e z e i c h n u n g

T e l e f o n - N r

S t r a s s e

H a u s - N r


------------------------------------------------------------------------
Herbst 01 - Thema 1

345

Da aber die Entität Termin an keiner anderen Stelle benötigt wird und binäre
Relationships leichter weiter zu verarbeiten sind als ternäre, bleiben wir im
Folgenden bei der ursprünglichen Modellierung.

1.2. Geben Sie zu dem entwickelten E/R Diagramm ein relationales Schema an
und kennzeichnen Sie durch Unterstreichen die gewählten Primärschlüssel.

relationales
Schema,
Primär-
schlüssel

1.2. Regisseur(Name, Vorname, Geb-Datum, Vita)

Film(Titel)
Schauspieler(S#, Name, Vorname, Geb-Datum, Vita)
Kino(Bezeichnung, Strasse, Haus-Nr, Telefon-Nr)
spielt(Titel, S#)
fuehrt(Titel, Name, Vorname)
laeuft(Datum, Uhrzeit, KinoBezeichnung, Titel)

Verfeinerung der relationalen Schemas:
Die Relationen Film und fuehrt können zusammengefasst werden:
Regisseur(Name, Vorname, Geb-Datum, Vita)
Film(Titel, RegName, RegVorname)
Schauspieler(S#, Name, Vorname, Geb-Datum, Vita)
Kino(Bezeichnung, Strasse, Haus-Nr, Telefon-Nr)
spielt(Titel, S#)
laeuft(Datum, Uhrzeit, Kino, Titel)

1.3. Formulieren Sie für das relationale Schema die folgenden Anfragen bzw.

SQL

Operationen in SQL:

• Eine Liste aller Filmregisseure
• In welchen Filmen spielt Meryll Streep?
• NAME, GEB-DATUM und VITA des Regisseurs von
• In welchen Filmen spielt Meryll Streep gemeinsam mit Robert Red-

AfricanQueen“
”

ford?

• In welchem Kino mit Tel.Nr. läuft heute der Film

Story“ und zu welcher Zeit?

• änderung des Spielplans des Kinos

The Straight
”

Media Palast“, so dass morgen
”

The Straight Story“ läuft.
”

um 22:15h der Film

1.3. SELECT *
FROM

Regisseur;

SELECT spielt.Titel
FROM
WHERE

Schauspieler s, spielt
spielt.S# = s.S#
AND s.Vorname = ’Meryll’
AND s.Name = ’Streep’;


------------------------------------------------------------------------
346

5 Datenbanken

SELECT Name, Geb-Datum, Vita
FROM
Regisseur r, Film f
WHERE f.Titel = ’African Queen’

AND r.Vorname = f.RegVorname
AND r.Name = f.RegName;

SELECT spielt.Titel
FROM
WHERE spielt.S# = s.S#

Schauspieler s, spielt

AND s.Vorname = ’Meryll’
AND s.Name = ’Streep’
AND spielt.titel IN (SELECT spielt.Titel

FROM
WHERE spielt.S# = s.S#

Schauspieler s, spielt

AND s.Vorname = ’Robert’
AND s.Name = ’Redford’);

SELECT k.Bezeichnung, k.TelNr, laeuft.Uhrzeit
FROM
WHERE laeuft.Titel = ’The Straight Story’

Kino k, laeuft

AND laeuft.Datum = ’today’
AND laeuft.Kino = k.Bezeichnung;

UPDATE laeuft
SET
WHERE Kino = ’Media Palast’

Titel = ’The Straight Story’

AND Datum = ’tomorrow’
AND Uhrzeit = 22:15;

Herbst 01 - Thema 2

Aufgabe 2

Normalfor-
men,
relationales
Schema,
Normalisie-
rung,
funktionale
Abhängig-
keiten,
Anomalien

2.1. Für die Anwendung in der Anlageabteilung einer Bank sei ein relationales
Datenbankschema gegeben. Die verwendeten Attribute sind: Anlageberater
(AB), Büro des Beraters (Büro), Anleger, Aktienname (Aktie), Anzahl der
gekauften Aktien und die für eine bestimmte Aktie gezahlte Dividende. Die
Relationenschemata sehen wie folgt aus:
ANLAGE (Aktie, Anzahl, Anleger, Dividende)
mit den funktionalen Abhängigkeiten Aktie → Dividende sowie
Anleger, Aktie → Anzahl
BERATUNG (Anleger, AB, Büro)
mit den funktionalen Abhängigkeiten AB → Büro sowie Anleger → AB


------------------------------------------------------------------------
Herbst 01 - Thema 2

347

2.1.1. Welchen Normalformen (2NF, 3NF, BCNF) genügen die Relationen-

schemata und welchen nicht? Begründen Sie kurz Ihre Antworten.
2.1.2. Können beim Arbeiten mit dieser Datenbank Anomalien auftreten

und, wenn ja, welche (jeweils mit einem kurzen Beispiel)?

2.1.3. Bringen Sie die Relationen in BCNF und begründen Sie Ihre

Transformationen.

2.1.1. ANLAGE ist nicht in 2NF, da als Schlüssel nur (Anleger, Aktie) in
Frage kommt und die FD Aktie → Dividende damit nur von einem Teil
des Schlüsselkandidaten abhängig ist und die 2NF verletzt. ANLAGE
ist damit auch nicht in 3NF.
BERATUNG besitzt den Schlüsselkandidaten (Anleger) und da dieser
einelementig ist, ist die 2NF automatisch gewährleistet (wenn die 1NF
erfüllt ist). BERATUNG ist allerdings nicht in 3NF, da die transitive
Abhängigkeit Anleger → AB → Büro existiert.
Beide Relationenschemata sind nicht in BCNF, da sie FDs besitzen,
deren linke Seiten keine Superschlüssel sind. Diese sind Aktie → Divi-
dende bzw. AB → Büro.

2.1.2. Es kann die DELETE-Anomalie auftreten, wenn z. B. alle Anleger eine
bestimmte Aktie verkaufen, geht die Information über deren Dividende
verloren.
Außerdem kann es zu einer UPDATE-Anomalie kommen: Angenommen
ein AB ändert sein Büro, so muss dies bei allen Anlegern, die er betreut,
geändert werden.
Die INSERT-Anomalie zeigt sich dadurch, dass ein AB erst in die Da-
tenbank aufgenommen werden kann, wenn er mindestens einen Anleger
betreut.

2.1.3. Zerlege ANLAGE in AKTIE(Aktie, Dividende) und ANLEGER(Anleger,

Aktie, Anzahl).
Es entsteht eine Relation mit den Attributen der verletzenden FD, Ak-
tie und Dividende, sowie eine Relation mit allen anderen Attributen
außer der rechten Seite der verletzenden FD, also (Anleger, Aktie, An-
zahl, Dividende) ohne Dividende.
Zerlege BERATUNG in BERATER(AB, Büro) und BERATUNG(An-
leger, AB).
Es entsteht eine Relation mit den Attributen der verletzenden FD, AB
und Büro, sowie eine Relation mit allen anderen Attributen außer der
rechten Seite der verletzenden FD, also (Anleger, AB, Büro) ohne Büro.


------------------------------------------------------------------------
348

5 Datenbanken

SQL-Anfra-
gen

2.2. Ein Flugbuchungssystem enthalte unter anderen folgende Relationen:

• Flughafen(FlughafenNummer, FlughafenName, FlughafenOrt, Land)
• Flug(FlugNummer, FluggesellschaftKürzel, FlugzeugNummer)
• Flugintervall(FlugintervallNummer, FlugNummer,

StartﬂughafenNummer, ZielﬂughafenNummer, Abﬂugzeit,
Ankunftszeit)

• Buchung(PassagierNummer, FlugintervallNummer,

BuchungsklasseNummer)

• Buchungsklasse(BuchungsklasseNummer,

BuchungsklasseBeschreibung)

• Flugpreis(FlugintervallNummer, BuchungsklasseNummer, Preis)
2.2.1. Formulieren Sie eine Anfrage, die für die vorhandenen Flugintervalle

eine Tabelle der Namenspaare der Start- und Ziel-Flughäfen nach
Start-Flughäfen sortiert liefert.

2.2.2. Ermitteln Sie die Flugintervallnummer, die zwei Orte(!) ’Start’ und

’Ziel’ direkt verbinden, zusammen mit den zugehörigen Abﬂugs- und
Ankunftszeiten. ’Start’ und ’Ziel’ sollen Parameter sein.

2.2.3. Ermitteln Sie zu einem als Parameter angebbaren Flugintervall, wie
viele Plätze in den verschiedenen Buchungsklassen belegt sind. Bu-
chungsklassen ohne Buchungen brauchen nicht aufgeführt zu werden.)
2.2.4. Ermitteln Sie zu einem angebbaren Flug den Gesamtpreis der getätig-

ten Buchungen.

2.2.1. SELECT

FROM
WHERE

F1.FlughafenName AS Start, F2.FlughafenName AS Ziel
Flug F1, Flug F2, Flugintervall
F1.FlughafenNummer = StartflughafenNummer
AND F2.FlughafenNummer = ZielflughafenNummer

ORDER BY F1.FlughafenName;

2.2.2. SELECT FlugintervallNummer, Abflugzeit, Ankunftszeit

FROM
WHERE FH1.FlughafenOrt = ’Start’

Flugintervall FI, Flughafen FH1, Flughafen FH2

AND FH2.FlughafenOrt = ’Ziel’
AND FH1.FlughafenNummer = FI.StartflughafenNummer
AND FH2.FlughafenNummer = FI.ZielflughafenNummer;

2.2.3. SELECT

BuchungsklasseNummer, COUNT(*)
Buchung
FlugintervallNummer = ’xyz’

FROM
WHERE
GROUP BY BuchungsklasseNummer
COUNT > 0;
HAVING

2.2.4. SELECT

FROM

FlugNummer, SUM(Preis)
Buchung B, Flug F, Flugintervall FI,
Flugpreis FP, Buchungsklasse BK


------------------------------------------------------------------------
Frühjahr 02 - Thema 1

349

WHERE

B.BuchungsklasseNummer = BK.BuchungsklasseNummer
AND B.FlugintervallNummer = FI.FlugintervallNummer
AND F.FlugNummer = FI.FlugNummer
AND FP.BuchungsklasseNummer = BK.BuchungsklasseNummer
AND FP.FlugintervallNummer = FI.FlugintervallNummer

GROUP BY F.FlugNummer
HAVING

F.Flugnummer=’xyz’;

Frühjahr 02 - Thema 1

Aufgabe 1

In einer Datenbank beﬁnden sich Relationen mit den folgenden Relationensche-
mata (Schlüsselattribute sind jeweils unterstrichen):
LOrt
Lieferant

Waren WNr WarenBez

Rechtsform

LName

Preis

LNr

Kunden

KNr

KName

KOrt

Bestellung

LNr

KNr WNr

Datum Anzahl

1.1. Geben Sie für die folgenden verbal formulierten Anfragen jeweils Anfrage-
formulierungen in zwei verschiedenen Anfragesprachen bzw. -formalismen
an (zur Auswahl stehen dabei SQL, Relationenalgebra, Tupelkalkül und
QBE (Query by Example))!

a) Geben Sie alle Paare von Lieferanten(-namen) und Kunden(-namen)
aus, bei denen der Kunde bei dem Lieferanten Waren bestellt hat
und Kunde und Lieferant sich am gleichen Ort beﬁnden!

b) Geben Sie alle Waren (mit allen Attributen) aus, zu denen es mindes-
tens zwei Lieferanten mit unterschiedlicher Rechtsform gibt, bei de-
nen Kunden diese Waren bestellt haben!

1.2. Formulieren Sie die folgenden Anfragen in SQL:

a) Berechnen Sie für jeden Lieferanten die Anzahl der Kunden, die Wa-
ren bei diesem Lieferanten bestellt haben! Geben Sie dazu Lieferan-
tennamen und die Anzahl der Kunden aus!

b) Geben Sie für jeden Tag die Gesamtanzahl an bestellten Waren aus!
c) Berechnen Sie für jeden Kunden (unter Angabe des Kundennamens)

den Gesamtpreis aller von dem Kunden bestellten Waren!

1.1.

a) SELECT LName, KName

relationales
Schema,
Datenbank-
anfrage,
relationale
Algebra

FROM
WHERE

Lieferant L, Kunden K, Bestellung B
K.KOrt = L.LOrt
AND L.LNr = B.LNr
AND B.KNr = K.KNr;

πLN ame,KN ameσKOrt=LOrt(Lief erant ./ Kunden ./ Bestellung)


------------------------------------------------------------------------
350

5 Datenbanken

b) SELECT DISTINCT WNr, WarenBez, Preis

FROM

Lieferant L1, Lieferant L2,
Bestellung B1, Bestellung B2, Waren W

WHERE B1.WNr = B2.WNr

B1.WNr = W.WNr
AND B1.LNr <> B2.LNr
AND B1.LNr = L1.LNr
AND B2.LNr = L2.LNr
AND L1.Rechtsform <> L2.Rechtsform;

B1(WNr, WarenBez, Preis, LNr, Rechtsform):= (Lief erant ./ W aren ./ Bestellung)
B2(WNr, WarenBez, Preis, LNr, Rechtsform):= (Lief erant ./ W aren ./ Bestellung)

π W N r,W arenBez,P reis

(B1 ./B1.LN r6=B2.LN R∧B1.Rechtsf orm6=B2.Rechtsf orm∧B1.W N r=B2.W N r B2)

1.2.

a) SELECT
FROM
WHERE
GROUP BY LNr;

LName, COUNT(DISTINCT KNr)
Lieferant L, Bestellung B
L.LNr = B.LNr

b) SELECT
FROM
GROUP BY Datum;

Datum, SUM(Anzahl)
Bestellung B

c) SELECT
FROM
WHERE

KName, SUM(W.Preis * B.Anzahl) AS Gesamtpreis
Kunden K, Waren W, Bestellung B
W.WNr = B.WNR
AND K.KNr = B.KNr

GROUP BY KNr;

Frühjahr 02 - Thema 2

Aufgabe 3

funktionale
Abhängig-
keit,
Normalisie-
rung

Gegeben seien die folgenden Relationenschemata R1, R2, R3 und R4 mit ihren
Attributen und zugehörigen funktionalen Abhängigkeiten (FDs):
R1 : ABCD

FDs : A → BCD,

FDs: EF → G,

R2 : EF GH

F → H

B → C,
C → D

R3 : IKLM

FDs : I → K,
K → L,
L → M

R4 : OP QR

FDs: OP → Q,

P → R,
QR → P,
R → O


------------------------------------------------------------------------
Frühjahr 02 - Thema 2

351

3.1. Bestimmen Sie für jede Relation alle möglichen Schlüssel(-kandidaten)!
3.2. Geben Sie für jedes der oben aufgeführten Relationenschemata an, ob es in
2. Normalform (2NF) und ob es in 3. Normalform (3NF) ist. Begründen
Sie dies jeweils kurz!

3.3. Für die Relationenschemata, die nicht in 2NF bzw. 3NF sind, geben Sie
bitte neue Relationenschemata in 3NF an. Erläutern Sie die dazu
durchzuführenden Schritte jeweils kurz!

3.1. R1 : {A} - wegen der ersten FD werden mit A bereits alle anderen Attribute

erreicht.
R2 : {E, F }, da mit FD2 G nicht erreicht würde, muss auch E zum Schlüssel
gehören.
R3 : {I} - mittels FD1, FD2 und anschließend FD3 werden alle Attribute
erreicht.
R4 : {P } - hier müssen die FDs in der Reihenfolge FD2, FD4 und dann FD1
angewendet werden, um alle Attribute zu erreichen.

3.2. Alle Relationenschemata mit einelementigen Schlüsseln sind automatisch in

2NF. Dies triﬀt auf R1, R3 und R4 zu.
R2 ist nicht in 2NF, da durch die FD F → H ein Element nur von einem
Teil des Schlüssels abhängt.
Keines der übrigen Relationenschemata ist in 3NF, da überall transitive
Abhängigkeiten existieren, z. B. A → B → C bei R1.

3.3. Zu R1:

In der ersten FD gibt es transitive Abhängigkeiten wegen der beiden letzten
FDs. Um 3NF zu erhalten, muss man die FDs A → B, B → C, C → D zu
Grunde legen, um die Relationen R11 : AB, R11 : BC, R13 : CD als 3NF-
Zerlegung von R1 zu erhalten.
Zu R2:
Die Relation wird in zwei Relationen aufgeteilt: R21 : EF G und R22 : F H.
Diese können nicht weiter zusammengefasst werden.
Zu R3:
Analog zu R2 wird aufgespalten: R31 : IK, R32 : KL und R33 : LM
Zu R4: Die Zerlegung in einfache FDs ist bereits gegeben.
Linksreduktion und Rechtsreduktion ergeben keine änderung, somit liegt
bereits die kanonische überdeckung vor.
R41 : OP Q
R42 : P R
R43 : P QR
R44 : OR

R42 kann mit R43 zusammengefasst werden:
R41 : OP Q
R423 : P QR
R44 : OR


------------------------------------------------------------------------
352

5 Datenbanken

Herbst 02 - Thema 1

Aufgabe 1

ER-Model-
lierung,
relationales
Schema,
Verfeine-
rung,
SQL

Es soll eine Datenbank für ein Konzert-Auskunftsystem für München entworfen
werden. Das System soll vergangene und zukünftige Konzertveranstaltungen
enthalten können.
Entity Mengen:
Dirigenten

Konzerte

Komponisten
Musikstücke

Konzertsäle

mit den Attributen NAME, VORNAME, GEB-DATUM,
VITA
mit dem Attribut BEZEICHNUNG und einem künstlichen
Schlüssel KONZERT# vom Typ integer
mit den selben Attributen wie Dirigenten
mit dem Attribut TITEL und einem künstlichen
Schlüssel TITEL# vom Typ integer
mit den Attributen SAALNAME, ADRESSE,
TELEFON-NR

Relationsships:
dirigiert
komponierte
wird gespielt
ﬁndet statt

ein Dirigent dirigiert ein Konzert.
ein Komponist komponierte ein Musikstück.
ein Musikstück wird gespielt in einem Konzert.
ein Konzert ﬁndet in einem Konzertsaal statt an einem Tag
und Uhrzeit.

1.1 Integritätsbedingungen

Neben den oﬀensichtlichen Integritätsbedingungen sollen folgende gelten:

I1: ein Konzert wird nur von einem Dirigenten dirigiert.
I2: ein Konzert kann mehrmals, auch in verschiedenen Konzertsälen statt-

ﬁnden.

I3: TITEL#, KONZERT#, SAALNAME sind eindeutig für Musikstü-
cke, Konzerte und Konzertsäle, sowie die Kombination NAME,
VORNAME für Dirigenten und Komponisten.

1.2 E/R Diagramm

1. Entwerfen Sie für die Datenbank ein E/R Diagramm entsprechend den

obigen Speziﬁkationen und Integritätsbedingungen!
2. Geben Sie die Kardinalitäten für die Relationships an!
3. Geben Sie für jede Entität die Mengen der Schlüsselkandidaten an!
4. Geben Sie die Attribute der Relationsships an!
5. Ergänzen Sie die Relationship

wird gespielt“ so, dass die Reihenfol-
”

ge der Musikstücke im Konzert ersichtlich ist!

1.3 Relationales Schema

Geben Sie zu dem entwickelten E/R Diagramm ein relationales Schema an
und kennzeichnen Sie durch Unterstreichen die gewählten Primärschlüssel!


------------------------------------------------------------------------
Herbst 02 - Thema 1

1.4 SQL-Anfragen

353

Formulieren Sie für das relationale Schema die folgenden Anfragen bzw.
Operationen in SQL:

I1: Welche Dirigenten (NAME, VORNAME, GEB-DATUM) haben je in

München ein Konzert dirigiert?

I2: Welche Konzerte (KONZERT#, BEZEICHNUNG) dirigiert Lorin

Mazel?

I3: Finden Sie NAME, VORNAME und VITA des Dirigenten von
Herkulessaal“ am 1.1.2002 um 20Uhr!
”

jahrskonzert 2002“ im

I4: In welchen Konzerten (KONZERT#, BEZEICHNUNG) dirigiert

Neu-
”

Claudio Abbado ein Stück von Claude Debussy?

I5: In welcher Konzertveranstaltung wird heute

Rhapsody in Blue“ ge-
”

spielt, wo und zu welcher Zeit (KONZERT#, KONZERTSAAL,
UHRZEIT)?

I6: Führen Sie folgende Programmänderung aus: im Konzert mit der

KONZERT# = 123 wird statt dem Stück ST üCK# = 234 das Stück
ST üCK# = 345 gespielt!

V O R N A M E

G E B - D A T U M

V O R N A M E

G E B - D A T U M

N A M E

K o m p o n i s t

V I T A

N A M E

D i r i g e n t

V I T A

1

k o m p o n i e r t e

n

P R O G R A M M #

1

d i r i g i e r t

n

A D R E S S E

S A A L N A M E

T E L E F O N - N R

T A G

M u s i k s t u e c k

m

w i r d _ g e s p i e l t

n

K o n z e r t

m

f i n d e t _ s t a t t

n

K o n z e r t s a a l

T I T E L #

T I T E L

K O N Z E R T #

B E Z E I C H N U N G

U H R Z E I T

1.3 Schüsselkandidaten sind:

Komponist: {NAME,VORNAME}
Musikstueck: {TITEL#}
Konzert: {KONZERT#}
Dirigent: {NAME, VORNAME}
Konzertsaal: {SAALNAME}, {TELEFON-NR}

1.4 Komponist(NAME,VORNAME, Geb-Datum, Vita)
Dirirgent(NAME,VORNAME, Geb-Datum, Vita)
Musikstueck(TITEL#, Titel)
Konzert(KONZERT#, Bezeichnung)
Konzertsaal(SAALNAME, Adresse, Telefon-Nr)
findet statt(SAALNAME, Konzert#, Uhrzeit, Tag)


------------------------------------------------------------------------
354

5 Datenbanken

wird gespielt(Titel#, Konzert#, Programm#)
komponierte(KompName, KompVorname, Titel#)
dirigiert(DirName, DirVorname, Konzert#)

Verfeinerung des relationalen Schemas:

Komponist(NAME,VORNAME, Geb-Datum, Vita, Titel#)
Dirirgent(NAME,VORNAME, Geb-Datum, Vita, Konzert#)
Musikstueck(TITEL#, Titel)
Konzert(KONZERT#, Bezeichnung)
Konzertsaal(SAALNAME, Adresse, Telefon-Nr)
findet statt(SAALNAME, Konzert#, Uhrzeit, Tag)
wird gespielt(Titel#, Konzert#, Programm#)

1.5 Nachdem nur Konzerte in München in der Datenbank sind, müssen alle

vorhandenen Dirigenten selektiert werden.

SELECT Name, Vorname, Geb-Datum
FROM

Dirigent;

SELECT K.Konzert#, Bezeichnung
FROM
WHERE D.Vorname = ’Lorin’

Dirigent D, Konzert K

AND D.Name = ’Mazel’
AND D.Konzert# = K.Konzert#;

SELECT Name, Vorname, Vita
FROM
WHERE f.Uhrzeit = 20:00

Dirigent D, Konzert K, findet statt f

AND f.Tag = 1.1.2002
AND K.Bezeichnung = ’Neujahrskonzert 2002’
AND K.Konzert# = f.Konzert#
AND D.Konzert# = K.Konzert#;

SELECT Konzert#, Bezeichnung
FROM
WHERE Ko.Name = ’Debussy’

Konzert K, Dirigent D, wird gespielt w, Komponist Ko

AND Ko.Vorname = ’Claude’
AND Ko.Titel# = w.Titel#
AND w.Konzert# = K.Konzert#
AND K.Konzert# = D.Konzert#
AND D.Name = ’Abbado’
AND D.Vorname = ’Claude’;

SELECT K.Konzert#, Saalname, Uhrzeit
FROM

Konzert K,findet statt f,wird gespielt g,Musikstueck M


------------------------------------------------------------------------
Herbst 02 - Thema 2

355

WHERE

M.Titel = ’Rhapsody in Blue’
AND M.Titel# = g.Titel#
AND g.Konzert# = f.Konzert#
AND f.Tag = ’today’;

UPDATE Konzert
SET
WHERE

Stück# = 345
Stück# = 234
AND Konzert# = 123;

Herbst 02 - Thema 2

Aufgabe 1

In einer Datenbank beﬁnden sich Relationen mit den folgenden Relationensche-
mata (Schlüsselattribute sind jeweils kursiv geschrieben):

SQL,
relationale
Algebra

Teilnehmer MatrNr Name Vorname Fachsemester Geburtstag

Ergebnisse AufgNr MatrNr Punkte

Aufgaben AufgNr Abgabedatum MaxPunkte

1. Geben Sie für die folgenden verbal formulierten Anfragen jeweils eine An-
frageformulierung in der Datenbanksprache SQL an! Darüber hinaus ge-
ben Sie jeweils eine Anfrageformulierung in einem weiteren Anfrageforma-
lismus an (zur Auswahl stehen dabei Relationenalgebra, Tupelkalkül und
QBE (Query by Example))!

a) Geben Sie alle Teilnehmer aus, die mindestens in einer Aufgabe die
maximal erreichbare Punktzahl erreicht haben (wobei ein Teilneh-
mer nicht mehrfach ausgegeben werden soll)!

b) Geben Sie alle Teilnehmer aus, die mindestens in zwei (verschiede-
nen) Aufgaben die maximal erreichbare Punktzahl erreicht haben!

c) Geben Sie für den Teilnehmer

Hans Wurst“ eine Liste aller bearbei-
”

teten Aufgaben mit der jeweils von ihm erreichten Punktzahl sowie
der maximal erreichbaren Punktzahl für diese Aufgabe aus!

2. Formulieren Sie die folgenden Anfragen in SQL:

a) Geben Sie eine Anfrage an, die eine Ergebnisliste erstellt, in der für je-
den Teilnehmer die Summe der insgesamt von diesem Teilnehmer er-
reichten Punkte aufgeführt sind!


------------------------------------------------------------------------
356

5 Datenbanken

b) Berechnen Sie für jeden Teilnehmer die durchschnittlich erreichte

Punktzahl, wobei nur die bearbeiteten Aufgaben für jeden Teilneh-
mer berücksichtigt werden sollen.

c) Geben Sie Namen und Vornamen aller Teilnehmer aus, die nicht mehr

als 10 Aufgaben bearbeitet haben!

d) Geben Sie für jede Fachsemesterzahl die Fachsemesterzahl zusammen
mit der Anzahl der Teilnehmer aus diesem Fachsemester aus, die min-
destens in einer Aufgabe die maximal erreichbare Punktzahl erreicht
haben!

1.

a) SELECT DISTINCT MatrNr, Name, Vorname

FROM
WHERE E.AufgabenNr = A.AufgabenNr

Teilnehmer T, Ergebnisse E, Aufgaben A

AND E.Punkte = A.MaxPunkte
AND E.MatrNr = T.MatrNr;

πM atrNr,Name,V orname
(T eilnehmer ./σ E.P unkte=A.M axP unkte(Ergebnisse ./ Auf gaben))

b) SELECT
FROM
WHERE

DISTINCT MatrNr, Name, Vorname
Teilnehmer T, Ergebnisse E, Aufgaben A
E.AufgabenNr = A.AufgabenNr
AND E.Punkte = A.MaxPunkte
AND E.MatrNr = T.MatrNr

GROUP BY MatrNr
HAVING COUNT > 2;
Die relationale Algebra ist nicht mächtig genug, um andere Anfrage-
sprachen, speziell SQL, vollständig abbilden zu können. So gibt es z.
B. keine Möglichkeit, die SQL-Operatoren GROUP BY/HAVING und
Aggregatfunktionen in die relationale Algebra zu übersetzen.

c) SELECT E.AufgabenNr, Punkte, MaxPunkte

FROM
WHERE T.Name = ’Wurst’

Teilnehmer T, Ergebnisse E, Aufgaben A

AND T.Vorname = ’Hans’
AND E.MatrNr = T.MatrNr
AND E.AufgabenNr = A.AufgabenNr;

π E.Auf gabenNr,P unkte,M axP unkte
((σ T.Name=0W urst0∧T.V orname=0Hans0 T eilnehmer)
./ Ergebnisse ./ Auf gaben)

2.

a) SELECT
FROM
GROUP BY MatrNr;

MatrNr, SUM(Punkte)
Aufgaben


------------------------------------------------------------------------
Herbst 02 - Thema 2

357

b) SELECT
FROM
GROUP BY MatrNr;

MatrNr, AVG(Punkte)
Ergebnisse

Name, Vorname
Aufgaben A, Teilnehmer T
T.MatrNr = A.MatrNr

c) SELECT
FROM
WHERE
GROUP BY MatrNr
HAVING

COUNT < 11;

d) SELECT
FROM
WHERE

Fachsemester, COUNT(MatrNr)
Teilnehmer T, Ergebnisse E, Aufgaben A
E.AufgabenNr = A.AufgabenNr
AND E.Punkte = A.MaxPunkte
AND E.MatrNr = T.MatrNr

GROUP BY Fachsemester;

Aufgabe 2

Normal-
formen,
relationales
Schema,
Normalisie-
rung,
Schlüssel
(-kandidat)

Gegeben sei ein Relationenschema R mit Attributen A, B, C, D. Für dieses Re-
lationenschema seien die folgenden Mengen an funktionalen Abhängigkeiten
(FDs) gegeben.
A → B,
B → C,
A → D,

AB → C,
B → D

b)

a)

c)

A → B,
B → C,
C → D,
C → A

d)

e)

AB → C,
AC → D,
AD → B

AB → C,
A → D,
CD → A

1. Bestimmen Sie für das Relationschema R für jede der angegebenen Mengen
an funktionalen Abhängigkeiten jeweils alle möglichen Schlüssel(-kandida-
ten)!

2. Geben Sie für jede der Mengen an funktionalen Abhängigkeiten an, ob das
Relationenschema R in 2. Normalform (2NF) und ob es in 3. Normalform
(3NF) ist. Begründen Sie dies jeweils kurz!

3. Für die Fälle, in denen R nicht in 2NF bzw. 3NF ist, geben Sie bitte neue
Relationenschemata in 3NF an! Erläutern Sie die dazu durchzuführenden
Schritte jeweils kurz!


------------------------------------------------------------------------
358

5 Datenbanken

4. Untersuchen Sie für die Fälle d) und e), ob das Relationenschema in Boyce-
Codd-Normalform (BCNF) ist! Geben Sie jeweils eine kurze Begründung
an! Wenn das Relationenschema nicht in BCNF ist, erläutern Sie, ob eine
Zerlegung in eine semantisch äquivalente Menge an Relationenschemata
in BCNF möglich ist.

1. Ein Schlüsselkandidat ist eine minimale Menge von Attributen, von denen
aus man über die gegebenen FDs jedes andere Attribut erreichen kann.
Ra : {{A}}
Rb : {{A}, {C}}
Rc : {{A, B}}
Rd : {{A, B}, {A, C}, {A, D}}
Re : {{A, B}}

2. 2NF:

Bei den Relationenschemata mit einelementigen Schlüsselkandidaten ist die
2NF automatisch erfüllt, denn eine Abhängigkeit von einer Teilmenge des
Schlüsselkandidaten ist unmöglich. Dies triﬀt auf Ra und Rb zu. Rc ist auf-
grund der FD B → D nicht in 2NF, da B eine Teilmenge des Schlüsselkandi-
daten ist. Gleiches gilt für Re und die FD A → D. Für Rd wiederum ist die
2NF erfüllt, da egal welcher Schlüssel gewählt wird, niemals eine Teilmenge
dieses Schlüssels auf der linken Seite einer FD steht.
3NF:
Nachdem die 2NF Voraussetzung für die 3NF ist, sind Rc und Re nicht in
3NF. Ra ist nicht in 3NF, da die transitive Abhängigkeit A → B → C be-
steht. Gleiches gilt für Rb und A → B → C bzw. C → A → B. Bei Rd
bestehen keine transitiven Abhängigkeiten, da auf der linken Seite jeweils 2
Attribute und auf der rechten immer nur ein Attribut stehen. Rd ist demnach
in 3NF.

3. Für die Umwandlung in 3NF werden die Relationenschemata aufgespalten:

Ra wird zu Ra1 und Ra2 mit A → B, A → D sowie B → C.
Rb muss in drei Relationen aufgespalten werden:
A → B, B → C und C → D, C → A
Rc wird zu Rc1 und Rc2 mit AB → C sowie B → D.
Re muss wiederum in drei Teilrelationen zerlegt werden:
AB → C sowie A → D und CD → A

4. Für die BCNF muss gelten, dass auf der linken Seite der FDs Superschlüssel
stehen oder die FD trivial ist. Da wegen Teilaufgabe 1. bekannt ist, dass alle
linken Seiten von Rd Schlüsselkandidaten und damit Superschlüssel sind, ist
Rd in BCNF.
Bei Re verletzen die zweite und dritte FD die BCNF, da auf der linken
Seite kein Superschlüssel steht. Eine sinnvolle Zerlegung in BCNF ist hier
nicht möglich, da alle FDs das Attribut A enthalten. Wenn Re aufgespalten
wird, enthält nur eines der Relationenschemata Re1 und Re2 das Attribut
A. Das andere wiederum enthält keine FDs, in denen A vorkommt. Folglich
hat dieses Schema keine einzige FD.


------------------------------------------------------------------------
Frühjahr 03 - Thema 1

359

Frühjahr 03 - Thema 1

Aufgabe 4

ER-Model-
lierung,
relationales
Schema,
Schlüssel,
Funktiona-
lität,
Kardinali-
tät

Betrachten Sie die folgende Miniwelt der deutschen Bundesbahn. Es gibt Bahnhö-
fe, Zugabschnitte und Züge. Bahnhöfe haben einen Namen, eine Stadt und eine
Adresse. Ein Zugabschnitt verbindet zwei Bahnhöfe. Züge haben eine Num-
mer, einen Namen und sind einem Startbahnhof und einem Endbahnhof sowie
mehreren Abschnitten zugeordnet. Zum Beispiel könnte ein Zug von München
nach Hamburg fahren und dabei die Abschnitte München-Augsburg, Augsburg-
Stuttgart, Stuttgart-Mannheim, usw. passieren. Zu den Zügen soll abgespeichert
werden, zu welchen Uhrzeiten sie auf jedem Bahnhof ankommen und losfahren.
Des Weiteren verkehren nicht alle Züge täglich. Es soll also erfasst werden, an
welchen Tagen ein Zug fährt. Sie können annehmen, dass kein Zug mehrmals
an einem Tag verkehrt.
1. Zeichnen Sie die Attribute, Entitäten und Beziehungen eines ER-Diag-

ramms, das diese Miniwelt modelliert.

2. Geben Sie die Funktionalitäten der Beziehungen in Ihrem ER-Diagramm

an!

3. Geben Sie die Kardinalitäten (in min-max Notation) der Beziehungen in

Ihrem ER-Diagramm an!

4. übersetzen Sie Ihr ER-Diagramm in ein äquivalentes relationales Schema!
5. Unterstreichen Sie alle möglichen Schlüssel in Ihrem relationalen Schema!

1.

S t a d t

B e z e i c h n u n g

N a m e

A d r e s s e

B a h n h o f

2

( 1 , * )

v e r b i n d e t

n

( 2 , 2 )

Z u g a b s c h n i t t

( 0 , * )

1

( 0 , * )

1

S t a r t b a h n h o f

E n d b a h n h o f

T a g

f a e h r t

( 0 , 1 )

n

A b f a h r t s z e i t

( 1 , * )

1

A n k u n f t s z e i t

( 1 , 1 )

n

( 1 , 1 )

n

Z u g

N u m m e r

N a m e

2. s. ER-Diagramm!


------------------------------------------------------------------------
360

5 Datenbanken

3. s. ER-Diagramm!

4. Bahnhof(Name, Stadt, Adresse)
Zugabschnitt(Bezeichnung)
Zug(Nummer, Name)
faehrt(Abfahrtszeit, Ankunftszeit, Tag, ZugNr, Zugabschnitt)
verbindet(BName, BStadt, Zugabschnitt)
startbahnhof(BName, BStadt, ZugNr)
endbahnhof(BName, BStadt, ZugNr)

5. s. 4.!

Aufgabe 5

SQL Gegeben seien die folgenden drei Relationen. Diese Relationen erfassen die
Mitarbeiterverwaltung eines Untemehmens. Schlüssel sind fett dargestellt und
Fremdschlüssel sind kursiv dargestellt. So werden Mitarbeiter, Abteilungen und
Untemehmen jeweils durch ihre Nummer identiﬁziert. AbtNr ist die Nummer
der Abteilung, in der ein Mitarbeiter arbeitet. Manager ist die Nummer des Mit-
arbeiters, der die Abteilung leitet. UntNr ist die Nummer des Unternehmens,
dem eine Abteilung zugeordnet ist.

Mitarbeiter(Nummer, Name, Alter, Gehalt, AbtNr)
Abteilung(Nummer, Name, Budget, Manager, UntNr)
Unternehmen(Nummer, Name, Adresse)

Stellen Sie folgende Anfragen in SQL.

1. Wie hoch ist das Durchschnittsalter der Abteilung

ternehmen

Test.com“?
”

Personal Care“ im Un-
”

2. Geben Sie für jedes Unternehmen das Durchschnittsalter der Mitarbeiter

an!

3. Wie viele Mitarbeiter im Unternehmen

(D. h. sind älter als der Manager der Abteilung, in der sie arbeiten.)

4. Welche Abteilungen haben ein geringeres Budget als die Summe der Gehäl-

ter der Mitarbeiter, die in der Abteilung arbeiten?

Test.com“ sind älter als ihr Chef?
”


------------------------------------------------------------------------
Frühjahr 03 - Thema 1

361

Führen Sie folgende änderungen in SQL durch.

Wagner“ in die Abteilung
”

e) Versetzen Sie den Mitarbeiter
f) Löschen Sie die Abteilung
Personal Care“ mit allen ihren Mitarbeitern!
”
g) Geben Sie den Managern aller Abteilungen, die ihr Budget nicht überzie-
hen, eine 10 Prozent Gehaltserhöhung. (Das Budget ist überzogen, wenn
die Gehälter der Mitarbeiter höher sind als das Budget der Abteilung.)
Zusatzfrage: Was passiert mit Mitarbeitern, die Manager von mehreren Ab-
teilungen sind?

Personal Care“!
”

1. SELECT AVG(Alter)

FROM
WHERE

Mitarbeiter M, Abteilung A, Unternehmen U
U.Name = ’Test.com’
AND U.Nummer = A.UntNr
AND A.Name = ’Personal Care’
AND A.Nummer = M.AbtNr;

2. SELECT
FROM
WHERE

U.Name, AVG(Alter)
Mitarbeiter M, Abteilung A, Unternehmen U
U.Nummer = A.UntNr
AND A.Nummer = M.AbtNr

GROUP BY U.Nummer;

3. SELECT
FROM
WHERE

COUNT(M.Nummer)
Mitarbeiter M, Abteilung A, Unternehmen U
U.Name = ’Test.com’
AND U.Nummer = A.UntNr
AND M.AbtNr = A.Nummer
AND M.Alter > (SELECT Alter

Abteilung B, Mitarbeiter M

FROM
WHERE B.Manager = M.Nummer)
A.Nummer = B.Nummer);
AND

4. CREATE VIEW LowBudget AS

(Diese Anweisung wird für Teilaufgabe 7 benötigt!)
SELECT
FROM
WHERE

A.Nummer, A.Name
Mitarbeiter M, Abteilung A
A.Budget < (SELECT

FROM
WHERE
AND

SUM(Gehalt)
Abteilung B, Mitarbeiter M
B.Nummer = M.AbtNr
A.Nummer = B.Nummer);


------------------------------------------------------------------------
362

5 Datenbanken

5. UPDATE Mitarbeiter

SET

AbtNr = (SELECT

FROM
WHERE

WHERE Name = ’Wagner’;

AbtNr
Abteilung
Name = ’Personal Care’)

Anmerkung: Hier muss man davon ausgehen, dass es nur einen Mitarbei-
ter Wagner gibt, denn seine ihn sicher identiﬁzierende Nummer ist nicht
gegeben!

6. DELETE FROM Mitarbeiter
WHERE AbtNr = (SELECT

FROM
WHERE

AbtNr
Abteilung
Name = ’Personal Care’)

DELETE FROM Abteilung
WHERE Name = ’Personal Care’;

7. UPDATE Mitarbeiter

SET
Gehalt = 1.1*Gehalt
WHERE Abteilung.Manager = Nummer

AND Abteilung.Nummer IN LowBudget;

(Siehe Teilaufgabe 4!)
Das Gehalt dieser Mitarbeiter würde mehrfach (Anzahl der geführten ent-
sprechenden Abteilungen) erhöht werden.

Frühjahr 03 - Thema 2

Aufgabe 2

Normal-
form,
relationales
Schema,
Normalisie-
rung,
Anomalien

Zeigen Sie formal, dass das nachfolgende relationale Schema einer Relation Stu-
denten nicht in dritter Normalform ist!

Studenten: {[MatrNr, Name, Semester, Universitaet, Fakultaet, Dekan,
Rektor]}

Begründen Sie intuitiv, warum es zweckmäßig ist, eine Relation in die dritte
Normalform umzuwandeln! Zeigen Sie dazu die so genannten Anomalien auf,
die bei fehlender Normalisierung auftreten können!
Normalisieren Sie die obige Relation Studenten, indem Sie sie in mehrere Rela-
tionen zerlegen, die alle in 3. Normalform sind! Zeigen Sie detailliert die Vorge-
hensweise bei der Normalisierung auf!


------------------------------------------------------------------------
Frühjahr 03 - Thema 2

363

MatrNr, Universitaet → Name, Semester, Fakultaet
Universitaet → Rektor
Universitaet, Fakultaet → Dekan
Aus {MatrNr, Universität, Fakultaet} ergibt sich oﬀenbar die gesamte Relation;
mit keiner Teilmenge davon lassen sich alle Attribute erreichen, {MatrNr, Univer-
sität, Fakultaet} ist also minimaler Superschlüssel und somit Schlüsselkandidat.
Dekan ist von MatrNr, Universität transitiv über Universität, Fakultät abhängig
⇒ die Relation ist nicht in 3NF.

Durch die dritte Normalform werden Anomalien verhindert und es kann nicht zu
einem inkonsistenten Datenbestand kommen.

UPDATE-Anomalie: Ein Datensatz müsste an mehreren Stellen geändert werden,
dies kann aber leicht übersehen werden.
INSERT-Anomalie: Fakultäten können z. B. erst angelegt werden, wenn der Dekan
bekannt ist.
DELETE-Anomalie: Wird der letzte Studierende einer Fakultät gelöscht, sind auch
deren Informationen nicht mehr vorhanden.

• Dekomposition:

MatrNr, Universitaet → Name
MatrNr, Universitaet → Semester
MatrNr, Universitaet → Fakultaet
Universitaet → Rektor
Universitaet, Fakultaet → Dekan

• Linksreduktion:

Da auf der linken Seite der vierten FD nur ein einzelnes Attribut steht, kann
es hier keine redundanten Attribute geben. In den anderen Fällen sind aber
weder durch Universitaet noch durch MatrNr bzw. Fakultaet alleine die
rechts stehenden Attribute erreichbar. Also ist auch hier kein redundantes
Attribut vorhanden.

• Rechtsreduktion:

Da jedes Attribut auf der rechten Seite der FDs nur einmal vorkommt, kann
es keine redundanten FDs geben.

• Zusammenfassen:

MatrNr, Universitaet → Name, Semester, Fakultaet
Universitaet → Rektor
Universitaet, Fakultaet → Dekan

• Erstellen der FDs:

R1(M atrN r, U niversitaet, N ame, Semester, F akultaet)
R2(U niversitaet, Rektor)
R3(U niversitaet, F akultaet, Dekan)

• Da R1 bereits den (einzigen) Schlüsselkandidaten

{M atrN r, U niversitaet, F akultaet} enthält, wird keine weitere Relation be-
nötigt.

• Die drei Relationen enthalten bereits alle Attribute und somit ist auch hierfür

keine weitere Relation nötig.


------------------------------------------------------------------------
364

5 Datenbanken

Aufgabe 3

SQL Gegeben sei folgendes relationales Schema, das eine Universitätsverwaltung mo-

delliert:
Studenten:
Vorlesungen: {[VorlNr: integer, Titel: string, SWS: integer,

{[MatrNr: integer, Name: string, Semester: integer]}

gelesenVon: integer]}

Professoren: {[PersNr: integer, Name: string, Rang: string, Raum: integer]}
hören:
voraussetzen: {[VorgängerVorlNr: integer, NachfolgerVorlNr: integer,

{[MatrNr: integer, VorlNr: integer]}

prüfen:

VorlNr: integer]}
{[MatrNr: integer, VorlNr: integer, PrüferPersNr: integer,

Note: decimal]}

Formulieren Sie folgende Anfragen in SQL:
(a) Alle Vorlesungen zusammen mit der Anzahl ihrer Hörer.
(b) Alle Vorlesungen, die von Sokrates gehalten werden.
(c) Die Studenten, die alle Vorlesungen von Sokrates gehört haben.
(d) Die Durchschnittsnoten aller Studenten desselben Semesters.
(e) Die Studenten/Studentinnen mit der besten Durchschnittsnote.

(a) SELECT
FROM
GROUP BY VorlNr;

VorlNr, COUNT(MatrNr)
hören

(b) SELECT VorlNr

FROM
WHERE gelesen Von = PersNr

Vorlesungen, Professoren

AND Name = ’Sokrates’;

y

y

(c) (siehe Herbst 03 Thema 1 Aufgabe 5e) auf Seite 370)

(d) SELECT
FROM
WHERE
GROUP BY Semester;

Semester, AVG(Note)
Studenten, prüfen
Studenten.MatrNr = prüfen.MatrNr

(e) (siehe Herbst 03 Thema 1 Aufgabe 5b) auf Seite 369)


------------------------------------------------------------------------
Herbst 03 - Thema 1

365

Aufgabe 4

Erläutern Sie die Funktionsweise des B-Baums. Zeigen Sie graphisch, was pas-
siert, wenn nacheinander die Schlüssel 4, 6, 1, 3, 2, 10, 9, 7, 11, 8, 5 eingefügt
werden. Wir nehmen an, dass die Knoten des B-Baums eine Kapazität von vier
haben. Geben Sie allgemein an, wie hoch ein B-Baum mit insgesamt N Ein-
trägen bei einer Knotenkapazität von k Datensätzen ist! Als konkretes Beispiel
geben Sie die Höhe eines B-Baums mit 1 Milliarde Einträgen bei einer Knoten-
kapazität von 100 Einträgen an.

B-Baum

Die Höhe beträgt logk(N ), im Beispiel also log100(1000000000) = 4, 5.

Herbst 03 - Thema 1

Aufgabe 3

Modellieren Sie eine Bibliothek. Es sollten zumindest die folgenden Konzepte
abgedeckt werden:
• Autoren haben Bücher geschrieben.
• Leser leihen Bücher aus.
• Leser geben diese ausgeliehenen Bücher (hoﬀentlich) irgendwann wieder zu-

ER-Model-
lierung,
relationales
Schema,
Schlüssel,
Datenbank-
anfrage

rück.


------------------------------------------------------------------------
366

5 Datenbanken

Modellieren Sie diese Miniwelt zunächst als ER-Diagramm! Diese konzeptuelle
ER-Modellierung sollte dann in ein relationales Schema transformiert werden.
Geben Sie die Schlüssel der Relationen an! Auf der Basis Ihres relationalen
Schemas formulieren Sie folgende Anfrage: Wie viele Leser namens Bohlen ha-
Nichts als die Wahrheit“ ausgeliehen und noch
ben ein Buch mit dem Titel
”
nicht zurückgegeben?

N a m e

V o r n a m e

L e s e r N r

N a m e

V o r n a m e

A d r e s s e

A u t o r

1

h a t _ g e s c h r i e b e n

n

I S B N

B u c h

E x e m p l a r

T i t e l

L e s e r

n

l e i h t _ a u s

m

A u s l e i h d a t u m

R u e c k g a b e d a t u m

Bemerkung:
Die (sicher nicht sehr elegante und wirklichkeitsnahe) Modellierung geht davon
aus, dass jedes Buch nur von einem Autor geschrieben wurde. Beim Anlegen und
Pﬂegen der Datenbank müsste hier sehr darauf geachtet werden, dass wirklich bei
jedem Exemplar eines Buches der gleiche Autor eingegeben wird. Exemplar wurde
aber als Attribut eingeführt, damit nicht jedes Buch nur einmal in der Bibliothek
vorhanden ist. Jeder Leser darf an einem bestimmten Tag nur eine Ausleihe täti-
gen.
Rückgabedatum stellt das Datum der tatsächlichen Rückgabe dar und ist mit NULL
vorbesetzt.
Autor{Name, Vorname}
Buch{ISBN, Exemplar, Titel
Leser{LeserNr, Name, Vorname, Adresse}
hat geschrieben{ISBN, Exemplar, AutorName, AutorVorname}
leiht aus{Ausleihdatum, LeserNr, ISBN, Exemplar, Rueckgabedatum}

SELECT COUNT(*)
FROM
WHERE Name = ’Bohlen’

Leser, Buch, leiht aus

AND Leser.LeserNr = leiht aus.LeserNr
AND Buch.ISBN = leiht aus.ISBN
AND Buch.Titel = ’Nichts als die Wahrheit’
AND Rueckgabedatum = NULL;


------------------------------------------------------------------------
Herbst 03 - Thema 1

367

Aufgabe 4

Zeigen Sie formal, dass das nachfolgende relationale Schema einer Relation Uni-
versitäten nicht in dritter Normalform ist!

Universitäten: {[UniName, Professor, Fakultät, Dekan, Studiendekan, Rektor]}

Wir gehen dabei davon aus, dass Professoren eindeutige Namen haben. Zur Er-
innerung: eine Universität hat i. Allg. mehrere Fakultäten, Professoren gehören
einer Fakultät einer Universität an, eine Universität hat einen Rektor, eine Fa-
kultät hat einen Dekan und einen Studiendekan.
Begründen Sie intuitiv, warum es zweckmäßig ist, eine Relation in die dritte
Normalform umzuwandeln! Zeigen Sie dazu die so genannten Anomalien auf,
die bei fehlender Normalisierung auftreten können!
Normalisieren Sie die obige Relation Universitäten, indem Sie den Syntheseal-
gorithmus anwenden! Zeigen Sie detailliert die Vorgehensweise bei der Norma-
lisierung auf!

Normal-
form,
relationales
Schema,
Normalisie-
rung,
Synthese-
algorith-
mus,
Anomalien

Professor → UniName, Fakultaet
UniName → Rektor
UniName, Fakultät → Dekan, Studiendekan
Aus {Professor} ergibt sich oﬀenbar die gesamte Relation; {Professor} ist also
minimaler Superschlüssel und somit Schlüsselkandidat.
Dekan, Studiendekan ist von Professor transitiv über UniName, Fakultät abhängig
⇒ die Relation ist nicht in 3NF.

Durch die dritte Normalform werden Anomalien verhindert und es kann nicht zu
einem inkonsistenten Datenbestand kommen.

UPDATE-Anomalie: Ein Datensatz müsste an mehreren Stellen geändert werden,
dies kann aber leicht übersehen werden.
INSERT-Anomalie: Fakultäten können z. B. erst angelegt werden, wenn der Dekan
bekannt ist.
DELETE-Anomalie: Wird der letzte Professor einer Fakultät gelöscht, sind auch
deren Informationen nicht mehr vorhanden.

• Dekomposition:

Professor → UniName
Professor → Fakultaet
UniName → Rektor
UniName, Fakultät → Dekan
UniName, Fakultät → Studiendekan

• Linksreduktion:

Da auf der linken Seite der ersten drei FDs nur einzelne Attribute ste-
hen, kann es hier keine redundanten Attribute geben. In den beiden letzten
Fällen ist aber weder durch UniName noch durch Fakultät alleine Dekan
bzw. Studiendekan erreichbar. Also ist auch hier kein redundantes Attribut
vorhanden.


------------------------------------------------------------------------
368

5 Datenbanken

• Rechtsreduktion:

Da jedes Attribut auf der rechten Seite der FDs nur einmal vorkommt, kann
es keine redundanten FDs geben.

• Zusammenfassen:

Professor → UniName, Fakultaet
UniName → Rektor
UniName, Fakultät → Dekan, Studiendekan

• Erstellen der FDs:

R1(P rof essor, U niN ame, F akultaet)
R2(U niN ame, Rektor)
R3(F akultaet, Dekan, Studiendekan)

• Da R1 bereits den (einzigen) Schlüsselkandidaten {P rof essor} enthält, wird

keine weitere Relation benötigt.

• Die drei Relationen enthalten bereits alle Attribute und somit ist auch hierfür

keine weitere Relation nötig.

Aufgabe 5

SQL-Anfra-
gen,
Relationen-
algebra

Gegeben sei folgendes relationales Schema, das eine Universitätsverwaltung mo-
delliert:
{[MatrNr:integer, Name:string, Semester:integer]}
Studenten
Vorlesungen {[VorlNr:integer, Titel:string, SWS:integer, gelesenVon:integer] }
Professoren {[PersNr:integer, Name:string, Rang:string, Raum:integer] }
hören
voraussetzen {[VorgängerVorlNr:integer, NachfolgerVorlNr:integer]}
{[MatrNr:integer, VorlNr:integer, PrüferPersNr:integer,
prüfen

{[MatrNr:integer, VorlNr:integer]}

Note:decimal]}

Formulieren Sie die folgenden Anfragen in SQL:
a) Alle Studenten, die den Professor Kant aus einer Vorlesung kennen.

b) Die Studenten, die die beste Durchschnittsnote ihrer Prüfungen haben.


------------------------------------------------------------------------
Herbst 03 - Thema 1

369

c) Geben Sie eine Liste der Professoren (Name, PersNr) mit ihrem Lehrdepu-
tat (Summe der SWS der gelesenen Vorlesungen) aus. Ordnen Sie diese Lis-
te so, dass sie absteigend nach Lehrdeputat sortiert ist! Bei gleicher Lehrtä-
tigkeit dann noch aufsteigend nach dem Namen des Professors/der Professo-
rin.

d) Geben Sie eine Liste der Studenten (Name, MatrNr, Semester) aus, die

mindestens zwei Vorlesungen bei Kant gehört haben.

e) Geben Sie eine Liste der Studenten aus, die alle Vorlesungen von Sokrates

gehört haben.

f) Geben Sie eine Liste der Studenten aus, die nur Vorlesungen von Sokrates

gehört haben.

Geben Sie verbal an, welches Ergebnis folgende SQL-Anfrage liefert:
SELECT s1.Name, s2.Name
FROM
WHERE

Studenten s1, hören h1, Studenten s2, hören h2
s1. MatrNr = h1.MatrNr
AND h1.VorlNr = h2.VorlNr
AND h2.MatrNr = s2.MatrNr;

Geben Sie einen Relationenalgebra-Ausdruck für diese Anfrage an. Dieser Aus-
druck sollte keine Kreuzprodukte (nur Joins) enthalten.

a) SELECT MatrNr, Studenten.Name

FROM
WHERE

Vorlesungen, hören, Studenten, Professoren
Professoren.Name = ’Kant’
AND Professoren.PersNr = Vorlesungen.gelesenVon
AND Vorlesungen.VorlNr = hören.VorlNr
AND hören.MatrNr = Studenten.MatrNr;

b) SELECT
FROM
WHERE
GROUP BY MatrNr;

MatrNr, Name, MIN(AVG(Note))
Studenten, prüfen
Studenten.MatrNr = prüfen.MatrNr

Name, PersNr, SUM(SWS) AS Deputat
Vorlesungen, Professoren
gelesenVon = PersNr

c) SELECT
FROM
WHERE
GROUP BY PersNr
ORDER BY Deputat DESC, Name ASC;

d) SELECT MatrNr, Studenten.Name, Semester

FROM
WHERE

Vorlesungen, hören, Studenten, Professoren
Professoren.Name = ’Kant’
AND Professoren.PersNr = Vorlesungen.gelesenVon
AND Vorlesungen.VorlNr = hören.VorlNr
AND hören.MatrNr = Studenten.MatrNr

GROUP BYMatrNr
HAVING COUNT(VorlNr) > 1;


------------------------------------------------------------------------
370

5 Datenbanken

e) SELECT Name

FROM
WHERE S.MatrNr = h.MatrNr AND

Studenten S, hoeren h

h.VorlNr = all

(SELECT VorlNr

FROM
WHERE gelesenVon = PersNr AND Name = ’Sokrates’;);

Vorlesungen, Professoren

f) SELECT Name

FROM
WHERE S.MatrNr = h.MatrNr AND

Studenten S, hoeren h

h.VorlNr not exists

(SELECT VorlNr

FROM
WHERE gelesenVon = PersNr AND Name <> ’Sokrates’;);

Vorlesungen, Professoren

Es handelt sich hier um alle Paare von Studenten, die die gleiche Vorlesung gehört
haben. Dabei werden auch die Paare (student1, student1) sowie (student1, stu-
dent2) und (student2, student1) selektiert.

πs1.N ame,s2.N ame((s1 ./ h1) ./h1.V orlN r=h2.V orlN r (s2 ./ h2))

Aufgabe 6

B-Baum ln den meisten Datenbanksystemen wird standardmäßig ein B-Baum als Index-
struktur angelegt. Erläutern Sie die Funktionsweise des B-Baums! Zeigen Sie
graphisch, was passiert, wenn nacheinander die Schlüssel

1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10

eingefügt werden! Wir nehmen an, dass die Knoten des B-Baums eine Kapazität
von vier haben.

Ein B-Baum erlaubt im Gegensatz zum binären Suchbaum auch die sogenannte
externe Suche wie z. B. Suche von Festplattenspeicheradressen. Hier werden im-
mer ganze Bereiche der Platte herausgegriﬀen und auf diesen gesucht.
B-Bäume sind höhenbalancierte (Such-)Bäume, bei denen alle Blätter auf gleichem
Niveau liegen.


------------------------------------------------------------------------
Herbst 03 - Thema 1

371

Jeder Knoten eines B-Baums der Ordnung m enthält höchstens 2m Schlüssel
und (mit Ausnahme der Wurzel) mindestens m Schlüssel. Jeder Knoten mit k
Schlüsseln besitzt genau k + 1 Söhne oder keinen Sohn. Alle Knoten ohne Söhne
beﬁnden sich auf gleichem Niveau.
Um in einem B-Baum mit n Knoten der Ordnung m einen Wert zu suchen, muss
man höchstens logm+1(n)-mal auf die Platte zugreifen. B-Bäume sind somit gut
geeignet für die Verwaltung großer, sich ständig verändernder Datenmengen, auf
die häuﬁg zugegriﬀen werden muss.
Um in einem B-Baum einen bestimmten Schlüssel s zu ﬁnden, prüft man begin-
nend bei der Wurzel, ob sich s im gerade betrachteten Knoten x beﬁndet. Falls dies
nicht der Fall ist und x kein Blatt ist, stellt man fest, zwischen welchen Schlüsseln
si und si+1 von x der Schlüssel s liegt und setzt die Suche beim entsprechenden
Sohn von x fort bis man bei einem Blatt angekommen ist.
Eingefügt wird bei einem B-Baum grundsätzlich nur in den Blättern. Das entspre-
chende Blatt wird durch den oben beschriebenen Suchvorgang identiﬁziert. Falls
durch das Einfügen die Kapazität des Blattes überschritten wird, wird es aufge-
spaltet und der mittlere Schlüssel vom Vater übernommen, was sich ggf. rekursiv
bis zur Wurzel fortsetzt. Läuft die Wurzel über, wird sie geteilt und der Baum
wächst um eine Ebene.
Das Löschen eines Schlüssels kann dazu führen, dass zu wenige Schlüssel in einem
Knoten stehen, was dazu führt, dass dieser wieder aufgefüllt werden muss. Dabei
kann es zur Verschmelzung von Blättern kommen. Die sehr aufwändige Vorgehens-
weise hierzu sowie weitere Informationen ﬁnden sich in [DUD].

(cid:28)

------------------------------------------------------------------------
372

5 Datenbanken

Herbst 03 - Thema 2

Aufgabe 1

Normalfor-
men,
relationales
Schema,
Normalisie-
rung,
funktionale
Abhängig-
keiten

Gegeben sei die folgende relationale Datenbank mit den oﬀenen Rechnungen
der Kunden eines Versandhauses:

Rechnung

RNR
1
2
3
4
5
6

KDNR
1
1
1
1
1
1

Name
Adresse
Müller München
Müller München
Nürnberg
Huber
Nürnberg
Huber
Augsburg
Meier
München
Meier

Positionen
3
2
3
8
7
12

Datum
01.11.2002
23.05.2003
09.03.2003
14.02.2003
20.06.2003
07.04.2003

Betrag
60
90
90
70
110
90

1. Erläutern Sie, warum nur Relationen mit einem zusammengesetzten

Schlüsselkandidaten die 2. Normalform verletzen können.

2. Geben Sie für obige Datenbank alle vollen funktionalen Abhängigkeiten

(einschließlich der transitiven) an!

3. Erläutern Sie, inwiefern obiges Schema die 3. Normalform verletzt.
4. überführen Sie das obige Relationenschema in die 3. Normalform!
Erläutern Sie die dazu durchzuführenden Schritte jeweils kurz!

5. Erläutern Sie, inwiefern sich eine vollständige Normalisierung nachteilig

auf die Geschwindigkeit der Anfragebearbeitung auswirken kann und wie
darauf reagiert werden kann!

1. Bei in zweiter Normalform vorliegenden Schemata sind sämtliche nicht zum
Schlüsselkandidaten gehörenden Attribute voll funktional abhängig von die-
sem Schlüsselkandidaten. Besteht der Schlüsselkandidat nur aus einem ein-
zigen Attribut, müssen zwangsläuﬁg alle anderen Attribute voll funktional
von diesem abhängig sein.

2. KDNR → Name, Adresse

RNR → KDNR, Positionen, Datum, Betrag

3. Da Name, Adresse transitiv über KDNR von RNR abhängt, ist die 3NF ver-

letzt.

4. KDNR → Name
KDNR → Name
RNR → KDNR
RNR → Positionen
RNR → Datum
RNR → Betrag
Da auf der linken Seite jeweils nur einzelne Attribute stehen, gibt es keine
redundanten Attribute.
Da auf der rechten Seite jedes Attribut nur einmal vorkommt, gibt es keine
redundanten FDs.


------------------------------------------------------------------------
Herbst 03 - Thema 2

373

Die Zusammenfassung liefert wieder das obige:
KDNR → Name, Adresse
RNR → KDNR, Positionen, Datum, Betrag
Der Schlüsselkandidat RNR ist in der zweiten Relation enthalten und außer-
dem sind alle Attribute in den beiden Relationen vorhanden, so dass keine
weiteren Relationen mehr nötig sind.

5. Bei vollständiger Normalisierung entstehen viele Tabellen und deshalb sind
entsprechend viele JOINs für eine Anfrage nötig. Da ein JOIN ein kartesi-
sches Produkt mit anschließender Selektion darstellt, entstehen bei der An-
frage zwischendurch sehr viele Tupel. Die Antwortzeit der Datenbank erhöht
sich dadurch signiﬁkant. Statt der 3NF kann auch die BCNF verwendet wer-
den, die aber nicht mehr abhängigkeitserhaltend ist.

Aufgabe 2

Gegeben sei das folgende relationale Datenbankschema (Schlüsselattribute sind
jeweils unterstrichen):
Lehrer (PNR, LName, Fachgebiet)
Schüler (SNR, SName, Adresse, KNR)
Klasse (KNR, Raum, Jahrgangsstufe)
Fach (FNR, FName, Stundenzahl)
unterrichtet (PNR, KNR, FNR)
In der Datenbank sind die Daten von Lehrern, Schülern, Klassen und Fächern
einer Schule gespeichert. Ein Lehrer hat dabei eine Personalnummer (PNR),
einen Namen und ein Fachgebiet. Schüler haben neben einer Identiﬁkations-
nummer (SNR) einen Namen, eine Adresse und gehören einer einzigen Klasse
an. Klassen sind eindeutig durch ihre Klassennummer (KNR) bestimmt und
ihnen ist ein Klassenraum und eine Jahrgangstufe zugeordnet. Eine Klasse wird
von genau einem Lehrer in einem Fach unterrichtet. Ein Lehrer kann jedoch
dieselbe Klasse in unterschiedlichen Fächern unterrichten.

Rechnung

RNR
1
2
3
4
5
6

KDNR
1
1
1
1
1
1

Name
Adresse
Müller München
Müller München
Nürnberg
Huber
Nürnberg
Huber
Augsburg
Meier
München
Meier

Positionen
3
2
3
8
7
12

Datum
01.11.2002
23.05.2003
09.03.2003
14.02.2003
20.06.2003
07.04.2003

Betrag
60
90
90
70
110
90

1. Geben Sie für die folgenden verbal formulierten Anfragen jeweils eine

Anfrageformulierung in relationaler Algebra an.

a) Bestimmen Sie die Namen und Adressen aller Schüler der 5. Jahr-

gangsstufe!

b) Bestimmen Sie die Namen aller Lehrer, die jeweils jede Klasse der

6. Jahrgangsstufe unterrichten!

c) Geben Sie die Namen aller Schüler an, die von einem Lehrer in einem
Fach unterrichtet werden, das nicht dem Fachgebiet dieses Lehrers
entspricht!

SQL-Anfra-
gen,
Relationen-
algebra


------------------------------------------------------------------------
374

5 Datenbanken

2. Formulieren Sie die folgenden Anfragen in SQL:

a) Bestimmen Sie für jede Jahrgangstufe die durchschnittliche Anzahl an

Schülern in einer Klasse!

b) Erstellen Sie eine alphabetisch sortierte Liste mit den Namen aller Leh-
rer, die jedes Fach unterrichten, unabhängig von einer konkreten Klas-
se.

c) Erstellen Sie eine Liste aller Lehrer, die nur Klassen mit mehr als 30

1.

Schülern unterrichten!
a) πSN ame,Adresse σJahrgangsstufe=5(Klasse ./ Schueler)
b) πLN ame(σJahrgangsstufe=6(unterrichtet ./ Lehrer ./ Klasse)
c) πSN ameSchueler ./ ((unterrichtet ./ Lehrer)

÷ σJahrgangsstufe=6Klasse)

./F N ame6=F achgebiet F ach)

2.

a) SELECT
FROM

Jahrgangsstufe, AVG(Anzahl)
Klasse, (SELECT

KNR AS KlBez, COUNT(*) AS Anzahl
Schueler

FROM
GROUP BY KNR;)

WHERE
GROUP BY Jahrgangsstufe;

KNR = KlBez

b) SELECT
FROM
WHERE

LName
Lehrer l, unterrichtet u
u.PNR = l.PNR
AND u.FNR = all (SELECT FNR

FROM

Fach;)

ORDER BY LName;

c) SELECT LName

Lehrer
FROM
WHERE PNR not exists

(SELECT PNR

unterrichtet u, Klasse k, Schueler s

FROM
WHERE u.KNr = k.KNr AND k.KNR = s.KNR
HAVING COUNT(SNr) <= 30);


------------------------------------------------------------------------
Frühjahr 04 - Thema 1

375

Frühjahr 04 - Thema 1

Aufgabe 4

ER-Model-
lierung,
Entity,
Relation-
ship,
Attribut,
Kardinali-
tät, Rolle,
Unterklas-
se,
Schlüssel

Erläutern Sie die nachfolgenden Konzepte eines ER-Modells:

Entität, Relationship, Attribut, Kardinalität, Rolle, Unterklasse, Schlüssel

Das ER-Modell geht davon aus, dass sich die betrachtete Miniwelt durch Ob-
jekte (Entitäten) und Beziehungen zwischen diesen Objekten (Relationships) be-
schreiben lässt. Unter Entitäten versteht man wohlunterscheidbare physisch oder
gedanklich existierende Konzepte der zu modellierenden Welt. Entitäten und Re-
lationships können durch Attribute näher charakterisiert werden. Dabei handelt
es sich um Eigenschaften, die für jede Entität bzw. jede Relationship durch ent-
sprechende Werte, die Attributwerte, konkretisiert werden. Gleichartige Entitäten,
d. h. Entitäten, die durch gleiche Attribute charakterisiert sind, werden zu En-
titäts-Typen abstrahiert. Entitäts-Typen haben einen Namen und eine Menge von
Attributen. Einen Entitäts-Typ kann man auch als Menge von gleichartigen En-
titäten auﬀassen. Die Entitäten, die zu einem Entitäts-Typen gehören, sind durch
konkrete Werte der Attribute konkretisiert. Analog werden die tatsächlichen Be-
ziehungen gleicher Art zwischen konkreten Entitäten zu Relationship-Typen (Be-
ziehungstypen) abstrahiert. Ein wichtiges Charakteristikum von Beziehungstypen
ist ihre Kardinalität. Dadurch wird zum Ausdruck gebracht, mit wie vielen En-
titäten eine gegebene Entität in Beziehung stehen kann. Die Kardianlität muss
beim Datenbankentwurf durch die Analyse der Rahmenbedingungen erkannt wer-
den. Man unterscheidet die Kardinalitäten 1:1, n:1, 1:n und n:m. Entitäten können
in Beziehungen zudem eine Rolle übernehmen, die ein sematisches Beschreibungs-
element darstellt. über die
is a“-Beziehung können zu einer Entität auch Un-
”
terklassen gestaltet werden. Dabei besitzt die Unterklasse alle Attribute und den
Primärschlüssel der Oberklasse sowie zusätzliche Attribute. Erläuterungen zum
Begriﬀ Schlüssel siehe Aufgabe 5!

Aufgabe 5

Erläutern Sie informell die Begriﬀe:

Schlüsselkandidat, Primärschlüssel, Fremdschlüssel, referentielle Integrität

Die eindeutige Identiﬁzierung der Tupel einer Relation ist über deren Attributwerte
möglich. Dabei müssen aber in der Regel nicht alle Werte des Tupels herangezogen
werden. Die Attribute, die die eindeutige Identiﬁzierung eines Tupels gewährlei-
sten, heißen Schlüssel. Ein sogenannter Superschlüssel einer Relation ist eine Men-
ge von Attributen, deren Attributwerte jedes Tupel innerhalb der Relation eindeu-
tig festlegen. Jede Relation hat mindestens einen Superschlüssel. Im ungünstigsten

ER-Model-
lierung,
Schlüssel-
kandidat,
Primär-
schlüssel,
Fremd-
schlüssel,
referentielle
Integrität


------------------------------------------------------------------------
376

5 Datenbanken

Fall ist es die Menge aller Attribute der Relation. Im Allgemeinen gibt es in einer
Relation mehrere Superschlüssel. Ein Schlüsselkandidat ist ein in dem Sinne mini-
maler Superschlüssel, dass keine seiner Teilmengen bereits ein Superschlüssel der
Relation ist. Im Allgemeinen gibt es in einer Relation mehrere Schlüsselkandidaten.
Gibt es mehrere Schlüsselkandidaten, so können diese durchaus unterschiedlich vie-
le Elemente besitzen. Einer der Schlüsselkandidaten wird beim Datenbankentwurf
dann vom Entwickler als Primärschlüssel ausgewählt. Der Primärschlüssel wird
dann zur eindeutigen Identiﬁzierung von Tupeln verwendet. Relationen, die aus
entstanden“ sind, besitzen Fremdschlüssel. Ein Fremdschlüssel
Beziehungstypen
”
ist dabei folgendermaßen deﬁniert: Wir betrachten zwei verschiedene Relationen
R und S. Dann heißt der Primärschlüssel von S Fremdschlüssel von S in R, falls er
auch zum Relationenschema von R gehört. Die referentielle Integrität gewährlei-
stet, dass in einer Tabelle die Fremdschlüssel nur solche Werte annehmen können,
die in der referenzierten Tabelle der Beziehung bereits als Primärschlüssel angelegt
worden sind.

Aufgabe 6

ER-Model-
lierung,
Entity,
Relation-
ship

Erläutern Sie Grundprinzipien der Abbildung der Entities und der verschiede-
nen Relationship-Typen!

Zunächst entsteht aus jeder Entity und jeder Relationship eine Relation. Bei En-
tities besitzt diese Relation alle Attribute mit dem festgelegten Primärschlüssel.
Bei Relationships werden auch alle Attribute aufgenommen und zusätzlich die
Primärschlüssel aller beteiligten Entities als Fremdschlüssel. Der Primärschlüssel
einer solchen Relation hängt von den Kardinalitäten ab bzw. es kann auch ein
künstlicher Schlüssel eingefügt werden. Bei 1:n-Beziehungen ist der Primärschlüssel
der Entity, die nur einfach beteiligt ist, auch Primärschlüssel der Relationship.
Bei 1:1-Beziehungen kann einer der Primärschlüssel beliebig gewählt werden, bei
n:m-Beziehungen werden beide Primärschlüssel als zusammengesetzter Schüssel
verwendet. Im verfeinerten Relationenmodell können dann alle Relationen mit
gleichem Primärschlüssel zusammengefasst werden.

Aufgabe 7

SQL Für den Einkauf in einer Maschinenfabrik wird folgende Datenbank für die

Verwaltung der Bestände verwendet:

LIEFERANT(Name, Firmensitz, Ansprechpartner)
TEIL(Teil-Id, Bezeichnung)
LIEFERUNG(Lieferant-Id, Teil-Id, Lieferdatum, Stückzahl)

Die Primärschlüssel der Relationen sind unterstrichen. Lieferant-Id in LIEFE-
RUNG ist Fremdschlüssel zu Name in LIEFERANT. Teil-Id in LIEFERUNG
ist Fremdschlüssel zu Teil-Id in TEIL!


------------------------------------------------------------------------
Frühjahr 04 - Thema 1

377

a) Formulieren Sie die folgenden Datenbankanfragen in SQL:

• Welche Lieferanten haben ihren Firmensitz in Erlangen, Nürnberg

oder Fürth?

• Welche Bezeichnungen haben die Teile, bei denen eine Lieferung weni-

ger als 10 Stück umfasst?

b) Was bedeutet umgangssprachlich folgende Anfrage:

SELECT lf.Name

FROM Lieferant lf, Lieferung lg, Teil t
WHERE lf.Name = lg.Lieferant-Id
AND t.Teil-Id = lg.Teil-Id
AND t.Bezeichung = ’Bolzen’
AND lg.Stückzahl > 1000;

c) Geben Sie zu jeder Teilebezeichnung die Gesamtanzahl der gelieferten

Stücke an!

a)

• SELECT Name

FROM
WHERE
UNION
SELECT Name
FROM
WHERE
UNION
SELECT Name
FROM
WHERE

Lieferant
Firmensitz = ’Nuernberg’

Lieferant
Firmensitz = ’Fuerth’

Lieferant
Firmensitz = ’Erlangen’;

Alternativlösung:

SELECT Name
FROM
WHERE

Lieferant
Firmensitz IN (’Nuernberg’, ’Fuerth’, ’Erlangen’);

• SELECT T.Bezeichnung

FROM
WHERE
HAVING L.Stückzahl < 10;

Teil T, Lieferung L
T.Teil-ID = L.Teil-ID

b) Es werden die Namen aller Lieferanten ausgegeben, die mehr als 1000 Teile

mit der Bezeichnung ’Bolzen’ liefern.

c) SELECT
FROM
WHERE
GROUP BY T.Bezeichnung;

T.Bezeichnung, SUM(L.Stückzahl)
Teil T, Lieferung L
T.Teil-ID = L.Teil-ID


------------------------------------------------------------------------
378

5 Datenbanken

Aufgabe 8

Normalisie-
rung,
funktionale
Abhängig-
keit,
Normalfor-
men

a) Aus welchen Gründen wird eine Relation normalisiert?
b) Erläutern Sie den Begriﬀ der funktionalen Abhängigkeiten und wozu die-

ses Konzept verwendet wird!

c) Wie geht man prinzipiell bei der Normalisierung einer Relation vor? Ge-

hen Sie dabei auf die erste, zweite und dritte Normalform und die übergän-
ge zwischen ihnen ein!

a) Da sonst Anomalien auftreten und inkonsistente Datenbestände entstehen

können.
(weitere Ausführungen in Aufgabe 1f) von Frühjahr 07 - Thema 2 auf Sei-
te 427)

y

b) Seien A und B Teilmengen einer Relation. A heißt funktional abhängig von
B (geschrieben B → A), wenn gleiche Attributwerte in B auch gleiche At-
tributwerte in A erzwingen.
Funktionale Abhängigkeiten liegen bei den betrachteten Daten meist schon
vor. Z. B. besteht eine Abhängigkeit Strasse, Ort → P LZ. Diese Abhängig-
keiten werden genutzt um eine Relation entsprechend der Normalformen so
zu zerlegen, dass keine Anomalien mehr auftreten.

c) Für die 1NF müssen die Attributwerte aller Attribute atomar sein, was be-
deutet, dass es z. B. kein Attribut
Adresse“ mit Strasse, Hausnummer, Ort
”
und PLZ gibt, sondern dies vier einzelne Attribute sind. Für die Schaﬀung
der 1NF gibt es auch keinen expliziten Algorithmus, da die Attribute ein-
fach nur in atomare Attribute zerlegt werden müssen. Von der 1NF kann
auch direkt in die 3NF mittels des Synthesealgorithmus übergegangen wer-
den. (Ein Beispiel hierzu ﬁndet sich in Herbst 04 - Thema 2 Aufgabe 5 auf
Seite 388; weitere Informationen zu diesem Thema in [KEM].) Die 2NF for-
dert, dass es keine Attribute gibt, die nur von einer Teilmenge des Schlüssels
abhängig sind. Bei der überführung in 2NF wird eine Relation entsprechend
der funktionalen Abhängigkeiten in mehrere Relationen zerlegt, so dass die-
se Bedingung erfüllt ist. (siehe Herbst 02 - Thema 2 Aufgaben 2.2 und 2.3
auf Seite 358). Für die 3NF dürfen keine transitiven Abhängigkeiten mehr
vorhanden sein, d. h. FDs der Form A → B und B → C. Diese werden
wiederum durch Aufspalten der Relation in mehrere Teilrelationen besei-
tigt. (siehe wiederum Herbst 02 - Thema 2 Aufgaben 2.2 und 2.3 oder zum
Beispiel auch Frühjahr 08 - Thema 2 Aufgabe 2 auf Seite 465)

y

y

y

(cid:27)

------------------------------------------------------------------------
Frühjahr 04 - Thema 2

Aufgabe 9

379

Erläutern Sie die ACID-Eigenschaft einer Transaktion!
Welche Mechanismen werden verwendet, um die ACID-Eigenschaft umzuset-
zen?
Erläutern Sie kurz die Aufgaben dieser Mechanismen!

ACID-
Prinzip,
Transak-
tion

(s. Frühjahr 07 - Thema 1 Aufgabe 4 auf Seite 419 und Frühjahr 08 - Thema 1
Aufgabe 5 auf Seite 454)

x

Frühjahr 04 - Thema 2

Aufgabe 1

Erläutern Sie die nachfolgenden Konzepte eines ER-Modells:

Entität, Relationship/Beziehungstyp, Attribut, Kardinalität

(siehe Frühjahr 04 Thema 1 Aufgabe 4) auf Seite 375)

Aufgabe 2

Erläutern Sie informell die Begriﬀe:

Schlüsselkandidat, Primärschlüssel, Fremdschlüssel, referentielle Integrität

(siehe Frühjahr 04 Thema 1 Aufgabe 5) auf Seite 375)

Aufgabe 3

Gegeben sei folgende Relation. In ihr ist der Sachverhalt wiedergegeben, dass
in einer Firma Angestellte an Projekten arbeiten und zu Abteilungen gehören.

AngNr
4711
4711
0815
...

ProjNr
9
7
7
...

AbtNr
7
7
6
...

AngName
Meier
Meier
Huber
...

AbtName
Verkauf
Verkauf
Planung
...

AbtLeiter
007
007
123
...

ProjName
Diver
Tower
Tower
...

ProjLeiter
4711
0815
0815
...

a) Welche Probleme können bei der Arbeit mit dieser Tabelle auftreten?

Hinweis: Achten Sie auf die Beispieldaten in der Tabelle!

b) Beheben Sie diese Probleme! Wie heißt der allgemeine Lösungsansatz?

ER-Model-
lierung,
Entity,
Relation-
ship,
Attribut,
Kardinali-
tät

ER-Model-
lierung,
Schlüssel-
kandidat,
Primär-
schlüssel,
Fremd-
schlüssel,
referentielle
Integrität

Normalisie-
rung,
Anomalie,
ACID-
Prinzip


------------------------------------------------------------------------
380

5 Datenbanken

y

y

a) Es können Update-, Insert- und Delete-Anomalien auftreten.

(weitere Ausführungen in Aufgabe 2 von Frühjahr 03 - Thema 2 auf Seite 363
und Aufgabe 4 von Herbst 03 - Thema 1 auf Seite 367)

b) Diese Probleme werden durch (vollständige) Normalisierung behoben.
(Erläuterung siehe Frühjahr 07 - Thema 2 Aufgabe 1f auf Seite 427)
Es werden die FDs zu dieser Relation betrachtet:
AngNr → AbtNr, AngName, AbtLeiter
ProjNr → ProjName, ProjLeiter
ProjName → ProjLeiter
AbtNr → AbtName, AbtLeiter
AbtName → AbtLeiter
AbtLeiter → AbtNr
Um sowohl 2NF zu erhalten als auch transitive FDs zu vermeiden (also sogar
3NF herzustellen) und damit Anomalien zu verhindern, erhält man folgendes
Schema:
Angestellter(AngNr, AngName, AbtNr)
Abteilung(AbtNr, AbtName, AbtLeiter)
Projekt(ProjNr, ProjName, ProjLeiter)
Hierbei sind AbtLeiter und ProjLeiter Fremdschlüssel zu AngNr, da Ab-
teilungs- und Projektleiter auch Angestellte sind.

Aufgabe 4

SQL,
ER-Model-
lierung

Gegeben sei das folgende Flugbuchungsschema:

FLIGHT(FliqhtNr, Fluggesellschaft, ...)
FLIGHT INTERVALS(FlightID, FlightNr, FromAirport, ToAirport)
AIRPORT(AirportID, Ort)
BOOKING(PassengerID, FlightID, Datum)
PASSENGER(PassengerId, Name)

a) Zeichnen Sie das zu diesen Relationen gehörige ER-Diagramm!
b) Formulieren Sie die folgenden Datenbankanfragen in SQL:

i) Geben Sie all die Flugintervalle (FlightID) aus, die der Passagier

Müller“ gebucht hat!
”

ii) Gesucht ist die Anzahl der Buchungen je Flug (nicht Flugintervall!)!

c) Was bedeutet umgangssprachlich folgende Anfrage:

SELECT p.Name, a1.Ort. a2.Ort

FROM PASSENGER p, BOOKING b, FLIGHT INTERVALS f, AIRPORT a1,

AIRPORT a2

WHERE p.PassengerID = b.PassengerID

AND b.FlightID = f.FlightID
AND f.FromAirport = a1.AirportID
AND f.ToAirport = a2.AirportID;


------------------------------------------------------------------------
Frühjahr 04 - Thema 2

381

a)

F l u g g e s e l l s c h a f t

F l i g h t N r

D a t u m

F l i g h t

n

b o o k i n g

m

P a s s e n g e r I D

n

P a s s e n g e r

N a m e

F l i g h t I D

F l i g h t _ I n t e r v a l l s

p

f r o m

m

t o

A i r p o r t

A i r p o r t I D

O r t

b)

a) SELECT FlightID

FROM
WHERE

Flight Intervals F, Booking B, Passenger P
P.Name = ’Müller’
AND P.PassengerID = B.PassengerID
AND B.FlightID = F.FlightID;

b) SELECT
FROM
WHERE

COUNT(*)
Flight Intervals FI, Booking B, Flight F
B.FlightID = FI.FlightID
AND FI.FlightNr = F.FlightNr

GROUP BY F.FlightNr;

c) Es werden alle Passagiere mit jeweils sämtlichen Start- und Zielorten aller

ihrer Buchungen ausgegeben.

Aufgabe 5

Erläutern Sie die ACID-Eigenschaft einer Transaktion!

(s. Frühjahr 07 - Thema 1 Aufgabe 4 auf Seite 419 und Frühjahr 08 - Thema 1
Aufgabe 5 auf Seite 454)

ACID-
Prinzip,
Transak-
tion

x


------------------------------------------------------------------------
382

5 Datenbanken

Herbst 04 - Thema 1

Aufgabe 1

Super-
schlüssel,
Schlüssel-
kandidat,
relationales
Schema,
Normalfor-
men,
Normalisie-
rung,
Anomalien

Gegeben sei die folgende relationale Datenbank der Mietwagenﬁrma
Rent“, Station

Mobil-
”

München- Mitte“:
”

|

|

|

|

|

0

|gruppe| ge | station |

|Kd-| Name |Wohnort|Buchungs-|Aktion| Fahr- | Typ | Tarif- |Ta-|Rückgabe-|Stations-|
| zeug |
| Nr |
leiter |
| datum |
| Micra | Klein |
| 2 |Nürnberg-| Backus |
| 123 |Chomsky|Nürnberg| 23.01.04 |
|
|
|
|
|
|
|
| 1 |Nürnberg-| Hoare |
| 123 |Chomsky|Nürnberg| 07.10.03 | -25% |Sprinter|Transp|
|
|
|
|
|
|
|
|
| 2 | München- | Zuse
| Lupo | Klein |
| 220 |Neumann|München | 02.04.04 |
|
|
|
|
|
|
|
|
| 2 | München- | Zuse
| 710 | Turing |München | 20.02.04 | -10% | Micra | Klein |
|
|
|
|
|
|
|
| 5 | München- | Zuse
|Mittel-|
| 888 |Neumann| Passau | 07.10.03 | -25% | A3
|
|
| klasse |
|
|

| Mitte

| Mitte

| Mitte

| Nord

Süd

5

1

1

0

1

3

|

|

|

|

|

|

|

|

|

|

|

|

|

|

|

|

|

|

|

KdNr“ steht für die Kundennummer der Kunden. An bestimmten Tagen ge-
”
währt die Firma Rabatt. Folgende funktionale Abhängigkeiten seien vorgegeben:
KdNr → Name, Wohnort
KdNr, Buchungsdatum → Fahrzeug, Typ, Tarifgruppe, Tage, Rückgabestation,
Stationsleiter
Buchungsdatum → Aktion
Fahrzeug → Typ, Tarifgruppe
Typ → Tarifgruppe
Rückgabestation → Stationsleiter
a) Erklären Sie kurz den Unterschied zwischen

Schlüsselkandidat“ und
”

Superschlüssel“.
”

b) Erklären Sie, warum nur (KdNr, Buchungsdatum) als Schlüsselkandidat in

Frage kommt.

c) Begründen Sie, warum nur Relationen mit einem zusammengesetzten

Schlüsselkandidaten die 2. Normalform verletzen können.

d) Erläutern Sie, inwiefern obiges Schema die zweite bzw. dritte Normalform

verletzt. Zeigen Sie anhand obiger Relation
lien auf, die bei fehlender Normalisierung auftreten können.

MobilRent“ mögliche Anoma-
”

e) Begründen Sie, dass obiges Schema in erster Normalform ist und überfüh-
ren Sie es in die zweite, aber nicht in die dritte Normalform. Erläutern Sie
die dazu durchzuführenden Schritte jeweils kurz. Zeigen Sie, inwiefern die
entstandene Relation die dritte Normalform verletzt.

f) überführen Sie das Schema, ebenfalls mit kurzer Erläuterung, nun in die

dritte Normalform.

a) Aus einem Superschlüssel ergibt sich über die FDs die gesamte Relation.

Schlüsselkandidaten sind Superschlüssel, die minimal sind.

b) KdNr, Buchungsdatum tauchen bei keiner der FDs auf der rechten Seite auf.
Die Attributhülle von (KdNr, Buchungsdatum) ist die gesamte Relation.


------------------------------------------------------------------------
Herbst 04 - Thema 1

383

c) Bei in zweiter Normalform vorliegenden Schemata sind sämtliche nicht zum
Schlüsselkandidaten gehörenden Attribute voll funktional abhängig von die-
sem Schlüsselkandidaten. Besteht der Schlüsselkandidat nur aus einem ein-
zigen Attribut, müssen zwangsläuﬁg alle anderen Attribute voll funktional
von diesem abhängig sein.

d) Bei der ersten FD steht links die Teilmenge des Schlüsselkandidaten und
rechts nicht prime Attribute. ⇒ Verletzung von 2NF und damit auch Ver-
letzung von 3NF.
Wenn sich der Stationsleiter einer Rückgabestation ändert, muss dies bei
allen entsprechenden Kundenbuchungen durchgeführt werden. Passiert dies
nicht, kommt es zu einer UPDATE-Anomalie.
Es kann keine Buchung aufgenommen werden, ohne dass das zugehörige
Fahrzeug bereits mit eingegeben wird. Dies wird INSERT-Anomalie genannt.
Wenn die letzte Buchung mit einem bestimmten Fahrzeug gelöscht wird, ver-
liert man damit alle Informationen über dieses Fahrzeug. Dieser Eﬀekt heißt
eine DELETE-Anomalie.

e) In der Tabelle ist zu erkennen, dass alle Attribute atomar sind. ⇒ 1NF

Da KdNr und Buchungsdatum Teilmengen des Schlüsselkandidaten sind, wer-
den sie aus der Relation entfernt und wir erhalten:
Kunde{KdNr, Name, Wohnort}
Rabatt{Buchungsdatum, Aktion}
Buchung{KdNr, Buchungsdatum, Fahrzeug, Typ, Tarifgruppe, Tage,
Rückgabestation, Stationsleiter}
Wegen der transitiven Abhängigkeit von Tarifgruppe in den FDs 4 und 5 ist
die 3NF noch verletzt.

f) Für die 3. NF werden nun die transitiven Abhängigkeiten entfernt:

Kunde{KdNr, Name, Wohnort}
Rabatt{Buchungsdatum, Aktion}
Buchung{KdNr, Buchungsdatum, Fahrzeug, Tage, Rückgabestation}
Fahrzeug{Fahrzeug, Typ}
Typ{Typ, Tarifgruppe}
Rückgabestation{Rückgabestation, Stationsleiter}

Aufgabe 2

Für ein Transportunternehmen soll eine Datenbank für folgendes Szenario ent-
wickelt werden:
Die Firma verfügt über mehrere Abteilungen, die von jeweils einem Mitarbei-
ter geleitet werden, und jeder Mitarbeiter, von dem Name, Wohnort und Ge-
haltsstufe abgespeichert werden sollen, ist einer dieser Abteilungen eindeutig
zugeordnet. Der Betrieb besitzt mehrere Transporter verschiedener Typen.

ER-Model-
lierung,
Primär-
schlüssel,
künstlicher
Schlüssel


------------------------------------------------------------------------
384

5 Datenbanken

Diese unterscheiden sich durch Größe, maximale Nutzlast und benötigte Führer-
scheinklasse. Die einzelnen Fahrzeuge werden fortlaufend nummeriert und es soll
das Baujahr sowie der Termin zur nächsten Inspektion abgespeichert werden.
Neben den Verwaltungsangestellten (für Buchhaltung, Personal, Kundenbetreu-
ung etc.) und den hauseigenen KFZ-Meistern (zur LKW-Wartung) beschäftigt
das Logistikunternehmen natürlich insbesondere Fahrer. Bucht ein Kunde eine
Tour, so werden für diese wenigstens ein Fahrer und ein Transporter eingesetzt.
Von der gebuchten Tour müssen folgende Daten abrufbar sein: Buchungsdatum,
Termin und die Anzahl der benötigten LKWs. Von den Kunden müssen Name,
Wohnort und die zugehörige Firma vorliegen. Erstellen Sie ein E-R-Diagramm.
Verarbeiten Sie dabei nur die unbedingt notwendigen Informationen, geben Sie
aber an, wie die nicht im E-R-Modell auftauchenden Informationen bestimmt
werden können. Legen Sie auch die Primärschlüssel fest und begründen Sie Ihre
Entscheidung, falls Sie zusätzliche künstliche Schlüssel einfügen. Geben Sie die
Funktionalitäten an.

G e h a l t s s t u f e

N a m e

W o h n o r t

( 1 , 1 )

g e h o e r t _ z u

( 1 , * )

M i t a r b e i t e r

A b t e i l u n g

i s   a

i s   a

i s   a

( 0 , 1 )

l e i t e t

( 1 , 1 )

F a h r e r

K F Z - M e i s t e r

V e r w a l t u n g s a n g e s t e l l t e r

N a m e

( 1 , * )

W o h n o r t

K u n d e

( 1 , 1 )

b u c h t _ T o u r

( 1 , * )

T r a n s p o r t e r

( 1 , 1 )

h a t

( 0 , * )

T y p

F i r m a

F z N r

B a u j a h r

G r o e s s e

N u t z l a s t

T e r m i n

B D a t u m

I n s p e k t i o n s t e r m i n

F u e h r e r s c h e i n k l a s s e

Die Anzahl der LKWs, die an einer Tour beteiligt sind, wird nicht explizit abgespei-
chert, sondern kann über eine SELECT-Abfrage mit COUNT ermittelt werden.


------------------------------------------------------------------------
Herbst 04 - Thema 2

385

Herbst 04 - Thema 2

Aufgabe 3

Wir betrachten die Datenbank UNIVERSITäT mit den folgenden Beispieltabellen:
STUDENT

SQL

Matnr

147000
148000
...

Name

Semester Hauptfach

Schmidt
Maier
...

1
2
...

Informatik
Informatik
...

VORLESUNG

Vnr

Name

SWS

Fach

10640 Einführung in die Informatik
10650
10410
10780
...

Datenstrukturen
Diskrete Mathematik
Datenbanken
...

4
4
3
3
...

Informatik
Informatik
Mathematik
Informatik
...

Vnr

NOTENVERTEILUNG
Semester Matnr Note

SS 2002
10650
10650
SS 2002
10780 WS 0102

...

...

147000
148000
148000
...

3
1
2
...

VERANSTALTUNG

VORAUSSETZUNG

Dozent
Tarjan

Vnr
Semester
10650 WS 0102
10650
10780 WS 0102

...

SS 2002 Mehlhorn
Ullmann
...

...

hatVoraus
10650
10650
10780
...

istVoraus
10410
10640
10650
...

Erstellen Sie in SQL folgende Anfragen:
a) Bestimmen Sie alle Vorlesungen (Vnr, Name), die der Dozent

gehalten hat.

Ullman‘
’

b) Bestimmen Sie alle Studierenden (Matnr, Name), die in der Vorlesung

10780‘
’
eine Note erhalten haben.

c) Bestimmen Sie die Anzahl der Vorlesungen im Fach
Informatik‘.
’
d) Bestimmen Sie alle Voraussetzungen (Vnr, Name) der Vorlesung

strukturen‘.

Daten-
’

e) Bestimmen Sie für alle Studierenden (Matnr, Name) die Durchschnittsnoten

über alle ihre gehörten Vorlesungen.


------------------------------------------------------------------------
386

5 Datenbanken

a) SELECT Vnr, Name

FROM
WHERE Dozent = ’Ullman’ AND Vorlesung.Vnr = Veranstaltung.Vnr;

Vorlesung, Veranstaltung

b) SELECT Matnr, Name

FROM
WHERE Vnr = 10780 AND Notenverteilung.Matnr = Student.Matnr;

Student, Notenverteilung

c) SELECT COUNT(*)

FROM
WHERE Fach = ’Informatik’;

Vorlesung

d) SELECT Vnr, Name

FROM
Vorlesung, Voraussetzung
WHERE Name = ’Datenstrukturen’

AND Vorlesung.Vnr = Voraussetzung.istVoraus;

e) SELECT
FROM
WHERE
GROUP BY Matnr;

Matnr, Name, AVG(Note)
Student, Notenverteilung
Notenverteilung.Matnr = Student.Matnr

Aufgabe 4

ER-Model-
lierung,
Schlüssel,
Fremd-
schlüssel,
Relation-
ship,
Funktiona-
lität, SQL,
Relationen-
schema

Wir betrachten die Datenbank UNIVERSITäT aus Aufgabe 3.

a) Deﬁnieren Sie die Relationenschemas von UNIVERSITäT in SQL, und geben

Sie dabei geeignete Schlüssel und Fremdschlüssel an.

b) Fügen Sie in SQL in jede der Relationen

• STUDENT,
• VERANSTALTUNG und
• NOTENVERTEILUNG

aus Aufgabe 3 jeweils mindestens ein weiteres geeignetes Tupel ein, so dass
die natürlichen Schlüssel- und Fremdschlüsselbedingungen aus Teil a) er-
füllt sind.

c) Geben Sie ein ER-Diagramm (mit Funktionalitätsbedingungen) für das Da-
tenbankschema aus Aufgabe 3 an, in dem möglichst viele Relationen als Re-
lationships modelliert sind.

a) CREATE TABLE Student (

Matnr Integer PRIMARY KEY,
Name Varchar(255),
Semester Integer,
Hauptfach Varchar(255));

CREATE TABLE Vorlesung (

Vnr Integer PRIMARY KEY,


------------------------------------------------------------------------
Herbst 04 - Thema 2

387

Name Varchar(255) NOT NULL,
SWS Integer
Fach Varchar(255));

CREATE TABLE Veranstaltung (

Vnr Integer REFERENCES Vorlesung(Vnr),
Dozent Varchar(255),
Semester Varchar(255),
PRIMARY KEY (Vnr, Semester));

CREATE TABLE Voraussetzung (

hatVoraus Integer REFERENCES Vorlesung(Vnr),
istVoraus Integer REFERENCES Vorlesung(Vnr),
PRIMARY KEY (hatVoraus, istVoraus));

CREATE TABLE Notenverteilung (

Vnr Integer REFERENCES Vorlesung(Vnr),
Semester Varchar(255),
Matnr Integer REFERENCES Student(Matnr),
Note Integer,
PRIMARY KEY (Vnr, Matnr));

(Falls ein Student in einer Vorlesung mehrfach geprüft werden kann, muss
auch das Semester zum Primärschlüssel gehören.)

b) INSERT INTO Student VALUES (123445,’Mueller’,1,’Informatik’);

INSERT INTO Vorlesung VALUES (10651,’Theoretische Informatik’,

3,’Informatik’);

INSERT INTO Veranstaltung VALUES (10651,’Meier’,’WS0708’);
INSERT INTO Notenverteilung VALUES (10651,’WS0708’,123445,1);

c)

N a m e

M a t n r

S e m e s t e r

H a u p t f a c h

S t u d e n t

n

h a t N o t e

V n r

1

S W S

N a m e

F a c h

n

V o r l e s u n g

i s t V o r a u s s e t z u n g

S e m e s t e r

N o t e

m

m

w i r d V e r a n s t a l t e t

S e m e s t e r

n

D o z e n t

N a m e


------------------------------------------------------------------------
388

5 Datenbanken

Aufgabe 5

funktionale
Abhängig-
keit,
Attributhül-
le,
Syntheseal-
gorithmus,
3NF

Gegeben sei folgende Menge F von funktionalen Abhängigkeiten:
F = {BC → A, AC → DE, A → D}

a) Geben Sie zwei unterschiedliche Ableitungen für die funktionale Abhängig-

keit BC → D an.

b) Bestimmen Sie die Attributhülle von BC unter F .
c) Bestimmen Sie ein minimales System G für F . Bestimmen Sie mit dem Syn-
these-Algorithmus aus G eine 3NF-Zerlegung des Relationenschemas R,
mit der Attributmenge U = ABCDE und der Menge F von funktiona-
len Abhängigkeiten.

a) BC → A → D sowie BC → AC → D
b) Bestimmung von {BC}+
F :
F = {B, C} Initialisierung

1. {BC}+
2. überprüfe FD BC → A: ⇒ {BC}+
3. überprüfe FD AC → DE: ⇒ {BC}+
4. überprüfe FD A → D: ⇒ {BC}+

F = {A, B, C, D, E}
c) Zuerst muss die minimale überdeckung bestimmt werden:

F = {A, B, C}

F = {A, B, C, D, E}

1. Zerlege F in einfache FDs:

F = {BC → A, AC → D, AC → E, A → D}

2. Eliminiere redundante Attribute:

A → D kann keine redundanten Attribute enthalten.
Betrachte FD BC → A:
C redundant?
AttrHull(F, {B}) = {B} → C nicht redundant.
B redundant?
AttrHull(F, {C}) = {C} → B nicht redundant.
par Betrachte FD AC → D:
A ist nicht redundant, da AttrHull(F, {C}) = {C} (s. o.).
C redundant?
AttrHull(F, {A}) = {A, D} → C ist redundant.
G = {BC → A, AC → E, A → D}
Analog enthält AC → E keine redundaten Attribute.

3. Eliminiere redundante FDs:

Auf der rechten Seite aller FDs kommen die Attribute nur jeweils einmal
vor, so dass es keine redundanten FDs geben kann.


------------------------------------------------------------------------
Frühjahr 05 - Thema 1

389

Jetzt kann der Synthesealgorithmus angewendet werden:

1. Erstelle für jede FD eine Relation:

R1(A, B, C)
R2(A, C, E)
R3(A, D)

2. überprüfe, ob eine der Relationen bereits einen Schlüsselkandidaten

enthält:
BC sind die einzigen Attribute, die nicht auf der rechten Seite der FDs
vorkommen, also muss BC im Schlüsselkandidaten enthalten sein.
Da {BC}+
F = {A, B, C, D, E} ist, ist {BC} einziger Schlüsselkandidat.
R1 enthält den Schlüsselkandidaten und deshalb wird keine zusätzliche
Relation benötigt.

3. überprüfe, ob R = R1 ∪ R2 ∪ R3.

Dies ist erfüllt, es werden keine weiteren Relationen benötigt.
4. Die Relationen können nicht weiter zusammengefasst werden.

Frühjahr 05 - Thema 1

Aufgabe 4

Da die Aufgabenstellung identisch ist zu (Frühjahr 07 Thema 1 Aufgabe 1 auf
Seite 415) wird hier auf weitere Ausführungen verzichtet.

x

Aufgabe 5

Da die Aufgabenstellung identisch ist zu (Frühjahr 07 Thema 1 Aufgabe 3 auf
Seite 417) wird hier auf weitere Ausführungen verzichtet.

x

Aufgabe 6

Da die Aufgabenstellung identisch ist zu (Frühjahr 07 Thema 1 Aufgabe 5 auf
Seite 420) wird hier auf weitere Ausführungen verzichtet.

x

Aufgabe 7

Da die Aufgabenstellung identisch ist zu (Frühjahr 07 Thema 1 Aufgabe 6 auf
Seite 421) wird hier auf weitere Ausführungen verzichtet.

x

Aufgabe 8

Da die Aufgabenstellung identisch ist zu (Frühjahr 07 Thema 1 Aufgabe 7 auf
Seite 423) wird hier auf weitere Ausführungen verzichtet.

x


------------------------------------------------------------------------
390

5 Datenbanken

Frühjahr 05 - Thema 2

Aufgabe 9

Datenbank-
entwurf,
ER-Model-
lierung,
relationales
Schema,
funktionale
Abhängig-
keit,
Normal-
form, 2NF,
3NF, SQL

a) In einer Datenbank sind die Daten von Lehrern, Schülern, Klassen und Fä-
chern einer Schule gespeichert. Ein Lehrer hat dabei eine Personalnummer,
einen Namen, eine Adresse und eine Gehaltsstufe. Schüler haben neben ei-
ner Identiﬁkationsnummer einen Namen, eine Adresse und gehören einer
einzigen Klasse an. Klassen sind eindeutig durch ihre Klassennummer be-
stimmt und ihnen ist jeweils genau ein Klassenraum zugeordnet. Eine Klas-
se wird von genau einem Lehrer in einem Fach unterrichtet. Ein Lehrer
kann jedoch dieselbe Klasse in unterschiedlichen Fächern unterrichten. Zu-
sätzlich hat jeder Lehrer die Leitung maximal einer Klasse inne.

i) Erstellen Sie ein Entity-Relationship-Diagramm für obige Datenbank.
ii) Erläutern Sie, welche Möglichkeiten es gibt, um 1:n-Beziehungen aus

dem ER-Modell im relationalen Modell darzustellen!

b) Gegeben sei die nachfolgende relationale Datenbank. Sie enthält die Daten
der ausgeliehenen Filme einer Videothek. Dabei kann ein Film in mehre-
ren Kopien vorhanden sein. Ein Kunde kann aber nur eine Kopie eines Fil-
mes ausleihen:
|Leihgebühr|
|Ausleihe|FilmNr|Kdnr| Name | Adresse |
|
| 1 |Müller|München|
|
3
|
| 1 |Müller|München|Der Schuh des Manitu|
6
|
| 2 |Huber|Nürnberg|
|
4
|
| 2 |Huber|Nürnberg|Der Schuh des Manitu|
6
|
|
| 3 | Meier |Hamburg|
4
|
|
| 4 | Meier |München|
2

Romeo & Julia
Sissi

Fifth Element

Sixth Sense

1
2
3
2
5
6

Titel

|
|
|
|
|
|

|
|
|
|
|
|

i) Erläutern Sie, inwiefern obiges Schema die 2. Normalform verletzt!
ii) Geben Sie für obige Datenbank alle vollen funktionalen Abhängigkei-

ten an!

iii) überführen Sie das obige Relationenschema in die 3. Normalform! Er-

läutern Sie die dazu durchzuführenden Schritte jeweils kurz!
c) Gegeben sei das folgende relationale Datenbankschema (Schlüsselattribute

sind jeweils unterstrichen):
Personal(PNR, Name, Adresse, Gehalt, ANR)
Abteilung(ANR, Bezeichnung, Leiter, FNR)
Filiale(FNR, Ort)
In der Datenbank sind die Daten von Angestellten, Abteilungen und Filia-
len eines Handelsunternehmens gespeichert. Jeder Angestellte hat eine Per-
sonalnummer (PNR), einen Namen, eine Adresse, ein Gehalt und ist in ei-
ner bestimmten Abteilung beschäftigt. Jede Abteilung hat eine Abtei-
lungsnummer (ANR), eine Bezeichnung, die Personalnummer des Abtei-
lungsleiters (Leiter) und gehört zu einer bestimmten Filiale. Jede Filiale
hat eine Filialnummer (FNR) und ist in einem Ort beheimatet.


------------------------------------------------------------------------
Frühjahr 05 - Thema 2

391

c) Formulieren Sie folgende Anfragen in SQL:

i) Bestimmen Sie die Adresse aller Angestellten, die in Filialen in Berlin

beschäftigt sind!

ii) Geben Sie für jede Abteilung die Nummer und die Bezeichnung der
Abteilung zusammen mit der Personalnummer und dem Namen des
Abteilungsleiters aus! Das Ergebnis soll aufsteigend nach der Abtei-
lungsnummer sortiert werden.

iii) Bestimmen Sie die Personalnummern aller Angestellten, die in der

gleichen Abteilung wie der Angestellte mit der Nummer 333 arbeiten
und mehr Gehalt verdienen!

iv) Geben Sie für jede Filiale die Filialnummer zusammen mit dem mini-
malen und dem maximalen Gehalt der in der Filiale beschäftigten An-
gestellten aus! Dabei sollen nur Filialen mit mindestens vier Abteilun-
gen berücksichtigt werden.

v) Bestimmen Sie die Anzahl derjenigen Angestellten, die weniger als das

durchschnittliche Gehalt aller Angestellten verdienen!

vi) Bestimmen Sie die Liste der Filialnummern derjenigen Filialen, deren

Angestellte alle mehr als 500e Gehalt verdienen!

a)

i)

P e r s o n a l n r

G e h a l t s s t u f e

A d r e s s e

N a m e

1

l e i t e t

1

K l a s s e n n r

K l a s s e n r a u m

A d r e s s e

S _ I D

N a m e

L e h r e r

K l a s s e

1

i s t _ i n

n

S c h u e l e r

1

u n t e r r i c h t e t

m

n

F a c h

B e z e i c h n u n g

ii) Für eine 1:n-Beziehung kann es eine eigene Relation geben, der Primär-
schlüssel ist hierbei der Primärschlüssel der Entität mit der einfachen
Funktionalität. Die Relation enthält demnach die Primärschlüssel der
beiden beteiligten Relationen als Fremdschlüssel sowie eventuelle At-
tribute der Relationship. Alternativ kann das Relationenschema ver-
feinert werden. Die eben angesprochene Relation besitzt den gleichen
Primärschlüssel wie eine der zu den beiden beteiligten Entitäten gehören-
den Relationen. Mit dieser kann sie zusammengefasst werden. Der Pri-
märschlüssel bleibt erhalten und die neue Relation enthält dann alle
Attribute und Fremdschlüssel der beiden vorausgehenden Relationen.

b)

i) Name und Adresse der Kunden sind nur von der Kdnr abhängig und
damit nur von einem Teil des Primärschlüssels. Gleiches gilt für die


------------------------------------------------------------------------
392

5 Datenbanken

Abhängigkeit F ilmN r → T itel, Leihgebuehr. Damit ist die 2NF ver-
letzt.

ii) F ilmN r → T itel, Leihgebuehr
Kdnr → N ame, Adresse
T itel → Leihgebuehr

iii) Die Relation wird in zwei Relationen aufgespalten:

F ilm(F ilmN r, T itel, Leihgebuehr) und Kunde(Kdnr, N ame, Adresse)
Damit ist zwar die 2NF erreicht, aber es besteht die transitive Abhängig-
keit F ilmN r → T itel → Leihgebuehr und damit ist die 3NF verletzt.
Es muss also noch einmal aufgespalten werden:
F ilm(F ilmN r, T itel), P reis(T itel, Leihgebuehr) und
Kunde(Kdnr, N ame, Adresse)

c)

i) SELECT Name, Adresse

FROM
WHERE F.Ort = ’Berlin’

Personal P, Abteilung A, Filiale F

AND F.FNR = A.FNR
AND A.ANR = P.ANR;

ii) SELECT
FROM
WHERE
ORDER BY A.ANR;

A.ANR, A.Bezeichnung, P.Name, P.PNR
Personal P, Abteilung A
P.PNR = A.Leiter

iii) SELECT P1.PNR

FROM
WHERE P1.ANR = (SELECT ANR FROM Personal P2 WHERE PNR = 333)

Personal P1

AND P1.Gehalt > P2.Gehalt;

DISTINCT A.FNR, MIN(P.Gehalt), MAX(P.Gehalt)
Personal P, Abteilung A
P.ANR = A.ANR

iv) SELECT
FROM
WHERE
GROUP BY A.FNR;
HAVING COUNT A.ANR > 4

v) SELECT COUNT(PNR)
Personal P

FROM
WHERE P.Gehalt < (SELECT AVG(Gehalt) FROM Personal);

vi) SELECT
FROM
WHERE
GROUP BY A.FNR;

DISTINCT A.FNR
Personal P, Abteilung A
MIN(P.Gehalt) > 500e


------------------------------------------------------------------------
Herbst 05 - Thema 1

393

Herbst 05 - Thema 1

Aufgabe 1

Da die Aufgabenstellung identisch ist zu (Frühjahr 07 Thema 1 Aufgabe 1 auf
Seite 415) wird hier auf weitere Ausführungen verzichtet.

x

Aufgabe 2

Da die Aufgabenstellung identisch ist zu (Frühjahr 07 Thema 1 Aufgabe 2 auf
Seite 416) wird hier auf weitere Ausführungen verzichtet.

x

Aufgabe 3

Da die Aufgabenstellung identisch ist zu (Frühjahr 07 Thema 1 Aufgabe 3 auf
Seite 417) wird hier auf weitere Ausführungen verzichtet.

x

Aufgabe 4

Da die Aufgabenstellung identisch ist zu (Frühjahr 07 Thema 1 Aufgabe 4 auf
Seite 419) wird hier auf weitere Ausführungen verzichtet.

x

Aufgabe 5

Da die Aufgabenstellung identisch ist zu (Frühjahr 07 Thema 1 Aufgabe 5 auf
Seite 420) wird hier auf weitere Ausführungen verzichtet.

x

Aufgabe 6

Da die Aufgabenstellung identisch ist zu (Frühjahr 07 Thema 1 Aufgabe 6 auf
Seite 421) wird hier auf weitere Ausführungen verzichtet.

x

Aufgabe 7

Da die Aufgabenstellung identisch ist zu (Frühjahr 07 Thema 1 Aufgabe 7 auf
Seite 423) wird hier auf weitere Ausführungen verzichtet.

x

Herbst 05 - Thema 2

Aufgabe 1

Da die Aufgabenstellung identisch ist zu (Frühjahr 07 Thema 2 Aufgabe 1 auf
Seite 424) wird hier auf weitere Ausführungen verzichtet.

x


------------------------------------------------------------------------
394

5 Datenbanken

Aufgabe 2

Da die Aufgabenstellung identisch ist zu (Frühjahr 07 Thema 2 Aufgabe 2 auf
Seite 428) wird hier auf weitere Ausführungen verzichtet.

y

Aufgabe 3

Da die Aufgabenstellung identisch ist zu (Frühjahr 07 Thema 2 Aufgabe 3 auf
Seite 432) wird hier auf weitere Ausführungen verzichtet.

y

Frühjahr 06 - Thema 1

Aufgabe 1

Datenbank-
system,
DDL,
relationales
Schema,
Attribut,
Primär-
schlüssel,
Schlüssel-
kandidat,
Relation,
referentielle
Integrität

Bewerten Sie die folgenden Aussagen a) - i). Geben Sie für jede Aussage an, ob
diese richtig oder falsch ist. Begründen Sie Ihre Aussage in jedem Fall.
a) Anwender müssen sich beim Mehrfachzugriﬀ auf gleiche Daten eines Da-

tenbanksystems absprechen um Fehler bzw. Chaos zu vermeiden.

b) Eine Relation kann maximal 255 Attribute besitzen.
c) Ein Tupel kann mehrfach in einer Relation enthalten sein.
d) Die physische Datenstruktur entspricht in einem relationalen Datenbanksys-

tem immer der logischen Datenstruktur.

e) Primärschlüsselattribute verschiedener Relationen dürfen nicht den glei-

chen Namen haben.

f) In jeder Relation gibt es mindestens einen Schlüsselkandidaten.
g) Alle Relationen eines relationalen Schemas müssen miteinander in Bezie-

hung stehen.

h) Alle Relationen in einem Datenbankschema müssen normalisiert sein.
i) Attribute der selben Relation dürfen nicht den gleichen Namen haben.
Deﬁnieren Sie folgende Begriﬀe bzw. Abkürzungen j) - n) im Kontext von Da-
tenbanksystemen:
j) View
k) DDL
l) Domäne
m) Constraint
n) Referentielle Integrität

a) Falsch, dafür ist das Datenbankmanagementsystem zuständig.

b) Falsch, eine Relation kann beliebig viele Attribute besitzen.

c) Falsch. Dann würde es sich um denselben Datensatz handeln.


------------------------------------------------------------------------
Frühjahr 06 - Thema 1

395

d) Falsch. Abängig vom DBMS (z. B. B-Bäume).

e) Falsch.

ID“ oder
”
f) Korrekt.

Nr“ können viele Relationen als Primärschlüssel haben.
”

g) Nicht direkt, aber transitiv.

h) Korrekt. Ein erfolgreicher Abschluss wird mit commit bestätigt, ein erfolg-

loser Abschluss ist durch Abbruch (abort) gekennzeichnet.

i) Korrekt.

j) Eine Sicht, d. h. die mit einem Bezeichner abgespeicherte Ergebnistabelle

einer Abfrage, die für weitere Abfragen verwendet werden kann.

k) Data Deﬁnition Language. Die Daten-Deﬁnitions-Sprache (im Gegensatz zur
DML - Data Manipulation Language). Die DDL wird benutzt, um die Struk-
tur der abzuspeichernden Datenobjekte zu beschreiben. In SQL entspricht
das dem Teil, der für das Erstellen und Ausfüllen der Tabellen zuständig ist
(beispielsweise dem create-table-Befehl)

l) Die Eigenschaften des Transaktionskonzepts werden unter der Abkürzung
ACID zusammengefasst: Atomicity - Consistency - Isolation - Durability

m) Constraints sind Einschränkungen im Wertebereich von Attributen. Sie wer-

den durch Integritätsbedingungen deﬁniert.

n) Die referentielle Integrität gewährleistet, dass in einer Tabelle die Fremd-
schlüssel nur solche Werte annehmen können, die in der referenzierten Ta-
belle der Beziehung bereits als Primärschlüssel angelegt worden sind.

Aufgabe 2

a) Nennen und deﬁnieren Sie die vier wesentlichen Merkmale einer Datenbank-

transaktion!

Transak-
tion

b) Beschreiben Sie zwei mögliche Probleme, die bei unsynchronisierter Transak-

tionsausführung auftreten können.

c) Mit welchem Konzept versucht man die Probleme der unsynchronisierten

Transaktionsausführung zu vermeiden? Beschreiben Sie, wie dieses Konzept
in Datenbanksystemen umgesetzt wird.

a) (siehe Frühjahr 08 - Thema 1 Aufgabe 5.1. auf Seite 454)
b) (siehe Herbst 07 - Thema 1 Aufgaben 4b) bis 4d) auf Seite 438); weitere x

x

Informationen auch in [DUD] - Stichwort

Transaktion“)

”

c) (siehe Herbst 07 - Thema 1 Aufgaben 4b) bis 4d) auf Seite 438); weitere x

Informationen auch in [DUD] - Stichwort

Transaktion“)

”

(cid:28)
(cid:28)

------------------------------------------------------------------------
396

5 Datenbanken

Aufgabe 3

ER-Modell,
schwache
Entität,
Kardinali-
tät,
Generali-
sierung,
Spezialisie-
rung

a) Bei einem 2-stelligen Relationship-Typ muss die Kardinalität (Funktionali-
tät) festgelegt werden. Beschreiben, deﬁnieren und illustrieren Sie alle
möglichen Formen!

b) Was versteht man unter der sog. (min,max)-Notation bei einem 2-stel-

ligen Relationship-Typ? Erläutern Sie den Vorteil dieser Notation gegen-
über der herkömmlichen Notation und geben Sie ein kurzes Beispiel.
c) Wie unterscheidet sich ein schwacher Entitätstyp von einem starken Enti-
tätstyp? Skizzieren Sie an einem kleinen Beispiel, wie man einen schwa-
chen Entitätstyp im ER-Modell darstellt.

d) Wie nennt man die Beziehung in einem ER-Modell,

ie Generalisierung
bzw. Spezialisierung darstellt? Welche Eigenschaften haben Entities, die
durch eine derartige Beziehung verbunden sind? Illustrieren Sie Ihre Erklä-
rung ggf. an einem Beispiel.

d

a) Es kann jedes Tupel einer Entität mit genau einem Tupel der anderen Entität

in Beziehung stehen. Dies ergibt die Kardinalität 1:1.

E n t i t ä t 1

1

R e l a t i o n

1

E n t i t ä t 2

Steht ein Tupel mit mehreren Tupeln der anderen Entität in Beziehung, liegt
eine 1:n Kardinalität vor.

E n t i t ä t 1

1

R e l a t i o n

n

E n t i t ä t 2

Ist bei keiner der Entitäten eine eindeutige Beziehung vorhanden, stehen bei
der n:m Kardinalität viele Tupeln mit vielen in Beziehung.

E n t i t ä t 1

n

R e l a t i o n

m

E n t i t ä t 2

b) Die (min,max)-Notation gibt an, wie viele Tupel einer Entität mindestens
und wie viele maximal an einer Beziehung beteiligt sind. Die (min,max)-
Notation ist in dieser Hinsicht aussagekräftiger als die 1:n-Notation.

E n t i t ä t 1

( 1 , 1 )

R e l a t i o n

( 0 , * )

E n t i t ä t 2


------------------------------------------------------------------------
Frühjahr 06 - Thema 1

397

E n t i t ä t 1

( 1 , 1 )

R e l a t i o n

( 5 , * )

E n t i t ä t 2

Diese beiden Sachverhalte entsprechen der Kardinalität 1:n. Die Information,
dass im zweiten Fall immer mindestens 5 Tupel von Entität2 beteiligt sein
müssen, ist erst aus der (min,max)-Notation ersichtlich.

c) Bei der Modellierung einer Miniwelt ergeben sich oft Entity-Typen, die von
einem anderen Entity-Typ abhängig sind. Solche Entity-Typen heißen exi-
stenzabhängig. Bei existenzabhängigen Entity-Typen kann es vorkommen,
dass die Entities nur in Kombination mit dem Schlüssel des dominanten
Entity-Types identiﬁzierbar sind. Man spricht von schwachen Entity-Typen.
Hier besteht der Primärschlüssel aus dem Primärschlüssel der dominanten
Entity und einer Teilmenge der Attribute der schwachen Entity.

E n t i t ä t 1

1

R e l a t i o n

n

E n t i t ä t 2

d) Die is a - Beziehung beschreibt sowohl Generalisierung als auch Spezialisie-
rung, d. h. Entität2 ist eine Generalisierung von Entität1 oder Entität1 ist
eine Spezialisierung von Entität2. Für die Beziehung
Entität1 is a Entität2“
”
gilt:
Entität1 erbt die Attribute von Entität2. Entität1 kann darüber hinaus
zusätzliche Attribute besitzen. Zu jedem Tupel von Entität1 gehört genau
ein Tupel aus Entität2, so dass diese beiden das gleiche Entity repräsentie-
ren. Insbesondere hat das Tupel aus Entität1 also für die ererbten Attribute
dieselben Werte wie das korrespondierende Tupel aus Entität2. Kein Tupel
aus Entität2 kann zu zwei verschiedenen Elementen von Entität1 gehören.
Es kann aber Tupel in Entität2 geben, die zu keinem Tupel aus Entität1
gehören. Die Schlüsselkandidaten von Entität1 sind diejenigen von Entität2.
Folglich hat Entität1 den gleichen Primärschlüssel wie Entität2.

E n t i t ä t 2

R e l a t i o n

E n t i t ä t 1


------------------------------------------------------------------------
398

5 Datenbanken

Aufgabe 4

a) ER-Modellierung

Erstellen Sie das Modell eines ﬁktiven Grundbuchamtes in ER-Notation.
Wo möglich bzw. sinnvoll sollen 3-fache Beziehungen und Generalisierung/
Spezialisierung verwendet werden. Attribute von Entitäten und Beziehun-
gen sind anzugeben; Schlüsselattribute werden durch Unterstreichen ge-
kennzeichnet. Die Kardinalitäten von Beziehungen und - falls nötig - Rollen-
namen sollen ins Diagramm aufgenommen werden. Führen Sie Surrogat-
schlüssel nur ein, falls es nötig ist!

Datenbank-
system,
Datenbank-
entwurf,
ER-Model-
lierung,
relationales
Schema,
3NF

Im Grundbuchamt“

”

Grundstücke werden im Grundbuchamt eindeutig durch eine Grund-
buchnummer identiﬁziert und durch einen Lageplan genauer beschrieben.
Grundstücke liegen nebeneinander und stehen dadurch in einer Nachbar-
schaftsbeziehung zueinander. Es gibt Grundstücke, die nicht neben ande-
ren Grundstücken liegen und Grundstücke, die an mehrere Grundstücke
angrenzen.
Ein Haus steht genau auf einem Grundstück. Grundstücke sind entweder
nicht, mit einem oder mit mehreren Häusern bebaut. Jedes Haus kann ein-
deutig anhand seiner Hausnummer identiﬁziert werden.
Zu jedem Haus gehört mindestens ein Stockwerk. Aus städtebaulichen
Gründen darf ein Haus aber maximal aus 30 Stockwerken bestehen. Ein
Stockwerk gehört immer genau zu einem Haus. Jedes Stockwerk wird ein-
deutig durch seine Stockwerksnummer identiﬁziert. Ein Grundriss be-
schreibt die Aufteilung eines Stockwerks.
Ein Eigentümer kann beliebig viele Häuser besitzen. Ein Haus hat min-
destens einen oder mehrere Eigentümer. Einem Eigentümer können belie-
big viele Grundstücke gehören. Ein Grundstück kann immer nur einem
Eigentümer gehören. Ein Eigentümer wird eindeutig durch seinen Namen
und seine Adresse beschrieben.

b) Relationenmodell

Ausgehend von der ER-Darstellung ist ein Relationenschema in dritter Nor-
malform (3. NF) zu entwerfen. Wie gewohnt, werden dabei Primärschlüs-
sel durch Unterstreichen, Fremdschlüssel durch überstreichen kenntlich
gemacht.


------------------------------------------------------------------------
Frühjahr 06 - Thema 1

399

a)

( 0 , * )

L a g e p l a n

G r u n d b u c h N r

H a u s N r

g r e n z t _ a n

G r u n d s t ü c k

( 1 , * )

s t e h t _ a u f

( 1 , 1 )

H a u s

( 1 , 3 0 )

h a t

( 1 , 1 )

S t o c k w e r k

( 0 , * )

( 1 , 1 )

g e h ö r t

( 0 , * )

( 1 , * )

g e h ö r t

( 0 , * )

S t o c k w e r k s N r

G r u n d r i s s

E i g e n t ü m e r

N a m e

A d r e s s e

b) Grundstück(GrundbuchNr, Lageplan)

Haus(HausNr)
Stockwerk(StockwerksNr, Grundriss)
Eigentümer(Name, Adresse)
grenzt an(Grundstück1, Grundstück2)
gehörtGrundstück(Grundstück, EName, EAdresse)
gehörtHaus(HausNr, EName, EAdresse)
steht auf(HausNr, Grundstück)
hat(StockwerksNr, HausNr)
Verfeinertes Relationenmodell (in 3NF):
Grundstück(GrundbuchNr, Lageplan, EName, EAdresse)
Haus(HausNr Grundstück)
Stockwerk(StockwerksNr, Grundriss, HausNr)
Eigentümer(Name, Adresse)
grenzt an(Grundstück1, Grundstück2)
gehörtHaus(HausNr, EName, EAdresse)


------------------------------------------------------------------------
400

5 Datenbanken

Aufgabe 5

SQL,

relationale

Algebra

AmMeiHü“ die folgenden Relationen:
”

Szenario 1: Winzergenossenschaft
Für die Verwaltung ihrer Kunden in einer Datenbank verwendet eine kleine
Genossenschaft der Amateurwinzer
Weinfreund(Nr, Name, Vorname, Alter, Adresse)
Bestellung(Nr, W ID, Datum, Menge)
Wein(W ID, Weinberg, Jahrgang, Prozent, Rebsorte)
Die Primärschlüssel der Relationen sind unterstrichen. W ID in Bestellung ist
Fremdschlüssel zu W ID in Wein. Nr in Bestellung ist Fremdschlüssel zu Nr in
Weinfreund. Formulieren Sie die folgenden Datenbankoperationen in SQL und
geben Sie - falls möglich - die zugehörigen Ausdrücke in relationaler Algebra an.
a) Geben Sie den Namen und Vornamen aller gespeicherten Weinfreunde aus,

die jünger als 30 Jahre sind.

b) Geben Sie eine Liste aller gespeicherten Weine des Weinbergs

aufsteigend geordnet nach dem Jahrgang aus.

Katzkopf“
”

c) Geben Sie die durchschnittlich bestellte Menge Wein aller erfassten Bestel-

lungen aus.

d) Fügen Sie einen Wein mit den folgenden Attributen in die Liste der Weine

ein:
Weinberg:
Prozent:
Die nächste freie W ID ist 67.

Katzkopf“, Jahrgang:
”
12“, Rebsorte:
”

2005“,
”
Silvaner“
”

e) Der Weinfreund mit dem Vornamen

Otto“ und dem Namen
”
verbraucher“ hat noch nie einen Wein bestellt und ist daher aus der Liste
der Weinfreunde zu löschen.

Normal-
”

a) SELECT Name, Vorname

Weinfreund

FROM
WHERE Alter < 30;
πN ame,V orname(σAlter<30W einf reund)
Da die relationale Algebra nicht dazu geeignet ist Gruppierungs-, Ordnungs-
und Aggregatsfunktionen zu verwenden, können ab hier in dieser Aufgabe
keine weiteren Ausdrücke in relationaler Algebra angegeben werden.

b) SELECT
FROM
WHERE
ORDER BY Jahrgang;

*
Wein
Weinberg = ’Katzkopf’

c) SELECT AVG(Menge=

FROM

Bestellung;

d) INSERT INTO Wein

VALUES (67 , ’Katzkopf’, 2005, 12, ’Silvaner’);


------------------------------------------------------------------------
Frühjahr 06 - Thema 1

401

e) DELETE Weinfreund

WHERE

Vorname = ’Otto’
AND Name = ’Normalverbraucher’;

Szenario 2: Fußball-Weltmeisterschaft
Zur Vorbereitung auf die Fußball-Weltmeisterschaft 2006 entwickeln die Stadtliga-
Hobbyspieler des Dorﬀußballvereins
EFC Lummerland“ einen Spielplan. Einige
”
der Spieler sind selbst Hobbyprogrammierer und entscheiden sich für folgende
Relationen:
Nation(Land, Kapitaen, Trainer)
Stadion(SID, Stadionname, Ort, Kapazitaet, Eintrittspreis)
Match(Stadion ID, Datum, Land1, Land2, Ergebnis, Tore)
Es existieren folgende Fremdschlüsselbeziehungen: das Attribut Stadion ID der
Relation Match ist ein Fremdschlüssel auf das Attribut SID der Relation Stadion.
Die Attribute Land1 und Land2 der Relation Match sind Fremdschlüssel auf das
Attribut Land der Relation Nation.
Geben Sie SQL-Anweisungen für folgende Problemstellungen an:
f) Erstellung des beschriebenen Relationenschemas mit Tabellen, Primary

Key Contraints und Foreign Key Constraints.

g) Die Siegernation der letzten WM

Brasilien“ wird mit ihrem Kapitän
”

Cafu“ und Trainer
”

Scolari“ als erste Nation eingetragen.
”

h) Das versehentlich vorzeitig eingetragene

Deutschland“, am 09.07.2006 in Berlin, wird wieder gelöscht.

Traumﬁnale“
”

Brasilien gegen
”

i) Kurz vor dem oﬃziellen Start der WM 2006 kehrt der ehemalige Trainer

der deutschen Nationalmannschaft,
rück und ersetzt den bisherigen Trainer

Rudi Völler“, wieder in sein Amt zu-
”

Jürgen Klinsmann“.
”

j) Um den Ticketkauf planen zu können, möchten die Hobbyfußballer eine
Berlin“ statt-
”

Liste aller Spiele (
Match“), die im
”
ﬁnden, ausgeben.

Olympiastadion“ in
”

k) Um die Kosten des Kartenkaufs zu kalkulieren, wollen die Hobbyfußballer

die Summe der Eintrittspreise aller Spiele im
lin“ ausgeben.

Olympiastadion“ in
”

Ber-
”

l) Um einen Vergleich mit ihren eigenen Fußballspielen zu haben, wollen

die Hobbyfußballer nach der WM die durchschnittliche Anzahl an Toren
pro Spiel berechnen.

f) CREATE TABLE Nation(Land VARCHAR(255), Kapitaen VARCHAR(255),

Trainer VARCHAR(255), PRIMARY KEY (Land));

CREATE TABLE Stadion(SID INTEGER, Stadionname VARCHAR(255),

Ort VARCHAR(255), Kapazitaet INTEGER,
Eintrittspreis INTEGER, PRIMARY KEY (SID));
CREATE TABLE Match(Stadion ID INTEGER, Datum DATE, Land1 VARCHAR(255),
Land2 VARCHAR(255), Ergebnis VARCHAR(255), Tore INTEGER,
PRIMARY KEY (Stadion ID, Datum),
FOREIGN KEY (Stadion ID) REFERENCES Stadion(SID),


------------------------------------------------------------------------
402

5 Datenbanken

FOREIGN KEY (Land1,Land2) REFERENCES Nation(Land,Land));

g) INSERT INTO Nation(Land, Kapitaen, Trainer)
VALUES (’Brasilien’ , ’Cafu’, ’Scolari’);

h) DELETE FROM Match

WHERE Land1= ’Brasilien’ AND Land2=’Deutschland’

AND Datum =09.07.2006);

i) UPDATE Nation

SET
WHERE Land = ’Deutschland’;

Trainer = ’Rudi Voeller’

j) SELECT (Datum, Land1, Land2)

FROM
WHERE SID=Stadion ID AND Stadionname = ’Olympiastation’

Match, Stadion

AND Ort = ’Berlin’;

k) SELECT SUM(Eintrittspreis)

FROM
WHERE SID=Stadion ID AND Stadionname = ’Olympiastation’

Match, Stadion

AND Ort = ’Berlin’;

l) SELECT AVG(Tore) FROM Match;

Frühjahr 06 - Thema 2

Aufgabe 1

SQL Wir betrachten eine FLUG-Datenbank mit den folgenden Tabellen:

• Flug(Fnr, Start, Ziel, Distanz, Abflugszeit, Ankunftszeit,

Preis): Angaben zu einem Flug mit der Nummer Fnr.

• Flugzeug(Anr, Fluggesellschaft, Reichweite): zu einem Flugzeug

mit der Nummer Anr wird die Fluggesellschaft und die Reichweite an-
gegeben.

• darf fliegen(Pnr, Anr, Startdatum): der Angestellte (Pilot) mit der
Personalnummer Pnr darf das Flugzeug mit der Nummer Anr seit dem
Startdatum ﬂiegen.

• Angestellter(Pnr, Pname, Lohn): zu einem Angestellten (z. B. Pilot

oder Stewardess) mit der Personalnummer Pnr wird der Name Pname und
der Lohn abgegeben.


------------------------------------------------------------------------
Frühjahr 06 - Thema 2

403

Erstellen Sie in SQL folgende Anfragen:
a) Bestimmen Sie die Namen aller Angestellten, die seit dem ’31.01.2002’

ein Flugzeug der Fluggesellschaft Lufthansa ﬂiegen dürfen.

b) Bestimmen Sie für jeden Fluggesellschaft die maximale Reichweite ihrer

Flugzeuge.

c) Bestimmen Sie gruppiert nach Start- und Zielﬂughäfen jeweils die Anzahl

aller verbindenden Flüge.

d) Bestimmen Sie alle Fluggesellschaften, deren Angestellte zusammen mehr
als 1.000.000 Euro verdienen und geben Sie für jede solche Fluggesell-
schaft jeweils die Summe der Löhne an.

a) SELECT Pname

FROM
WHERE

Angestellter, darf fliegen, Flugzeug
Angestellter.Pnr = darf fliegen.Pnr
AND Startdatum = ’31.01.2002’
AND darf fliegen.Anr = Flugzeug.Anr
AND Fluggesellschaft = ’Lufthansa’;

Fluggesellschaft, MAX(Reichweite)
b) SELECT
FROM
Flugzeug
GROUP BY Fluggesellschaft;

COUNT(*)
c) SELECT
FROM
Flug
GROUP BY Ziel, Start;

d) SELECT
FROM
WHERE

Fluggesellschaft, SUM(Lohn)
Flugzeug, Angestellter, darf fliegen
Flugzeug.Anr = darf fliegen.Anr
AND Angestellter.Pnr = darf fliegen.Pnr

GROUP BY Fluggesellschaft
HAVING

SUM(Lohn) > 1 000 000 ;

Aufgabe 2

Wir betrachten die Datenbank FLUG aus Teilaufgabe 1.
a) Geben Sie ein ER-Diagramm für FLUG an, in dem möglichst viele Relatio-

nen als Relationships modelliert sind.

b) Erklären Sie kurz die Begriﬀe Primär- und Fremdschlüssel im relationalen
Datenmodell. Geben Sie geeignete Create Table-Statements mit Primär-
und Fremdschlüsselbedingungen zur Erzeugung der Tabellen Flugzeug,
darf fliegen und Angestellter an.

Datenbank,
Datenbank-
entwurf,
ER-Model-
lierung,
Primär-
schlüssel,
Fremd-
schlüssel,
SQL


------------------------------------------------------------------------
404

5 Datenbanken

c) Geben Sie Insert-Statements an, um in jede der Tabellen Flugzeug,

darf fliegen und Angestellter mindestens zwei Tupel einzufügen, so
dass in der entstandenen Datenbankinstanz alle Primär- und alle Fremd-
schlüsselbedingungen erfüllt sind.

d) ändern Sie den Lohn des Angestellten mit der Personalnummer ’17’ auf

80.000 Euro.

a)

F n r

S t a r t

Z i e l

D i s t a n z

A b f l u g z e i t

A n k u n f t s z e i t

P r e i s

A n r

F l u g g e s

R e i c h w e i t e

F l u g

h a t

F l u g z e u g

d a r f _ f l i e g e n

S t a r t d a t u m

A n g e s t e l l t e r

P n r

P n a m e

L o h n

b) Der Primärschlüssel dient zur eindeutigen Identiﬁzierung eines Datensat-
zes innerhalb einer Relation. Ein Fremdschlüssel verweist auf eine andere
Relation und bietet somit die Möglichkeit Relationen über Fremdschlüssel
miteinander in Verbindung zu setzen.

CREATE TABLE Angestellter (

Pnr Integer PRIMARY KEY,
Pname Varchar(255),
Lohn Float);

CREATE TABLE Flugzeug (

Anr Integer PRIMARY KEY,
Fluggesellschaft Varchar(255) NOT NULL,
Reichweite Integer);

CREATE TABLE darf fliegen (

Pnr Integer REFERENCES Angestellter,


------------------------------------------------------------------------
Frühjahr 06 - Thema 2

405

Anr Integer REFERENCES Flugzeug,
Startdatum Date,
PRIMARY KEY {Pnr, Anr} );

c) INSERT INTO Flugzeug VALUES (1, ’Lufthansa’, 750);

INSERT INTO Flugzeug VALUES (2, ’Air Berlin’, 300);

INSERT INTO Angestellter VALUES (15, ’Hans Meier’, 12000,50);

INSERT INTO Angestellter VALUES (30, ’Markus Mueller’, 14300);

INSERT INTO darf fliegen VALUES (15, 1, 01.01.2000);

INSERT INTO darf fliegen VALUES (30, 2, 30.03.2005);

d) UPDATE Angestellter

SET
WHERE

Lohn = 80 000
PNr = 17;

Aufgabe 3

Gegeben sei die Attributmenge U = {A, B, C, D, E} und folgende Menge F von
funktionalen Abhängigkeiten: F = {A → B, AB → C, BC → DE}
a) Bestimmen Sie die Attributhüllen {A}+
b) Zerlegen Sie das Relationenschema R = (U, F ) mittels Synthesealgorithmus

F und {B}+
F .

in ein 3NF-Datenbankschema.

c) Zerlegen Sie das Relationenschema R = (U, F ) bezüglich der funktiona-

len Abhängigkeit BC → DE (Einzelschritt des Dekompositionsalgorithmus).

funktionale
Abhängig-
keit,
Attributhül-
le,
relationales
Schema,
3NF

a) Bestimmung von {A}+
F :

i) {A}+
F = {A} Initialisierung
ii) überprüfe FD A → B: ⇒ {A}+
iii) überprüfe FD AB → C: ⇒ {A}+
iv) überprüfe FD BC → DE: ⇒ {A}+
Bestimmung von {B}+
F :
{B}+
Weil bei keiner FD die linke Seite in {B}+

F = {B} Initialisierung

F = {A, B}

F = {A, B, C}

F = {A, B, C, D, E}

F enthalten ist, ist {B}+

F = {B}

b) Zuerst muss die minimale überdeckung bestimmt werden:

i) Zerlege F in einfaches FDs:

F = {A → B, AB → C, BC → D, BC → E}


------------------------------------------------------------------------
406

5 Datenbanken

ii) Eliminiere redundante Attribute:

A → B kann keine redundanten Attribute enthalten.
Betrachte FD AB → C:
A redundant?
AttrHull(F, {B}) = {B} → A nicht redundant.
B redundant?
AttrHull(F, {A}) = {A, B, C, D, E} → B redundant.
F 0 = {A → B, A → C, BC → D, BC → E}
Betrachte FD BC → D:
C ist nicht redundant, da AttrHull(F 0, {B}) = {B} (s. o.).
B redundant?
AttrHull(F 0, {C}) = {C} → B ist nicht redundant.
Analog enthält BC → E keine redundaten Attribute.
F 0 = {A → B, A → C, BC → D, BC → E}

iii) Eliminiere redundante FDs:

Auf der rechten Seite aller FDs kommen die Attribute nur jeweils einmal
vor, so dass es keine redundanten FDs geben kann.

Jetzt kann der Synthesealgorithmus angewendet werden:

i) Erstelle für jede FD eine Relation:

R1(A, B)
R2(A, C)
R3(B, C, D)
R4(B, C, E)

ii) überprüfe, ob eine der Relationen bereits einen Schlüsselkandidaten

enthält:
A ist das einzige Attribut, das nicht auf der rechten Seite vorkommt,
also muss A im Schlüsselkandidaten enthalten sein.
Da {A}+
F = {A, B, C, D, E} ist {A} einziger Schlüsselkandidat. R1 und
R2 enthalten den Schlüsselkandidaten und deshalb wird keine zusätzli-
che Relation benötigt.

iii) überprüfe, ob R = R1 ∪ R2 ∪ R3 ∪ R4. Dies ist erfüllt, es werden keine

weiteren Relationen benötigt.

iv) Wegen der Minimalität von F 0 kann zusammengefasst werden:

R12(A, B, C)
R34(B, C, D, E)

c) S1 = ({B, C, D, E}, F1)
F1 = {BC → DE}
S2 = ({A, B, C}, F2)

(alle Attribute der verletzenden FD)
(alle FDs mit B, C, D, E)
(alle Attribute von U außer denen, die auf der
rechten Seite der verletzenden FD vorkommen)

F2 = {A → B, AB → C} (alle FDs ohne die verletzende FD)


------------------------------------------------------------------------
Herbst 06 - Thema 1

407

Herbst 06 - Thema 1

Aufgabe 1

Gegeben sei folgende Tabelle einer großen Kinokette:

KINO(Name, Stadt, Vorwahl, Telefon, MName, MGebDat,
MGehaltsstufe, MGehalt, MHandy, dBZ, SaalNr, Sitzplätze, Soundsystem)
MGebDat“ ﬁndet sich
Der Buchstabe
”
also das Geburtstdatum des Leiters des jeweiligen Kinos.
dBZ“ bezeichnet die
”
durchschnittliche Besucherzahl für ein Kino. Die SaalNr ist für jedes einzelne
Kino eindeutig. Es existieren folgende funktionale Abhängigkeiten (auf die An-
gabe der trivialen Abhängigkeiten wurde verzichtet):

M“ steht hierbei für
”

Manager“, unter
”

Stadt → V orwahl
M Gehaltsstuf e → M Gehalt
N ame, Stadt → T elef on, M N ame, M GebDat, M Gehalt, M Handy, dBZ
M N ame → M GebDat, M Gehaltsstuf e, M Gehalt, M Handy
N ame, Stadt, SaalN R → Sitzplätze, Soundsystem

relationales
Schema,
Schlüssel-
kandidat,
Normal-
form, 1NF,
2NF, 3NF

a) Die Relation

Kino“ sei in erster Normalform. Was muss für die Attribute
”

der Tabelle gelten?

b) Bestimmen Sie den einzigen Schlüsselkandidaten von
c) überführen Sie die Relation in zweite (aber noch nicht dritte) Normalform

Kino“!
”

und erläutern Sie Ihre Schritte kurz!

d) Finden Sie eine Anomalie, die Sie in diesem Beispiel durch überführung

in die zweite Normalform eliminieren konnten, sowie eine andere, die weiter-
hin vorhanden ist!

e) überführen Sie nun die Relation, ebenfalls mit kurzer Erläuterung, in die

dritte Normalform! Markieren Sie von allen Relationen die Primärschlüssel!

a) Alle Attribute müssen atomar also nicht aus mehreren Attributen zusam-

mengesetzt sein.

b) Da (Name, Stadt, SaalNr) auf keiner rechten Seite der FDs vorkommen,
müssen sie in jedem Schlüsselkandidaten vorhanden sein. An den FDs sieht
man, dass die Attributhülle dieser drei Attribute bereits die gesamte Relation
ist. (Name, Stadt, SaalNr) ist Superschlüssel und weil es wegen der ersten
Bedingung ein minimaler Superschlüssel ist, handelt es sich um den einzigen
Schlüsselkandidaten.

c) Entfernen aller nicht vom Primärschlüssel voll funktionalen Abhängigkeiten:

Telefon, MName, MGebDat, MGehaltsstufe, MGehalt, MHandy und dBZ sind
nicht abhängig von SaalNr, sondern nur voll funktional abhängig von Name,
Stadt.

Vorwahl ist nur von Stadt voll funktional abhängig.


------------------------------------------------------------------------
408

5 Datenbanken

Man erhält folgende Relationen:
KINO2(Name, Stadt, Telefon, MName, MGebDat, MGehaltsstufe, MGehalt,
MHandy, dBZ)
SAAL(Name, Stadt, SaalNr, Sitzplätze, Soundsystem)
ORT(Stadt, Vorwahl)

d) Entfernt wurde beispielsweise folgende UPDATE-Anomalie: Bekommt ein
Manager eine neue Gehaltsstufe, so musste das bislang für jeden Saal geändert
werden. Vergisst man das einmal, so ist die DB inkonsistent.
Es bleibt aber beispielsweise die DELETE-Anomalie: Wird ein Kino geschlos-
sen und der Datensatz gelöscht, so verliert man auch sämtliche Informationen
über den zugehörigen Manager.

e) Entfernt werden jetzt noch die transitiven Abhängigkeiten:

KINO2 wird aufgelöst in
KINO3(Name, Stadt, Telefon, dBZ, MName)
MANAGER(MName, MGebDat, MGehaltsstufe, MHandy)
GEHALT(Gehaltsstufe, Gehalt)
SAAL und ORT wie bei c).
Primärschlüssel sind unterstrichen.

Aufgabe 2

SQL Es seien folgende Tabellen eines Fahrradladens gegeben:

Bestand

Beschreibung

ArtNr
F112
F123
F023
Z321
Z361
Z721
MR231 Harley-Davidson - Street Rod

Prophete Herrenfahrrad
Prophete Damenfahrrad
Felix Kinderfahrrad
Prophete Pedale
Magnum Bügelschloss
Hella Speichenreﬂektoren

Größe

28
26
12
Einheitsgröße
XL
Einheitsgröße
1130cm3

Preis
559,00 e
529,00 e
139,00 e
10,00 e
99,00 e
2,99 e
14.500,00 e

Zuordnung

Beschreibung

Typ
Fahrrad
Prophete Herrenfahrrad
Fahrrad
Prophete Damenfahrrad
Fahrrad
Felix Kinderfahrrad
Zubehör
Prophete Pedale
Zubehör
Magnum Bügelschloss
Hella Speichenreﬂektoren
Zubehör
Harley-Davidson - Street Rod Motorrad


------------------------------------------------------------------------
Herbst 06 - Thema 1

409

a) Geben Sie die SQL-Anweisungen an, um die Tabelle Bestand (ohne Inhalt!)

zu erstellen!

b) Formulieren Sie folgende Abfragen in SQL:

i) Welche Artikel, die dem Typ Zubehör angehören, sind verfügbar?
ii) Bestimmen Sie alle Artikel, die Fahrräder sind und mehr als 500 e

kosten!

iii) Bestimmen Sie alle Artikel, die Zubehör sind und weniger als 10 e

kosten!

iv) Sortieren Sie alle Artikel alphabetisch (Beschreibung)!
v) Bestimmen Sie den Durchschnittspreis aller Fahrräder!

a) CREATE TABLE Bestand (

ArtNr VARCHAR(5),
Beschr VARCHAR(255),
Groesse VARCHAR(20),
Preis FLOAT);

b)

i) SELECT Bestand.ArtNr

FROM
WHERE

Bestand, Zuordnung
Bestand.Beschreibung = Zuordnung.Beschreibung
AND Zuordnung.Typ = ’Zubehör’;

ii) SELECT Bestand.ArtNr, Bestand.Beschreibung, Bestand.Preis

FROM
WHERE

Bestand, Zuordnung
Bestand.Beschreibung = Zuordnung.Beschreibung
AND Zuordnung.Typ = ’Fahrrad’
AND Bestand.Preis > 500;

Z.Typ, MAX(B.Preis) AS Maximalpreis
Bestand B, Zuordnung Z
B.Beschreibung = Z.Beschreibung

iii) SELECT
FROM
WHERE
GROUP BY Typ
HAVING

MIN(B.Preis) > 100;
∗
Bestand

iv) SELECT
FROM
ORDER BY Beschreibung;

v) SELECT AVG(B.Preis)

FROM
WHERE

Bestand B, Zuordnung Z
B.Beschreibung = Z.Beschreibung
AND Z.Typ = ’Fahrrad’;


------------------------------------------------------------------------
410

5 Datenbanken

Aufgabe 3

Gegeben sei folgendes Entity-Relationship-Diagramm einer Bank:

B N a m e

B A n s c h r i f t

B a n k

( 1 , * )

b e s c h ä f t i g t

( 1 , 1 )

M i t a r b e i t e r

P e r s o n a l n u m m e r

M N a m e

M A n s c h r i f t

G e h a l t s s t u f e

ER-Model-
lierung,
relationales
Schema,
Verfeine-
rung,
Schlüssel-
kandidat,
Fremd-
schlüssel

( 0 , * )

b e s i t z t

( 1 , 1 )

( 0 , * )

h a t

( 1 , 1 )

K G e b u r t s d a t u m

K N a m e

K u n d e

( 0 , * )

v e r f ü g t _ ü b e r

( 0 , * )

K o n t o

K A n s c h r i f t

K o n t o n u m m e r

K o n t o s t a n d

K o n t o a r t

a) Geben Sie die Schlüsselkandidaten an!
b) überführen Sie das ER-Modell in ein verfeinertes Relationenschema!
c) Markieren Sie alle Fremdschlüssel innerhalb des Relationenschemas!
d) Wie würden Sie das Modell ergänzen, wenn die Bank mehrere Filialen
unterhält? Gehen Sie davon aus, dass Kontodaten etc. zentral bei der
Bank gespeichert werden!


------------------------------------------------------------------------
Herbst 06 - Thema 1

411

a)

B N a m e

B A n s c h r i f t

K G e b u r t s d a t u m

K N a m e

K A n s c h r i f t

F N a m e

F A d r e s s e

( 0 , * )

g e h ö r t _ z u

( 1 , 1 )

F i l i a l e

( 0 , 1 )

a r b e i t e t _ i n

( 1 , * )

P e r s o n a l n u m m e r

M N a m e

B a n k

( 1 , * )

b e s c h ä f t i g t

( 1 , 1 )

M i t a r b e i t e r

M A n s c h r i f t

G e h a l t s s t u f e

( 0 , * )

b e s i t z t

( 1 , 1 )

( 0 , * )

h a t

( 1 , 1 )

K u n d e

( 0 , * )

v e r f ü g t _ ü b e r

( 0 , * )

K o n t o

K o n t o n u m m e r

K o n t o s t a n d

K o n t o a r t

b) Entity-Typen:

Bank(BName, BAnschrift)
Mitarbeiter(Personalnummer, MName, MAnschrift, Gehaltsstufe)
Kunde(KGebDatum, KName, KAnschrift)
Konto(KontoNr, Kontoart, Kontostand)

Relationship-Typen:
beschäftigt(BName, BAnschrift, Personalnummer)
verfügt über(Kontonummer, KName, KGeburtstDatum, KAnschrift)
hat(BName, BAnschrift, KName, KGebDat, KAnschrift)
besitzt(BName,BAnschrift,Kontonummer)

verfeinertes Relationenschema:
Mitarbeiter wird zusammengefasst mit beschäftigt:
Mitarbeiter(Personalnummer, MName, MAnschrift, Gehaltsstufe,
BName, BAnschrift)
besitzt wird zusammengefasst mit Konto:
Konto(Kontonummer, Kontoart,Kontostand, BName, BAnschrift)
Kunde wird zusammengefasst mit hat:
Kunde(KName, KGeburtsdatum, KAnschrift, BName, BAnschrift)
verfügt über und Bank bleiben.

c) Fremdschlüssel sind im verfeinerten Relationenschema kursiv gedruckt.

d) siehe rot dargestellten Teil in a).


------------------------------------------------------------------------
412

5 Datenbanken

Herbst 06 - Thema 2

Aufgabe 1

Normal-
form,
Anomalien,
Normalisie-
rung,
Normalfor-
men

1.1. Welche Nachteile haben Redundanzen im Datenbestand?
1.2. Annahme: Relationenschema R sei in 2. Normalform. Welche Eigenschaft

muss zusätzlich erfüllt werden, damit R in 3. Normalform ist?

1.3. Für die Zerlegung von Relationenschemata gibt es zwei grundlegende Kor-

rektheitsbeziehungen. Benennen und erklären Sie diese kurz!

1.1. siehe Aufgabe 5 von Frühjahr 07 - Thema 1 auf Seite 420 und Aufgabe 2 von

Frühjahr 03 - Thema 2 auf Seite 363

1.2. siehe Aufgabe 8 von Frühjahr 04 - Thema 1 auf Seite 378

1.3. siehe Aufgabe 8 von Frühjahr 04 - Thema 1 auf Seite 378

Datenbank-
entwurf,
ER-Model-
lierung,
relationales
Schema,
3NF

Aufgabe 2

2.1. ER-Modellierung

Erstellen Sie das Modell einer ﬁktiven Tanzschule in E/R-Notation! Wo
möglich bzw. sinnvoll sollen 3-fache Beziehungen und Generalisierung/Spe-
zialisierung verwendet werden. Attribute von Entitäten und Beziehungen
sind anzugeben; Schlüsselattribute werden durch Unterstreichen gekenn-
zeichnet. Die Kardinalitäten von Beziehungen und - falls nötig - Rollenna-
men sollen ins Diagramm aufgenommen werden. Führen Sie Surrogat-
schlüssel nur ein, falls es nötig ist!

Tanzpartner“.
”

Tanzschule“
”
Tanzschüler werden durch eine eindeutigen Nummer, Namen, Ge-
schlecht und Geburtsdatum beschrieben. Jeder Tanzschüler hat genau
einen anderen Tanzschüler als
Tänze zeichnen sich durch eine eindeutige Kurzbezeichnung, einen Na-
men und einen gewissen Stil aus. Ein Tanzschüler hat bestimmte Tänze ge-
lernt, andere nicht.
Ein Tanzkurs hat genau einen Tanzlehrer und mindestens einen Teilneh-
mer. Es werden in jedem Tanzkurs nur ausgewählte Tänze unterrichtet.
Ein Tanzkurs hat einen Namen und ein Beginndatum. Er wird durch
eine Nummer identiﬁziert. Ein Tanzschüler kann auch an mehreren Tanz-
kursen teilnehmen oder pausieren. Nicht jeder Tanz wird in einem Tanz-
kurs unterrichtet.


------------------------------------------------------------------------
Herbst 06 - Thema 2

413

Jeder Tanzlehrer kann nur bestimmte Tänze unterrichten. Ein Tanzleh-
rer hat einen Vornamen und Nachnamen und eine Zulassung. Er wird
durch seinen Nachnamen identiﬁziert. Er kann keinen, einen oder meh-
rere Tanzkurse unterrichten. Für jeden Tanz im Repertoire muss es einen
Tanzlehrer geben.
Dass an einem Kurs nur als Paar teilgenommen werden kann, ist nicht
zu modellieren.

2.2. Ausgehend von der ER-Darstellung ist ein Relationenschema in dritter Nor-

malform (3. NF) zu entwerfen! Primärschlüssel werden dabei durch Unter-
streichen, Fremdschlüssel durch Nennung der referenzierten Relation in
eckigen Klammern hinter dem Attributnamen kenntlich gemacht, z. B.:
Haus(Straße, OrtId[Ort])
Ort (OrtId, PLZ, Name)
Das Attribut OrtId der Relation Haus verweist als Fremdschlüssel auf
das Attribut OrtId der Relation Ort.

2.1.

G e b D a t

N a m e

N r

N a m e

K u r z b e z

S t i l

( 0 , * )

t a n z t

( 0 , * )

T a n z

( 1 , * )

u n t e r r i c h t e t _ T a n z

( 1 , * )

( 1 , 1 )

( 0 , * )

N a c h n a m e

T a n z s c h u e l e r

h a t _ P a r t n e r

w i r d _ u n t e r r i c h t e t _ i n

V o r n a m e

T a n z l e h r e r

G e s c h l e c h t

( 1 , 1 )

( 1 , * )

Z u l a s s u n g

( 0 , * )

n i m m t _ t e i l

( 1 , * )

T a n z k u r s

( 1 , 1 )

u n t e r r i c h t e t _ K u r s

( 0 , * )

N r

N a m e

B e g i n n D a t u m

2.2. Entity-Typen:

Tanzschueler(Nr, Name, Geschlecht, GebDat)
Tanz(Kurzbez, Name, Stil)
Tanzkurs(Nr, Name, Beginndatum)
Tanzlehrer(Nachname, Vorname, Zulassung)

Relationship-Typen:
hat Partner(Schueler1, Schueler2)
tanzt(Schueler, Kurzbez)
nimmt teil(Schueler, KursNr)
unterrichtet Kurs(KursNr, Lehrer)
unterrichtet Tanz(Lehrer, Kurzbez)


------------------------------------------------------------------------
414

5 Datenbanken

wird unterrichtet in(KursNr, Kurzbez)
Verfeinertes Relationenmodell ist dann in 3NF:
Tanzschueler(Nr, Name, Geschlecht, GebDat, Partner)
Tanz(Kurzbez, Name, Stil)
Tanzkurs(Nr, Name, Beginndatum, Lehrer)
Tanzlehrer(Nachname, Vorname, Zulassung)
tanzt(Schueler, Kurzbez)
nimmt teil(Schueler, KursNr)
unterrichtet Tanz(Lehrer, Kurzbez)
wird unterrichtet in(KursNr, Kurzbez)

Aufgabe 3

SQL Bitte beachten Sie:

”

DJ forever“

Primärschlüssel werden dabei durch Unterstreichen, Fremdschlüssel durch Nen-
nung der referenzierten Relation in eckigen Klammern hinter dem Attributna-
men kenntlich gemacht, z. B.:
Haus(Straße, OrtId[Ort])
Ort (OrtId, PLZ, Name)
Das Attribut OrtId der Relation Haus verweist als Fremdschlüssel auf das At-
tribut OrtId der Relation Ort. Szenario
Eine Discjockey-Agentur verwendet folgendes einfaches Datenbankschema:
Club( CId, Name, AnuahlAreas, ChefDJ[DJ])
DJ( DJId, Name)
Booking( DJId[DJ], CId[Club], Tag, Gage)
Tag = {Mo, Di, Mi, Do, Fr, Sa, So}
Jeder Club hat einen ChefDJ. DJs arbeiten an unterschiedlichen Tagen evtl. in
verschiedenen Clubs. Aber alle arbeiten regelmäßig, d. h. in der Tabelle
Boo-
”
king“ wird nur der Wochentag, kein konkretes Datum hinterlegt.
Primärschlüssel sind unterstrichen. DJId in Booking ist Fremdschlüssel zu DJId
in DJ, CId in Booking ist Fremdschlüssel zu CId in Club und ChefDJ in Club
ist Fremdschlüssel zu DJId in DJ.
Formulieren Sie folgende Datenbankoperationen in SQL:
a) Geben Sie die Namen aller DJs aus!
b) Was verdient
c) Welcher Club zahlt die höchste Gage?
d) Wie oft in der Woche arbeitet
e) Wie hoch ist die Durchschnittsgage aller DJs?
f) Geben Sie die Namen aller DJS aus, die

DJ Santos“ am Mi?
”

DJ Oetzi“?
”

DJ Mike“ als Chef haben! Es soll
”

kein Name doppelt vorkommen.

g) Fügen Sie
h)

DJ Helmut“ mit der DJId
”
DJ Helmut“ hat mittwochs ein Booking im Club
”
Gage von

80“. Fügen Sie dieses Booking in die Datenbank ein!
”

0815“ in die Datenbank ein!
”

Almenhof“ mit einer
”


------------------------------------------------------------------------
Frühjahr 07 - Thema 1

415

a) SELECT Name

FROM

DJ;

b) SELECT Gage

FROM
WHERE

DJ, Booking
Name = ’DJ Santos’
AND DJ.DJId = Booking.DJId
AND Tag = ’Mi’;

c) SELECT Name

FROM
WHERE

Club, Booking
Booking.CId = Club.CId
AND Gage = (SELECT MAX(Gage) FROM Booking);

d) SELECT COUNT(*) AS Anzahl

FROM
WHERE

DJ, Booking
Name = ’DJ Oetzi’
AND DJ.DJId = Booking.DJId;

e) SELECT AVG(Gage)

FROM

Booking;

f) SELECT DJ.Name

FROM
WHERE

DJ, Club
Name = ’DJ Mike’
AND DJ.DJId = Club.ChefDJ;

g) INSERT (0815, ’DJ Helmut’)

INTO

DJ;

h) INSERT (SELECT DJId FROM DJ WHERE Name =’DJ Helmut’,

SELECT CId FROM Club WHERE Name = ’Almenhof’,
’Mi’, 80)

INTO

Booking;

Frühjahr 07 - Thema 1

Aufgabe 1

Zur Datenspeicherung können neben Datenbanksystemen auch Einzeldateien
verwendet werden. Diskutieren Sie die Begriﬀe Redundanz, Inkonsistenz und
Integritätsverletzung und zeigen Sie, wie Datenbanksysteme hierfür Lösungen
bereitstellen!

Datenbanksysteme (DBS) dienen zur Beschreibung, Speicherung und Wiedergewin-
nung von umfangreichen Datenmengen, die von mehreren Anwendungsprogram-
men benutzt werden.

Datenbank-
system,
Redundanz,
Inkonsis-
tenz,
Integritäts-
verletzung


------------------------------------------------------------------------
416

5 Datenbanken

Bei der Speicherung der zu verwaltenden Daten in Einzeldateien würden viele
Daten gleichzeitig in mehreren Dateien gespeichert werden (Redundanz), was um-
fangreichen Speicherplatz benötigt und die Aktualisierung der Daten erschwert
(Inkonsistenzen des Datenbestandes können leicht entstehen). Bei der Datenver-
waltung mit Hilfe eines DBS wird genau diese Redundanz möglichst vermieden
und die Konsistenz des Datenbestandes garantiert.
Maßnahmen zum Schutz von Daten müssen bei der Speicherung in Einzeldateien in
allen Programmen des Anwendungssystems einzeln realisiert werden. Beim Einsatz
eines DBS hingegen werden alle Daten des Anwendungssystems zusammengefasst
und nach einheitlichen Regeln abgespeichert; der Zugriﬀ der Anwendungsprogram-
me auf die Daten erfolgt dann stets über ein Kontrollprogramm (das sogenannte
Datenbankmanagementsystem).
Werden die Daten in Einzeldateien abgelegt, muss der Aufbau einer Datei jedem
Programm, das diese Datei benutzt, bekannt sein. änderungen an der Dateistruk-
tur erfordern gleichzeitig änderungen in allen beteiligten Programmen. Auch hier-
zu bietet das DBS mit dem DBMS die Lösung der genannten Probleme.

Aufgabe 2

ANSI/SPARC ist ein Drei-Schichten-Modell für die Architektur von Datenbank-
systemen. Erläutern Sie anhand einer Skizze diese Architektur und geben Sie
ein Beispiel, das die unterschiedlichen Sichten verdeutlicht!

Das interne Modell enthält hierbei alle für
die physische Implementierung notwendigen
Aufgaben, wie Dateibenennung, Auswahl der
Datenträger, Speicher- und Zugriﬀsmetho-
den (z. B. Indexdateien). Hier werden alle
implementierungsabhängigen Eigenschaften
der Daten deﬁniert.
Das konzeptionelle Modell ist eine von al-
len Benutzern gemeinsam akzeptierte ein-
heitliche Darstellung (des Ausschnittes) der
realen Welt, die durch die Datenbank dar-
gestellt werden soll. Hier wird die logische Gesamtstruktur der Daten festgelegt.
Die konzeptionelle Ebene berücksichtigt weder die physikalische Organisation der
Daten noch die Wünsche von Anwendungsprogrammen.
Das externe Modell umfasst den für die Benutzer interessanten (oder erlaubten)
Teil der Daten, ihre Aufbereitung, sowie die Operationen, die darauf ausgeführt
werden dürfen. Externe Modelle stellen die Benutzersichten auf die Datenbank dar.
Jeder Benutzer (jedes Anwendungsprogramm) hat individuelle Anforderungen an
die Datenbank. Somit kann es zu einem Datenbestand gleichzeitig mehrere externe
Modelle geben.
(vgl. hierzu auch [DUD])

Datenbank-
system,
Drei-
Schichten-
Modell
nach AN-
SI/Sparc

(cid:27)

------------------------------------------------------------------------
Frühjahr 07 - Thema 1

Aufgabe 3

417

Die Entity-Relationship-Methode kennt die Konzepte der Generalisierung und
Spezialisierung. Deﬁnieren Sie diese, geben Sie Sinn und Zweck an und geben
Sie je ein Beispiel!
Bei der Umsetzung ins Relationenmodell werden diese Konzepte nicht direkt
unterstützt. Erläutern Sie die und zeigen Sie anhand des Beispiels eine Vorge-
hensweise, wie das Konzept trotzdem im Relationenmodell abgebildet werden
kann!

ER-Model-
lierung,
Relationen-
schema,
Generali-
sierung,
Spezialisie-
rung

Das Prinzip der Generalisierung wird eingesetzt, um eine übersichtlichere und
natürlichere Strukturierung der Entity-Typen zu erzielen. Dabei werden gemein-
same Eigenschaften, also Attribute und Beziehungen, ähnlicher Entity-Typen
her-
”
ausfaktorisiert“ und einem gemeinsamen Obertyp zugeordnet. Die beteiligten Entity-
Typen sind dann Untertypen des jeweiligen Obertyps. Eigenschaften, die nicht
allen Untertypen gemeinsam sind, bleiben beim entsprechenden Untertyp. Da je-
des Element eines Untertyps auch Element aller Obertypen ist, hat es auch alle
Beschreibungsmerkmale der Obertypen. Es
erbt“ damit sämtliche Eigenschaften
”
des Obertypen.
Beispiel: Die Lehrkräfte einer Schule werden durch den Entity-Typ Lehrkraft, die
übrigen Angestellten (Sekretärin, Hausmeister, ...) durch den Entity-Typ Personal
repräsentiert.

N a m e

N a m e

P e r s N r

W o h n o r t

P e r s N r

W o h n o r t

L e h r k r a f t

P e r s o n a l

S t u n d e n d e p u t a t

A m t s b e z e i c h n u n g

F u n k t i o n

Als Obertyp ist der Entity-Typ Bedienstete möglich, der die gemeinsamen At-
tribute aufnimmt.

N a m e

P e r s N r

W o h n o r t

B e d i e n s t e t e

L e h r k r a f t

P e r s o n a l

S t u n d e n d e p u t a t

A m t s b e z e i c h n u n g

F u n k t i o n


------------------------------------------------------------------------
418

5 Datenbanken

Die Beziehung von Unter- und Obertyp wird durch den speziellen Relationship-
Typ is a ausgedrückt. Im ER-Modell wird diese Beziehung durch eine Raute mit
der Beschriftung is a repräsentiert. In Richtung der Generalisierung wird da-
bei ein Pfeil gesetzt. Im obigen Beispiel gilt: Lehrkraft is a Bedienstete bzw.
Personal is a Bedienstete.

N a m e

P e r s N r

W o h n o r t

B e d i e n s t e t e

i s _ a

i s _ a

L e h r k r a f t

P e r s o n a l

S t u n d e n d e p u t a t

A m t s b e z e i c h n u n g

F u n k t i o n

Generalisierung und Spezialisierung werden im relationalen Modell nicht explizit
unterstützt. Die is a-Beziehung kann aber mittels folgendem Hilfskonstrukt in
das Relationenmodell transformiert werden. Gegeben seien die Entity-Typen E
und F, wobei gilt: E is a F. F sei bereits konvertiert. Die Relation E enthält alle
Attribute, die durch Konvertierung des Entity-Typen E entstehen, und zusätzlich
die Attribute des Primärschlüssels von F. Einziger Schlüsselkandidat von E ist dann
der Primärschlüssel von F. Für das Beispiel der Generalisierung von Lehrkraft
und Personal zu Bedienstete ist folgende relationale Darstellung denkbar:

• Bedienstete{PersNr, Name, Wohnort}
• Lehrkraft{PersNr, Amtsbezeichnung, Stundendeputat}
• Personal{PersNr, Funktion}

Diese Darstellung hat aber den Nachteil, dass in den Relationen, die aus den spe-
zialisierten Entity-Typen entstanden sind, nicht die volle Information verfügbar ist
(so enthält z. B. die Spezialisierung Lehrkraft nicht alle Informationen über eine
bestimmte Lehrkraft, da ein Teil dieser Informationen in der Relation Bedienstete
liegt“).
”
Das Schlüsselkonzept der Generalisierung ist die sogenannte Vererbung. Vererbung
heißt, dass ein Untertyp sämtliche Eigenschaften des Obertypen übernimmt. Im
vorliegenden Fall würde das bedeuten, dass die Relation, die aus dem Untertypen
entstanden ist, alle Attribute der Relation, die durch Konvertierung des Obertypen
entstanden ist,
erbt“. Dies kann aber leider nicht realisiert werden. Die einzige
”
Möglichkeit, die gesamte Information zu erhalten, ist die Verwendung von Joins,


------------------------------------------------------------------------
Frühjahr 07 - Thema 1

419

d. h. eine Anfrage über mehrere Tabellen. Bei der Nachbildung der Generalisie-
rung mit Hilfe des geschilderten Prinzips erhält man für den Obertypen und für
die Untertypen Relationen mit gleichem Primärschlüssel. Damit könnte man die
Relationen sogar ohne Probleme zusammenfassen. Dabei sind allerdings folgende
Punkte abzuwägen:

• Durch das Zusammenfassen geht das Prinzip der Generalisierung, d. h. die

Trennung von allgemeinem und speziellem Konzept, verloren.

• Anderseits ist bei der semantisch

richtigen“Darstellung, d. h. der Beibehal-
”
tung der Relationen des Ober- und Untertypen, zur Gewinnung der vollen
Information ein Join der Relationen notwendig. Joins sind datenbanktech-
nisch aber immer aufwändig.

Die Spezialisierung ist die inverse Operation zur Generalisierung (so ist z. B.
Lehrkraft und Personal sind Spezialisierungen von Bedienstete.
(vgl. hierzu auch [KEM])

Aufgabe 4

Das Konzept der Transaktion wird oft als einer der größten Beiträge der Da-
tenbankforschung für andere Informatikbereiche, wie beispielsweise Betriebssy-
steme oder Programmiersprachen, angesehen. Deﬁnieren Sie den Begriﬀ Trans-
aktion! Was versteht man unter der quasi-parallelen Ausführung von Trans-
aktionen? Erläutern Sie diese an einem Beispiel! Erläutern Sie schließlich das
ACID-Prinzip!

Transak-
tion,
ACID-
Prinzip

Unter einer Transaktion versteht man die
Bündelung“ mehrerer Datenbankope-
”
rationen, die in einem Mehrbenutzersystem ohne unerwünschte Einﬂüsse durch
andere Transaktionen als Einheit fehlerfrei ausgeführt werden sollen.
Aus der Sicht des Datenbankbenutzers oder Programmierers bilden Transaktio-
nen die
Programmiereinheiten“ für Datenbank-Anwendungsprogramme, die eine
”
bestimmte Funktion erfüllen. Für das Datenbankmanagementsystem (DBMS) ist
eine Transaktion eine Folge von Datenverarbeitungsbefehlen, die die Datenbank
ohne Unterbrechung von einem konsistenten Zustand in einen anderen, nicht not-
wendigerweise unterschiedlichen Zustand überführt.

Mehrere Transaktionen können quasi-parallel nebeneinander ausgeführt werden.
Quasi-parallel bedeutet dabei, dass bei der Abarbeitung der Transaktionen durch
das DBMS die einzelnen Aktionen einer Transaktion nicht unmittelbar hinter-
einander ablaufen müssen, sondern dazwischen Aktionen anderer Transaktionen
ausgeführt werden können. Die Transaktionen können gewissermaßen
verzahnt“
”
gleichzeitig“ mit der glei-
sein. Dadurch wird es möglich, dass mehrere Benutzer
”
chen Datenbank arbeiten(vgl. hierzu auch [KEM]).
Ein einfaches Beispiel für die quasi-parallele Ausführung zweier Transaktionen ist
gleichzeitig“ ablaufen. Bei der
eine Kontodatenbank, bei der zwei Transaktionen
”

(cid:28)
(cid:28)

------------------------------------------------------------------------
420

5 Datenbanken

ersten Transaktion werden 50e von Konto A abgehoben, bei der zweiten Trans-
aktion 100e auf das Konto B eingezahlt.

Anmerkung: BOT = Beginn von Transaktion

Schritt
1
2

T1
BOT
Stand von Konto A in Variable a
einlesen.

T2

3
4
4
5
5
6

7

8

9
10

Wert der Variablen a um 50e
vermindern.

Wert der Variablen a als neuen
Kontostand auf Konto A
zurückschreiben.

Ende der Transaktion

BOT
Stand von Konto B in Variable b
einlesen.

Wert der Variablen b um 100e
erhöhen.
Wert der Variablen b als neuen
Kontostand auf Konto B
zurückschreiben.

Ende der Transaktion

Dabei muss natürlich gewährleistet sein, dass die
Verzahnung“ der Transaktionen
”
nicht zu einer Ergebnisverfälschung der beteiligten Transaktionen führt. Dieser
Problematik wird durch das ACID-Prinzip begegnet (weitere Informationen hierzu
siehe Aufgabe 5 von Frühjahr 08 - Thema 1 auf Seite 454 oder [DUD])).

y

Aufgabe 5

Normal-
form,
Anomalien

Das Instrument der sogenannten Normalformen eines Datenbank-Schemas und
der dazu gehörigen Algorithmen bietet die Möglichkeit, aus der Analyse der
semantischen Beziehungen zwischen Daten eine Beurteilung des vorliegenden
Schemas abzuleiten und bei Bedarf ein
gutes“ Datenbank-Schema zu generie-
”
ren.
Sie haben in diesem Kontext die Update-, Einfüge- und Delete-Anomalie ken-
nen gelernt. Erläutern Sie diese und geben Sie Beispiele ihres Auftretens anhand
derer Sie die Problematik erläutern!

Im Folgenden wird als Beispiel ein Auszug aus einer Schulverwaltungsdatenbank
verwendet. Eine der vorkommenden Relationen ist
Lehrkraf t F ach{P ersN r, N ame, W ohnort, Geburtsjahr, F ach, Pﬂichtfach},
wobei {P ersN r, F ach} Primärschlüssel ist.

(cid:27)

------------------------------------------------------------------------
Frühjahr 07 - Thema 1

421

Da eine Lehrkraft oft in mehr als einem Fach unterrichtet, kann sie in mehreren
Tupeln gespeichert sein z. B.:
(M eir, Hierheim, 1955, M athematik, ja),
(M eir, Hierheim, 1955, Inf ormatik, nein)
Die somit redundant abgespeicherten Einträge können dazu führen, dass änderun-
gen an den Daten leicht zu einer inkonsistenten Datenbank führen, falls diese nicht
an allen betroﬀenen Stellen vollzogen wird. ändert sich zum Beispiel der Wohn-
ort von Herrn Meier und wird der notwendige Eintrag aber nur beim Tupel mit
dem Fach Mathematik geändert, so kommt es zu Inkonsistenzen (hier: UPDATE-
Anomalie). Außerdem entsteht für redundant abgespeicherte Daten ein erhöhter
Speicherbedarf.
Sollen nun in die Datenbank die Daten der Lehrkraft Moser, von der die persönli-
chen Daten, nicht aber die Lehrbefähigungen bekannt sind, eingetragen werden,
so ergibt sich ein anderes Problem. Da die Werte für Fach und Pﬂichtfach nicht
bekannt sind, müsste an diesen Stellen jeweils NULL eingetragen werden. Die At-
tributmenge PersNr, Fach ist aber der Primärschlüssel der Relation, d. h. beide At-
tribute dürfen keine NULL-Werte enthalten, da sonst die Entity-Integrität verletzt
würde. Das Einfügen des gewünschten Tupels ist somit nicht möglich (INSERT-
Anomalie).
Werden Informationen in Form eines Tupels gelöscht, kann dies weitreichende Fol-
gen haben. Wird zum Beispiel die Lehrkraft Müller (einzige Lehrkraft mit der
Lehrbefähigung in Sport) aus der Datenbank gelöscht, werden damit gleichzeitig
die Daten über das Fach Sport gelöscht. Es ist dann beispielsweise nicht mehr
nachvollziehbar, ob Sport an dieser Schule angeboten wird und ob es sich um ein
Pﬂichtfach handelt (DELETE-Anomalie).
(weitere theoretische Informationen zu Anomalien siehe Aufgabe 4 von Herbst 03
- Thema 1 auf Seite 367)
Normalformen vermeiden die oben als kritisch dargestellten Redundanzen und so-
mit auch das Auftreten von Anomalien.

Aufgabe 6

y

Gegeben sei folgendes Relationenschema zur Verwaltung von Fußballbundesliga-
Daten:

MANNSCHAFT (Vereinsname, Kapitän, Stadion)
SPIELER (SpielerID, Name, Vorname, Wohnort, Vereinsname)
MANNSCHAFT (MatchID, Datum, Heimverein, Gastverein, ToreHeim, Tore-
Gast)

SQL,
relationale
Algebra,
ER-Model-
lierung

Beispiel für MATCH:
Bayern München spielt in Köln gegen den 1. FC Köln, Bayern verliert 2:1. Dann
gilt: ToreHeim=2 und ToreGast=1.

Die Primärschlüssel der Relationen sind wie üblich durch Unterstreichen ge-
kennzeichnet.


------------------------------------------------------------------------
422

5 Datenbanken

Kapitän in MANNSCHAFT ist Fremdschlüssel zu SpielerID in SPIELER.
Vereinsname in SPIELER ist Fremdschlüssel zu Vereinsname in MANNSCHAFT.
Heimverein in MATCH ist Fremdschlüssel zu Vereinsname in MANNSCHAFT.
Gastverein in MATCH ist Fremdschlüssel zu Vereinsname in MANNSCHAFT.

Formulieren Sie die folgenden Anfragen in SQL:
a) Wo wohnt der Kapitän der Mannschaft
b) Geben Sie alle Spielbegegnungen an, die mit einem Sieg der Gäste geendet
haben. Ihr Ergebnis soll aus dem Datum des Spiels, der Bezeichnung des
Stadions, in dem das Spiel stattgefunden hat, und der Tordiﬀerenz beste-
hen!

1. FC Nürnberg‘?
’

c) Gegeben sei folgende SQL-Anweisung auf dem zuvor eingeführten Relatio-

nenschema.

SELECT S.Name, S.Vorname
FROM MANNSCHAFT T, SPIELER S, MATCH M
WHERE M.Datum = ’24.1.2001’
AND M.Heimverein = T.Vereinsname
AND T.Kapitän = S. SpielerID
AND M. Gastverein = ’FC Bayern München’

Welche umgangssprachliche Abfrage wird durch dieses SQL-Statement
realisiert?

d) Geben Sie einen zur Anfrage in Teilaufgabe c) äquivalenten Ausdruck der

relationalen Algebra an!

e) Zeichnen Sie zum Relationenschema ein ER-Diagramm!

a) SELECT Wohnort

MANNSCHAFT, SPIELER

FROM
WHERE Vereinsname = ’1. FC Nürnberg’
AND Kapitän = SpielerID;

b) SELECT Datum, Stadion, (ToreGast - ToreHeim)

FROM
WHERE ToreHeim < ToreGast

MANNSCHAFT, MATCH

AND Heimverein = Vereinsname;

c) Es wird Name und Vorname der Kapitäns der Mannschaft ausgegeben, die

am 24.1.2001 ein Heimspiel gegen FC Bayern München hatte.
d) π S.Name,S.V orname( Spieler ./Kapitaen=S.SpielerID M annschaft)
( σ Datum=024.1.20010 ∧Gastverein=0F CBayernMuenchen0 M atch))

./V ereinsname=Heimverein


------------------------------------------------------------------------
Frühjahr 07 - Thema 1

423

e)

S p i e l e r I D

V o r n a m e

S p i e l e r

W o h n o r t

N a m e

1

1

s p i e l t _ i n

h a t _ K a p i t ä n

n

1

V e r e i n s n a m e

M a n n s c h a f t

H e i m

S t a d i o n

G a s t

m

n

M a t c h

T o r e G a s t

T o r e H e i m

M a t c h I D

D a t u m

Aufgabe 7

Datenbanksysteme dienen der Speicherung und eﬃzienten Verarbeitung von
Daten. Das Datenbankschema lässt sich mit Hilfe von Entity-Relationship-
Diagrammen entwerfen.
Das folgende Entity-Relationship-Diagramm (ERD) beschreibt einen Ausschnitt
aus der Datenbank eines Flugbuchungssystems. Bestimmen Sie das zu diesem
ERD gehörige Relationenschema! Verwenden Sie als Namen für Fremdschlüssel-
attribute die Namen der referenzierten Primärschlüsselattribute. Primärschlüs-
selattribute sind zu unterstreichen, Fremdschlüsselattribute zu überstreichen!

ER-Modell,
relationales
Schema,
(Fremd-)
Schlüssel

F l u g z e u g I D

F l u g z e u g T y p

F l u g N r

n a c h

v o n

F l u g z e u g

m

1

f l i e g t _ a u f

n

F l u g

n

m

A n z a h l S i t z e

h a t _ K a p a z i t a e t

P a s s a g i e r

h a t _ g e b u c h t

n

P a s I D

N a m e

p

S i t z k l a s s e

K l a s s e

A n z P l a e t z e


------------------------------------------------------------------------
424

5 Datenbanken

Flugzeug(FlugzeugID,Typ)
Flug(FlugNr, von, nach)
Passagier (PasID, Name)
Sitzklasse(Klasse, AnzPlätze)
hat Kapazität(FlugzeugID, Klasse, AnzahlSitze)
fliegt auf(FlugNr, FlugzeugID)
hat gebucht(PasID, FlugNR, Klasse)

Frühjahr 07 - Thema 2

Aufgabe 1

Datenbank-
system,
Datenbank-
entwurf,
ER-Model-
lierung,
relationales
Schema,
Division,
Normal-
form,
Transak-
tion,
ACID-
Prinzip

Die Entwicklung der ersten Datenbanksysteme begann in den frühen 60er Jah-
ren. Seitdem haben sie die Datenverwaltung auf der Grundlage einfacher Be-
triebssystemdateien auf vielen Gebieten abgelöst.

a) Deﬁnieren Sie den Begriﬀ Datenbanksystem und grenzen Sie die Funktiona-

litäten eines Datenbanksystems von denen eines Dateisystems ab!

b) Nennen Sie die Phasen des Datenbankentwurfsprozesses und charakterisie-

ren Sie diese kurz!

c) Entity-Relationship-Modell: Erläutern Sie die nachfolgenden Konzepte ei-

nes ER-Modells!
• Entität,
• Relationship/Beziehungstyp,
• Attribut,
• Kardinalität

d) Relationales Modell: Erläutern Sie informell die folgenden Begriﬀe! Gehen
Sie insbesondere auf die Bedeutung der verschiedenen Begriﬀe für die An-
wendungsmodellierung ein!
• Schlüsselkandidat,
• Primärschlüssel,
• Fremdschlüssel

e) Sie haben sowohl die Grundoperationen der relationalen Algebra als auch

die daraus abgeleiteten Operationen kennen gelernt. Deﬁnieren Sie die Ope-
ration

Division“!
”

f) Sie haben die Normalformenlehre kennen gelernt. Welchen Sinn und Zweck

hat die Normalformenlehre?

g) Transaktionen sind ein wichtiges Konzept in Datenbanksystemen. Was

versteht man unter dem ACID-Prinzip? Welche Konsequenzen im Verhal-
ten des Datenbanksystems hat das ACID-Prinzip für den Anwender und
Entwickler?


------------------------------------------------------------------------
Frühjahr 07 - Thema 2

425

a) (vgl. [DUD] - Stichwort

Datenbank“)

”

Ein Datenbanksystem dient zur Beschreibung, Speicherung und Wiederge-
winnung von umfangreichen Datenmengen, die von mehreren Anwendungs-
programmen bzw. Datenbanknutzern gleichzeitig und unabhängig voneinan-
der benutzt werden. Es besteht aus der Datenbasis, in der die Daten ab-
gelegt werden, und den Verwaltungsprogrammen (Datenbanksoftware, Da-
tenbankmanagementsytem), die die Daten entsprechend den vorgegebenen
Beschreibungen abspeichern, auﬃnden oder weitere Operationen mit den
Daten durchführen. [. . . ] In den 60er-Jahren beherrschte vorwiegend eine
verarbeitungsorientierte Sicht die Entwicklung von Anwendungssystemen.
Die verarbeitenden Elemente, die Programme, benutzen Eingabedaten aus
Dateien und liefern Ausgabedaten, die ihrerseits in Dateien abgespeichert
werden und nachfolgenden Programmen als Eingabedaten dienen. [. . . ] Ob-
wohl dieses Konzept weit verbreitet ist, hat es einige gravierende Nachteile:

(1) Viele Daten sind gleichzeitig in mehreren Dateien gespeichert (Red-
undanz). [. . . ] Dadurch wird zusätzlich Speicherplatz benötigt und die
Aktualisierung der Daten erschwert.

(2) Bei jedem Programmlauf ist immer der gesamte Inhalt der bearbeiteten

Dateien beteiligt.

(3) Der Aufbau einer Datei muss jedem Programm, das diese Datei benutzt,
bekannt sein. änderungen an der Dateistruktur erfordern gleichzeitig
änderungen in allen beteiligten Programmen.

(4) Maßnahmen zum Schutz von Daten müssen in allen Programmen des

Anwendungssystems einzeln realisiert werden.

Die Lösung dieser Probleme bildet das Konzept des Datenbanksystems, bei
dem in einer Datenbank alle Daten des Anwendungssystems zusammenge-
fasst und nach einheitlichen Regeln abgespeichert werden (Datenintegrati-
on). Der Zugriﬀ der Anwendungsprogramme zu den Daten erfolgt stets über
ein Kontrollprogramm. Das Kontrollprogramm nennt man Datenbankma-
nagementsystem (DBMS). Hierbei ist ein grundlegendes Prinzip die strikte
Trennung von Daten und Datenbearbeitung. Ziel ist es dabei, den Benut-
zer von der eigentlichen Organisation der Daten innerhalb der Datenbank
unabhängig zu machen und ihm eine einheitliche, komfortable Datenschnitt-
stelle zur Verfügung zu stellen. Zur Kommunikation mit dem Anwendungs-
programm bzw. Datenbanknutzer stellt das Datenbanksystem eine Sprache
zur Verfügung.

(cid:28)

------------------------------------------------------------------------
426

b)

5 Datenbanken

Der Entwurf von Datenbanken läuft
ähnlich wie die Entwicklung einer
Software nach dem Prinzip des Was-
serfallmodells mit Rücksprungmög-
lichkeit in mehreren Phasen ab.
In der Deﬁnitionsphase wird die Mo-
dellierung der einzelnen Benutzer-
sichten durchgeführt. Hierzu wird
ein semantisches Datenmodell, z. B.
das Entity-Relationship-Modell,
eingesetzt.

Ergebnisse sind einzelne konzeptuelle Sichten und gegebenenfalls eine Auf-
stellung bereits jetzt erkannter Randbedingungen, wie beispielsweise Lauf-
zeitanforderungen.
In der Entwurfsphase wird eine View-Integration oder View-Konsolidierung
vorgenommen. Dabei werden die in der Regel sehr unterschiedlichen Anforde-
rungen der einzelnen Benutzersichten zu einem Gesamtkonzept zusammen-
gefasst. Resultat ist hier ein einheitliches konzeptuelles Datenbankschema,
beispielsweise in Form eines Entity-Relationship-Schemas. Oft ist hier eine
weitergehende Analyse des Anwendungsbereichs und damit eine Wiederho-
lung der ersten Entwicklungsphase notwendig.
Die Implementierungsphase lässt sich in drei Schritte untergliedern. Im ersten
Schritt wird das konzeptuelle Schema in ein logisches Schema, d. h. in ein
relationales Datenbankschema, umgesetzt. Es schließt sich die
Implementie-
”
rung“ mit Hilfe der Datendeﬁnitionssprache des jeweiligen Datenbankmana-
gementsystems an. Da bei der Erstellung des konzeptuellen Schemas nur mit
semiformalen Methoden gearbeitet wird, wird man oft feststellen, dass das
konzeptuelle Schema nicht sinnvoll relational implementiert werden kann,
weil das entstehende Datenbankschema nicht die gewünschten Normalform-
Eigenschaften hat. Entweder wird das logische (relationale) Datenbanksche-
ma daher durch Normalisierung modiﬁziert oder der ER-Entwurf wird ver-
bessert, d. h. die ersten Entwicklungsphasen werden erneut durchlaufen. Er-
gebnis ist ein
gutes“ logisches Datenbank-Schema, d. h. ein Schema, das
”
möglichst wenig Redundanz aufweist. Im zweiten Schritt wird dann das
interne Schema entworfen und optimiert. Es sind Speicherplatzbedarf und
Laufzeitanforderungen abzuschätzen und Indexe sind einzurichten. Dabei ist
auf ein ausgeglichenes Verhältnis von Retrieval- und Update-Eﬃzienz, zu
achten. Das Einrichten vieler Indexe beschleunigt das Suchen von Daten,
macht aber gleichzeitig das ändern von Daten aufwändiger, da die Inde-
xe mitberücksichtigt werden müssen. Manchmal ist eine De-Normalisierung
des Datenbank-Schemas, d. h. ein Rückgängigmachen einiger Zerlegungen,
aus Eﬃzienzgründen notwendig. Ein umfangreiches Datenbank-Schema er-
fordert bei der späteren Rückgewinnung der Daten aus der Datenbank sehr
viele Joins. Die Durchführung vieler Joins kann sich negativ auf die Eﬃzienz
einer Datenbankanfrage auswirken. Im abschließenden dritten Schritt wer-
den auf der Grundlage des ggf. optimierten logischen Schemas die externen
Sichten deﬁniert.


------------------------------------------------------------------------
Frühjahr 07 - Thema 2

c) (siehe Aufgabe 4 von Frühjahr 04 - Thema 1 auf Seite 375)

d) (siehe Aufgabe 5 von Frühjahr 04 - Thema 1 auf Seite 375)

427

x

x

e) Wir betrachten die Relationen R und S.

Sei {A1, ..., An} die Attributmenge von R und {B1, ..., Bm} die Attributmen-
ge von S, wobei gilt:
{B1, ..., Bm} ⊆ {A1, ..., An} und {B1, ..., Bm} 6= ∅.
Sei P roj := {A1, ..., An} \ {B1, ..., Bm}.
Die Division R ÷ S von R durch S ist deﬁniert durch
R ÷ S = {µ ∈ πP roj(R)|∀ν∈Sµ ∗ ν ∈ R}.
Beispiel:
Die Relation T 1 verfüge über die Attributmenge {W, X, Y, Z} und T 2 über
{X, Z}. T 1 enthalte die Tupel
(5, 3, A, 4), (LS, 3, R, 4), (5, LS, A, R), (LS, 5, A, R),
T 2 die Tupel (3, 4), (LS, R).
Bestimmt werden soll nun das Ergebnis der Division T 1 ÷ T 2.
Man sucht nun zuerst einmal alle Tupel aus T 1, die bei X und Z jeweils die
Einträge des Tupels (3, 4) der Relation T 2 enthalten.
Dies sind (5, 3, A, 4), (LS, 3, R, 4). Führt man diesen Schritt analog für das
Tupel (LS, R) der Relation T 2 durch, so ﬁndet man nur (5, LS, A, R). Somit
ist genau dieses Tupel das einzige, bei dem für alle Tupel aus T 2 einander
entsprechende Tupel aus T 1 vorhanden sind. Das Ergebnis der Division ist
nun die Projektion auf die Attribute von (5, LS, A, R), die nicht in T 2 ent-
halten sind; somit enthält die Ergebnisrelation T E hier genau das eine Tupel
(5, A).

T1 W X Y Z
A 4
3
3
R 4
LS A R
A R
5

5
LS
5
LS

T2

Z
X
3
4
LS R

TE W Y
A
5

Anmerkung: Da sich die Division mit Hilfe der Operatoren der Projektion,
der Diﬀerenz und des kartesischen Produkts in der Form
R ÷ S = πP roj(R) \ πP roj((πP roj(R) × S) \ R)
(Proj: Menge aller Attribute aus R, die nicht in S vorkommen)
ausdrücken lässt, ist sie keine Grundoperation der relationalen Algebra.

f) Bei der Modellierung einer relationalen Datenbank-Anwendung, die vor-
zugsweise mit Hilfe des ER-Modells geschieht, gibt es in der Regel mehre-
re Möglichkeiten, die zu unterschiedlichen Relationenschemata führen. Da-
mit stellt sich grundsätzlich die Frage, ob es möglich ist, die verschiede-
nen Relationenschemata qualititiv einzuordnen, d. h.
schlech-
”
te“ Relationenschemata zu erkennen und es ggf. Möglichkeiten gibt, aus ei-
gutes“ Relationenschema zu erzeugen. Hier-
schlechten“ Schema ein
nem
”
”
bei versteht man unter einem
schlechten“ Relationenschema eines, das Red-
”
undanzen enthält, was im ungünstigen Fall leicht zu einer inkonsistenten Da-
schlechten“ Schemata
tenbank führen kann. Gründe für das Auftreten von
”

gute“ bzw.
”


------------------------------------------------------------------------
428

5 Datenbanken

sind u. a. das Fehlen bzw. die Nichteinsetzbarkeit quantitativer Methoden
zur Zeit des Datenbankentwurfs. Die problemnahe Modellierung der An-
wendung ermöglicht oft noch kein genaues Verständnis der Zusammenhänge
zwischen den einzelnen Daten. Das Entity-Relationship-Modell verfügt zwar
über einen Schlüsselbegriﬀ, erlaubt aber nicht die detaillierte Analyse der
Abhängigkeiten zwischen den einzelnen Attributen. Das Instrument der soge-
nannten Normalformen eines Datenbank-Schemas bietet die Möglichkeit, aus
der Analyse der semantischen Beziehungen zwischen Daten eine Beurteilung
gutes“ Datenbank-
des vorliegenden Schemas abzuleiten und bei Bedarf ein
”
Schema zu generieren.

g) Probleme können entstehen, wenn Aktivitäten auf Zwischensituationen oder
inkonsistente Zwischenzustände zugreifen und davon abhängige Entscheidun-
gen treﬀen. Das kann dazu führen, dass aufwändige Rücksetzungen anhand
von mitgeführten Protokollierungen durchgeführt werden müsen und bereits
als beendet angenommene Aktivitäten automatisch neu nachvollzogen oder,
falls das nicht möglich ist, aufgehoben werden müssen (siehe [DUD] - Stich-
Transaktion“). (siehe Aufgabe 5 von Frühjahr 08 - Thema 1 auf Sei-
wort
”
te 454)

y

Aufgabe 2

ER-Model-
lierung,
Relationen-
schema,
3NF,
Primär-
schlüssel,
Fremd-
schlüssel,
Generali-
sierung,
Spezialisie-
rung

a) Es soll ein Modell der beschriebenen universitären Welt in ER-Notation er-
stellt werden! Dabei können alle Ihnen bekannten Modellierungskonstruk-
te verwendet werden. Wo möglich bzw. sinnvoll, sollen 3-fache Beziehun-
gen und Generalisierung/Spezialisierung verwendet werden. Attribute von
Entitäten und Beziehungen sind anzugeben; Schlüsselattribute werden
durch Unterstreichen gekennzeichnet. Die Kardinalitäten von Beziehungen
und (falls nötig) Rollennnamen sollen ins Diagramm aufgenommen werden!
Das folgende Beispiel beschreibt einen Ausschnitt der universitären Welt.
Personen und Einrichtungen der Universität werden durch folgende Typen
von Objekten beschrieben:

• Für Personen werden folgende Informationen aufgezeichnet: Ausweis-

nummer, Vorname, Nachname, Adresse (Land, PLZ, Ort, Straße,
Hausnummer), Geburtstag und eine Liste von Telefonnummern.
• Mitarbeiter sind eine Gruppe von Personen, die durch zusätzliche
Eigenschaften charakterisiert sind: Personalnummer, Fachrichtung,
Zimmernummer, Gebäude, Anstellungsdatum und Gehalt.

• Einige Mitarbeiter sind Professoren, für die noch weitere Charakte-
ristika hinzukommen: Lehrstuhl und Gehaltsstufe (C3, C4, etc.).
• Darüber hinaus gibt es eine weitere Personengruppe, die Studenten.
Zusätzlich zu den Eigenschaften der Personen besitzen sie folgende At-
tribute: Matrikelnummer, Studienfach und Immatrikulationsdatum.
• Jeder Lehrstuhl wird durch seine Fachrichtung, das Institut, zu dem

er gehört, und die Anzahl seiner Planstellen beschrieben.

(cid:27)

------------------------------------------------------------------------
Frühjahr 07 - Thema 2

429

Darüber hinaus enthält die abzubildende universitäre Miniwelt noch Aus-
prägungen folgender Typen:

• Die Universitätsbibliothek enthält eine Reihe von Büchern, die durch
ISBN-Nummer, Titel, Jahr der Veröﬀentlichung, Auﬂage, mehrere
Suchbegriﬀe und eine Autorenliste beschrieben werden.

• Buchverlage sollen durch Namen und Ort repräsentiert werden.
• Vorlesungen haben eine Bezeichnung, eine vorgegebene Zahl von Se-
mesterwochenstunden und werden im Sommer- oder Wintersemester
abgehalten. Für den Besuch einer Vorlesung kann der vorherige Be-
such einer Reihe anderer Vorlesungen, in denen Grundlagen vermit-
telt werden, gefordert sein.

Zwischen Instanzen der beschriebenen Objekttypen bestehen eine ganze
Reihe von Beziehungen. In jedem der folgenden Punkte können eine oder
mehrere Beziehungen beschrieben sein:

• Mitarbeiter und Studenten können Bücher bei der Bibliothek auslei-
hen. Die Ausleihfrist beträgt jeweils 14 Tage. Bei einer überschrei-
tung dieser Frist werden Gebühren (5 e) erhoben. überschreiten die
kumulierten Gebühren, die eine Person zu entrichten hat, ein vorgege-
bene Grenze (20 e), so kann die betreﬀende Person keine weiteren Bü-
cher ausleihen.

• Professoren empfehlen den Studenten Bücher für ihre Vorlesungen.
• Einige Professoren sind Lehrstuhlinhaber; für jeden Lehrstuhl gibt es

aber höchstens einen Lehrstuhlinhaber.

• Professoren halten ihre Vorlesungen entweder im Winter- oder im

Sommersemester. Jeder Student kann mehrere Vorlesungen in einem
Semester besuchen. Jede Vorlesung kann eine beliebige Zahl anderer
Vorlesungen voraussetzen (Vorkenntnisse).
• Bücher werden von Verlagen herausgegeben.
• Studenten werden von Professoren in unterschiedlichen Fächern ge-

prüft. Die Leistungen in jeder Prüfung werden mit einer Note bewer-
tet.

b) Ausgehend von der ER-Darstellung ist ein Relationenschema in dritter Nor-
malform (3NF) zu entwerfen. Wie gewohnt werden dabei Primärschlüssel
durch Unterstreichen, Fremdschlüssel durch überstreichen kenntlich ge-
macht.


------------------------------------------------------------------------
5 Datenbanken

s
u
a
r
o
v
_
t
z
t
e
s

m

n

t
h
c
u
s
e
b

m

m
u
t
a
D

h
c
a
F

e
t
o
N

1

t
f
e
u
r
p

n

f
f
i
r
g
e
b
h
c
u
S

n

t
a
h

m

s
i
e
r
P

t
n
e
d
u
t
S

a
_
s
i

1

s
u
a
r
e
h
_
t
b
i
g

n

N
B
S
I

g
a
l
r
e
v
h
c
u
B

e
m
a
N

t
r
O

m
u
t
a
d
s
n
o
i
t
a
l
u
k
i
r
t
a
m
m
I

h
c
a
f
n
e
i
d
u
t
S

r
e
m
m
u
n
l
e
k
i
r
t
a
M

430

a)

l
h
a
z
n
a
n
e
l
l
e
t
s
n
a
l
P

g
n
u
t
h
c
i
r
h
c
a
F

t
u
t
i
t
s
n
I

l
h
u
t
s
r
h
e
L

1

1

t
e
t
i
e
l

u
z
_
t
r
e
o
h
e
g

r
e
m
m
u
n
l
a
n
o
s
r
e
P

g
n
u
t
h
c
i
r
h
c
a
F

t
l
a
h
e
G

e
d
u
e
a
b
e
G

1

e
f
u
t
s
s
t
l
a
h
e
G

n

m
u
t
a
d
s
g
n
u
l
l
e
t
s
n
A

r
e
m
m
u
n
r
e
m
m
i
Z

n

t
a
h

1

e
s
s
e
r
d
A

t
r
O

r
e
m
m
u
n
s
u
a
H

e
ß
a
r
t
S

1

t
l
e
a
h

S
/
W

m
u
t
a
D

t
h
i
e
l

m

r
h
e
u
b
e
G

r
h
a
J

n
o
s
r
e
P

e
m
a
n
h
c
a
N

e
m
a
n
r
o
V

r
o
s
s
e
f
o
r
P

a
_
s
i

r
e
t
i
e
b
r
a
t
i
M

a
_
s
i

g
a
t
s
t
r
u
b
e
G

d
n
a
L

Z
L
P

g
n
u
n
h
c
i
e
z
e
B

S
W
S

g
n
u
s
e
l
r
o
V

n

t
l
h
e
i
f
p
m
e

m

n

n

1

r
o
t
u
A

n

t
a
h

m

n

h
c
u
B

l
e
t
i
T

l
h
a
z
n
e
t
i
e
S

e
g
a
l
f
u
A

r
e
m
m
u
n
s
i
e
w
s
u
A

n

t
a
h

m

r
e
m
m
u
n
n
o
f
e
l
e
T


------------------------------------------------------------------------
Frühjahr 07 - Thema 2

431

b) Adresse(Hausnummer, Strasse, PLZ, Land, Ort),

hat Adresse(Ausweisnummer, Hausnummer, Strasse, PLZ, Land),
Person(Ausweisnummer, Vorname, Nachname, Geburtstag),
Telefonnummer(Nr),
hat TelNr(TelNr, Ausweisnummer),
Mitarbeiter(Ausweisnummer, Personalnummer, Vorname, Nachname,
Geburtstag, Fachrichtung, Gebaeude, Zimmernummer, Gehalt,
Anstellungsdatum),

Student(Ausweisnummer, Matrikelnummer, Vorname, Nachname,

Geburtstag, Studienfach, Immatrikulationsdatum),

Professor(Ausweisnummer, Personalnummer, Vorname, Nachname,
Geburtstag, Fachrichtung, Gebaeude, Zimmernummer, Gehalt,
Anstellungsdatum, Gehaltsstufe),

prueft(Datum, SAusweis, SMatrNr, PAusweis, PPersonalNr, Note, Fach),
Vorlesung(Bezeichnung, SWS),
besucht(VBezeichnung, SAusweis, SMatrNr),
setzt voraus(VBezeichnung1, VBezeichnung2),
haelt(VBezeichnung, PAusweis, PPersonalNr, W/S),
Lehrstuhl(Fachrichtung, Institut, Planstellenanzahl),
leitet(PAusweis, PPersonalNr, Fachrichtung, Institut),
gehoert zu(PAusweis, PPersonalNr, Fachrichtung, Institut),
empfiehlt(PAusweisNr, PPersonalNr, ISBN, VBezeichnung),
Buch(ISBN, Preis, Auflage, Seitenzahl, Titel, Jahr),
hat Autor(ISBN, AName, AVorname),
Autor(Name, Vorname),
hat Suchbegriff(ISBN, Begriff),
Suchbegriff(Begriff);
leiht aus(Datum, AusweisNr, ISBN, Gebuehr),
Buchverlag(Name, Ort),
gibt heraus(ISBN, VName, VOrt)

Adresse(Hausnummer, Strasse, PLZ, Land, Ort),
Mitarbeiter(Ausweisnummer, Personalnummer, Vorname, Nachname,
Geburtstag, Fachrichtung, Gebaeude, Zimmernummer, Gehalt,
Anstellungsdatum),

Person(Ausweisnummer, Vorname, Nachname, Geburtstag, Hausnummer,

Strasse, PLZ, Land),

Telefonnummer(Nr),
hat TelNr(TelNr, Personalnummer),
Student(Ausweisnummer, Matrikelnummer, Vorname, Nachname, Geburtstag,

Studienfach, Immatrikulationsdatum),

Professor(Ausweisnummer, Personalnummer, Vorname, Nachname,
Geburtstag, Fachrichtung, Gebaeude, Zimmernummer, Gehalt,
Anstellungsdatum, Gehaltsstufe, gehoertFachrichtung,
gehoertInstitut, leitetFachrichtung, leitetInstitut, empfiehltISBN,
empfiehltVBezeichnung),

prueft(Datum, SAusweis, SMatrNr, PAusweis, PPersonalNr, Note, Fach),
Vorlesung(Bezeichnung, SWS, PAusweis, PPersonalNr, W/S),
besucht(VBezeichnung, SAusweis, SMatrNr),


------------------------------------------------------------------------
432

5 Datenbanken

setzt voraus(VBezeichnung1, VBezeichnung2),
Lehrstuhl(Fachrichtung, Insitut, Planstellenanzahl),
Buch(ISBN, Preis, Auflage, Seitenzahl, Titel, Jahr, VName, VOrt),
hat Autor(ISBN, AName, AVorname),
Autor(Name, Vorname),
hat Suchbegriff(ISBN, Begriff),
Suchbegriff(Begriff);
leiht aus(Datum, AusweisNr, ISBN, Gebuehr),
Buchverlag(Name, Ort)

Aufgabe 3

SQL,
relationale
Algebra

a) Szenario 1: Bücher und Verlag

Für die Verwaltung ihrer Bestände in einer Datenbank verwendet eine klei-
ne Buchhandlung die folgenden Relationen:

BUCH(ISBN,Autor Nachname, Titel, Verlags Id, Lagerbestand)
VERLAG(Verlags Id, Verlagsname, Verlagsadresse)

Die Primärschlüssel der Relationen sind unterstrichen, Verlags Id in BUCH
ist Fremdschlüssel zu Verlags Id in VERLAG. Formulieren Sie die folgen-
den Datenbankoperationen in SQL und geben Sie - falls möglich - die zuge-
hörigen Ausdrücke in relationaler Algebra an!

1. Welche ISBN hat das Buch

dekind?

Kaufmännische Datenbanken“ von We-
”

2. Welche Adresse hat der Verlag, in dem das Buch mit der

ISBN 2-411-16541-3 erschienen ist?

3. Die Buchhandlung erwirbt fünf Exemplare des bei Adisson-Wesley er-

Objektorientierte Datenbanken“ von
”

schienenen Buchs
Andreas Heuer, ISBN 3-89319-315-4. Der Verlag ist bereits in der Re-
lation VERLAG vorhanden und hat die Id
AW1“. Formulieren Sie
”
die Anweisungen für den Eintrag der Daten!

4. Löschen Sie den

Erfolglosenstr. 13, 90439 Nürnberg“!
”
Gehen Sie davon aus, dass von dem Verlag nie ein Buch gelagert wur-
de!

Pleite-Verlag“,
”

b) Szenario 2: Personaldatenbank

Für die Personalabteilung eines Unternehmens soll eine Personaldatenbank
erstellt werden. Das Unternehmen ist in mehrere Abteilungen unterglie-
dert. Jeder Angestellte gehört zu genau einer Abteilung; jede Abteilung
hat einen Abteilungsleiter. Die folgenden Relationen stellen einen kleinen
Ausschnitt aus der erarbeiteten Datenbankanwendung dar:


------------------------------------------------------------------------
Frühjahr 07 - Thema 2

433

ABTEILUNG(ANr,Bezeichnung)
PERSONAL(PNr,Name, Geburtsdatum, Gehalt, ANr)
LEITER(ANr, PNr)

Die Fremdschlüsselbeziehungen sind sprechend und gemäß der Beschrei-
bung gewählt. Geben Sie SQL-Anweisungen für folgende Problemstellun-
gen an:

1. Erstellung des beschriebenen Relationenschemas mit Tabellen,

Primary Key Constraints und Foreign Key Constraints.

2. Frau Schneider (geb. 12.5.61) wird zur Leiterin der neu gegründe-

ten Abteilung

Kundensupport“. Sie erhält die Personalnummer 4497.
”

3. Herr Müller (PNr 2371) scheidet aus dem Unternehmen aus.
4. Wie viele Personen arbeiten in der Abteilung, die von Frau Ziegler

(geb. 30.12.58) geleitet wird?

5. Wie viele Mitarbeiter hat die Abteilung, in der Herr Schuster

(geb. 18.1.83) arbeitet?

6. Wie hoch ist das Durchschnittsgehalt in den einzelnen Abteilungen?
7. Wessen Gehalt liegt über dem Durchschnittsgehalt der Abteilung, in

der er beschäftigt ist?

a)

1. SELECT ISBN
BUCH
Autor Nachname = ’Wedekind’
AND Titel = ’Kaufmännische Datenbanken’;

FROM
WHERE

2. SELECT Verlagsadresse

FROM
WHERE

BUCH, VERLAG
ISBN = ’2-411-16541-3’
AND BUCH.Verlags Id = VERLAG.Verlags Id ;

3. INSERT INTO BUCH

VALUES (’3-89319-315-4’, ’Andreas Heuer’,

’Objektorientierte Datenbanken’, ’AW1’, 5);

”

Eintrag“
Hier wird aufgrund der Formulierungen in der Angabe (z. B.
änderung“) davon ausgegangen, dass vorher noch keine Ex-
und nicht
emplare dieses Buches in der Buchhhandlung vorhanden waren. An-
sonsten müsste hier eine UPDATE-Anweisung für den Lagerbestand
durchgeführt werden, der eine SELECT-Abfrage für die Ermittlung des
aktuellen Lagerbestandes vorausgeht.

”

4. DELETE FROM VERLAG

WHERE
AND Verlagsadresse = ’Erfolglosenstr. 13, 90439 Nürnberg’;

Verlagsname = ’Pleite-Verlag’

b)

1. CREATE TABLE Abteilung (

ANr Integer PRIMARY KEY,
Bezeichnung Varchar(50));


------------------------------------------------------------------------
434

5 Datenbanken

CREATE TABLE Personal (

PNr Integer PRIMARY KEY,
Name Varchar(50),
Geburtsdatum Date,
Gehalt Float,
ANr REFERENCES Abteilung(ANr));

CREATE TABLE Leiter (

ANr REFERENCES Abteilung(ANr),
PNr REFERENCES Personal(PNr),
PRIMARY KEY (ANr));

2. INSERT INTO Personal

VALUES (4497, ’Schneider’, ’12.05.61’, NULL,

SELECT ANr FROM Abteilung
WHERE Bezeichnung = ’Kundensupport’);

UPDATE Leiter
SET
WHERE ANr = (SELECT ANr FROM Abteilung

PNr = 4497

WHERE Bezeichnung = ’Kundensupport’);

3. DELETE FROM Personal
WHERE PNr = 2371;

4. SELECT COUNT(PNr)

FROM
WHERE ANr = (SELECT ANr

Personal

FROM
WHERE Personal.Name = ’Ziegler’

Leiter, Personal

AND Geburtsdatum = 30.12.58
AND Personal.PNr = Leiter.PNr);

5. SELECT COUNT(PNr)

FROM
WHERE ANr = (SELECT ANr

Personal

Personal

FROM
WHERE Personal.Name = ’Schuster’
AND

Geburtsdatum = 18.1.83);

6. SELECT
FROM
GROUP BY

ANr, AVG(Gehalt)
Personal
ANr ;

7. SELECT PNr, Name

FROM
WHERE Gehalt > (SELECT

Personal P1

FROM
GROUP BY
HAVING

AVG(Gehalt)
Personal P2
ANr
P1.ANr = P2.ANr);


------------------------------------------------------------------------
Herbst 07 - Thema 1

435

Herbst 07 - Thema 1

Aufgabe 1

Datenbank-
system,
DML,
relationales
Schema,
Attribut,
Primär-
schlüssel,
Fremd-
schlüssel,
Schlüssel-
kandidat,
schwache
Entität,
SQL

Geben Sie für jede der folgenden Aussagen an, ob diese richtig oder falsch ist!
Begründen Sie Ihre Aussage in jedem Fall!
a) Jede Relation muss mindestens ein Attribut besitzen.
b) Ein Primärschlüssel muss immer aus mindestens zwei Attributen zusammen-

gesetzt sein.

c) Alle Relationen eines Datenbankschemas müssen in der ersten Normal-

form vorliegen.

d) Datenbanksysteme können gleichzeitig von maximal 32 Anwendern ge-

nutzt werden.

e) Ein Fremdschlüssel verweist auf genau ein Tupel einer anderen Relation.
f) Eine Datenbanktransaktion entspricht genau einem SQL-Statement.
g) Der Name eines Fremdschlüsselattributs darf nicht gleich dem Namen des

referenzierten Primärschlüsselattributes sein.

h) Die logische Datenstruktur einer relationalen Datenbank beschreibt, wo wel-

che Daten auf der Festplatte gespeichert sind.

i) Alle Attribute einer Relation müssen unterschiedliche Namen haben.
j) Kein Attribut einer Relation darf den gleichen Namen wie die Relation tra-

gen.

Deﬁnieren Sie folgende Begriﬀe bzw. Abkürzungen im Kontext von Datenbank-
systemen!
k) DML
l) Schlüsselkandidat

m) Index
n) Stored Procedure

a) Richtig, denn jede Relation benötigt einen Primärschlüssel und somit hat

jede Relation mindestens ein Attribut.

b) Falsch, wenn bereits ein Attribut alle Tupel eindeutig bestimmt, z. B. ein
künstlicher Schlüssel, kann der Primärschlüssel auch einelementig sein.

c) Falsch; aber es ist hilfreich, dass alle Attribute atomar sind, um Abfragen

einfacher und sinnvoller zu gestalten.

d) Falsch, das DBMS ist dafür zuständig, die Zugriﬀe der unterschiedlichen User

zu koordinieren. Dabei gibt es keine Maximalzahl.

e) Falsch, ein Fremdschlüssel verweist auf ein Attribut einer anderen Relation.
Der Attributwert dieses Attributs kann mehrfach in dieser Relation auftre-
ten, d. h. zu mehreren Tupeln gehören.


------------------------------------------------------------------------
436

5 Datenbanken

f) Richtig, jede Transaktion kann durch ein SQL-Statement ausgedrückt wer-

den.

g) Falsch; aber es ist zur besseren Lesbarkeit häuﬁg sinnvoll den Fremdschlüssel
anders zu benennen als das referenzierte Attribut, z. B. bei Attributnamen
wie

Name“ oder
”

ID“.
”

h) Die logische Gesamtstruktur beﬁndet sich auf der konzeptionellen Ebene,
wohingegen die Festlegung der Festplatten etc. auf der internen Ebene statt-
ﬁndet.

i) Richtig, sonst wären z. B. SQL-Anfragen nicht eindeutig möglich.

j) Falsch, hier ist eine Verwechslung ausgeschlossen.

y

y

k) (siehe Frühjahr 08 - Thema 1 Aufgabe 1.2b) auf Seite 451)

l) (siehe Frühjahr 04 - Thema 1 Aufgabe 5 auf Seite 375)

m) Ein Datenbankindex, oder kurz Index (im Plural

Indizes“),
”
ist eine von der Datenstruktur getrennte Indexstruktur in einer Datenbank,
die die Suche und das Sortieren nach bestimmten Feldern beschleunigt. Ein
Index besteht aus einer Ansammlung von Zeigern (Verweisen), die eine Ord-
nungsrelation auf eine oder mehrere Spalten in einer Tabelle deﬁnieren.

Indexe“ oder
”

n) In einer Stored Procedure können ganze Abläufe von Anweisungen unter
einem Namen gespeichert werden, die dann auf dem Datenbankserver zur
Verfügung stehen und ausgeführt werden können.

Aufgabe 2

Datenbank,
relationales
Schema,
relationale
Algebra,
Datenbank-
anfrage

a) Relationen werden oft mit Tabellen verglichen. Dieser Vergleich ist jedoch
nicht ganz korrekt. Stellen Sie kurz dar, welche Unterschiede zwischen
den Konzepten

Tabelle“ und
”

Relation“ existieren!
”

b) Stellen Sie kurz den Unterschied zwischen

Relationenschema einer Rela-
”
tion“ und der
Extension einer Relation“ dar! Illustrieren Sie Ihre Erklä-
”
rung an einem kleinen Beispiel!

c) Nennen und beschreiben Sie in jeweils 1-2 Sätzen drei Grundoperationen der

relationalen Algebra!

d) Benennen und beschreiben Sie kurz die prinzipiellen Möglichkeiten der An-

frage-Optimierung!

a) Eine Relation ist ein Tupel von Attributen, dies bedeutet insbesondere, dass
es keine festgelegte Reihenfolge der Attribute gibt. In einer Tabelle wird
zusätzlich die Extension einer Relation, d. h. die konkreten Attributwerte,
dargestellt.


------------------------------------------------------------------------
Herbst 07 - Thema 1

437

b) Ein Relationenschema ist das, was sich in den Zeilenköpfen einer Tabelle
ﬁndet. In den einzelnen Zeilen steht die Extension der Relation. Das Rela-
tionenschema beschreibt also die Attribute, während die Extension die At-
tributwerte wiedergibt.

c) Folgende Grundoperationen werden von der relationalen Algebra zur Verfü-
gung gestellt: Selektion, Projektion, Vereinigung, Diﬀerenz, kartesisches Pro-
dukt.
Bei einer Selektion werden diejenigen Tupel einer Relation R ausgewählt, die
eine bestimmte Selektionsbedingung erfüllen; bestimmte Attribute müssen
bestimmte Werte annehmen bzw. ihre Werte in bestimmten Bereichen lie-
gen.
Die Projektion ermöglicht die Auswahl bestimmter Attribute (Gruppen von
Attributen) einer Relation.
Die Vereinigung zweier Relationen R und S enthält alle Tupel, die in der
Relation R oder (auch) in der Relation S vorkommen.
Die Diﬀerenz zweier Relationen R und S ist die Menge aller Tupel, die in R,
aber nicht in S vorkommen.
Das kartesische Produkt ermöglicht das Zusammenführen von Tupeln ver-
schiedener Relationen R und S in neue Tupel. Dabei enthält das kartesische
Produkt von R und S alle möglichen Konkatenationen von Tupeln der Re-
lationen R und S.
(darüber hinaus gehende Informationen zu diesem Themenbereich ﬁnden sich
in Frühjahr 07 - Thema 2 Aufgabe 1e) auf Seite 427 und Frühjahr 08 - The-
ma 1 Aufgabe 2) auf Seite 452)

x

d) Ziel der Anfrage-Optimierung ist es, durch Schaﬀung geeigneter Voraus-
setzungen und durch eventuelle Umformung des zur Anfrage gehörenden
Terms eine möglichst eﬃziente und günstige Bearbeitung zu gewährleisten.
Grundsätzlich unterscheidet man bei Anfragen zwischen der nicht-algebrai-
schen und der algebraischen Optimierung. Gegenstand der nicht-algebraischen
Optimierung ist die Auswahl der günstigsten Datenstrukturen und Algo-
rithmen zur Auswertung einer Anfrage. Die algebraische Optimierung be-
fasst sich mit der Umformung eines Terms der relationalen Algebra gemäß
den Rechenregeln der relationalen Algebra. Bei dieser Umformung wird als
allgemeine Heuristik die Berechnung möglichst kleiner Zwischenergebnisse
angestrebt. Das kann u. a. erreicht werden durch frühe Selektion, frühe Pro-
jektion und die Kombination von Selektion und kartesischem Produkt zu
einem Join.
(vertiefende Informationen hierzu ﬁnden sich in [KEM] Kapitel 8; eine wei- (cid:28)
tere Aufgabe zu diesem Themenbereich ist Frühjahr 01 - Thema 1 Aufgabe
2.3 auf Seite 343)

x


------------------------------------------------------------------------
438

5 Datenbanken

Aufgabe 3

Normal-
form, 1NF,
2NF, 3NF,
Normalisie-
rung

y

y

a) Erläutern Sie kurz Sinn und Zweck der Normalformenlehre!
b) Charakterisieren und erläutern Sie an einem kurzen Beispiel die erste, zwei-

te, dritte Normalform!

c) Stellen Sie kurz dar, welche Korrektheitskriterien man bei der Zerlegung

eines Relationenschemas beachten muss!

a) (s. z. B. auch Frühjahr 04 - Thema 1 Aufgabe 8a) auf Seite 378)

b) (s. z. B. auch Frühjahr 04 - Thema 1 Aufgaben 8b) und 8c) auf Seite 378)

c) Es muss darauf geachtet werden, dass die Zerlegung abhängigkeitserhaltend

und verlustfrei ist.
Verlustfrei bedeutet, dass keine Daten verloren gehen, d. h. dass alle Attri-
bute erhalten bleiben.
Abhängigkeitserhaltend ist einer Zerlegung, wenn die funktionalen Abhängig-
keiten erhalten bleiben.

Aufgabe 4

Transak-
tion,
ACID-
Prinzip,
Lost-Up-
date-
Problem

a) Nennen und deﬁnieren Sie die vier wesentlichen Merkmale einer Datenbank-

transaktion!

b) Was versteht man unter dem sog. Lost-Update-Problem? Skizzieren Sie den

Sachverhalt an einem kurzen Beispiel!

c) Um die quasi parallele Ausführung von Transaktionen auf einem Datenbank-
system fehlerfrei zu ermöglichen, verwendet man sog. Sperren. Stellen Sie
kurz dar, welche Arten von Sperren es gibt und wie sie zueinander in Bezie-
hung stehen!

d) Welches Problem kann sich bei der Verwendung von Sperren ergeben? Wie

kann man dieses Problem in der Praxis umgehen?

y

a) (siehe Frühjahr 08 - Thema 1 Aufgabe 5.1. auf Seite 454)

b) Beim Lost-Update-Problem arbeiten zwei Transaktionen gleichzeitig auf den
gleichen Daten. Zu Beginn lesen alle die gleichen Daten. Das zuletzt aus-
geführte Update bleibt erhalten, alle anderen Updates werden durch nachfol-
gende Transaktionen wieder überschrieben, so dass die änderungen verloren
gehen.


------------------------------------------------------------------------
Herbst 07 - Thema 1

439

Schritt Transaktion1
BOT

read(A) → x

x: = x + 3
x → write(A)
commit

1
2
3
4
5
6
7
8
9
10

Transaktion2

BOT

read(A) → y

y: = y + 1
y → write(A)
commit

Die änderungen von Transaktion1 gehen in diesem Fall verloren.

c) Es gibt zwei Arten von Sperren, Lese- und Schreibsperren. Lesesperren sind
nicht exklusiv, d. h. mehrere Transaktionen können gleichzeitig Daten le-
sen. Schreibsperren sind exklusiv, d. h. nur eine Transaktion hat das Recht
die Daten zu ändern. Wenn eine Schreibsperre besteht, sind auch keine Lese-
sperren zulässig, um das Dirty-Read-Problem zu vermeiden. Bestehen bereits
Lesesperren, wenn eine Schreibsperre gesetzt werden soll, so muss gewartet
werden bis alle Lesesperren aufgehoben sind.

d) Trotz Verwendung von Sperren könnten aber weiterhin das Lost-Update-
Problem und andere Synchronisationsprobleme auftreten, wenn Sperren vor-
zeitig freigegeben werden. Zur Vermeidung dieser Art von Fehlern verwen-
det man die sog. zweiphasige Abarbeitung. Die Abarbeitung von Transaktio-
nen erfolgt genau dann zweiphasig bzw. genügt genau dann dem 2-Phasen-
Sperrprotokoll, wenn keine Transaktion eine Sperre freigibt, bevor sie al-
le benötigten Sperren angefordert hat. In der Praxis wird ein 2-Phasen-
Sperrprotokoll dadurch realisiert, dass

1. eine Transaktion sukzessive alle benötigten Sperren anfordert,
2. alle Lesesperren bis zum Ende, d. h. bis zur Aktion commit, hält und
3. alle Schreibsperren bis nach commit hält.

Solche Abarbeitungen heißen auch strikt zweiphasig. Jede legale, strikt zwei-
Wir-
phasige Abarbeitung von Transaktionen ist korrekt. Sie hat die gleiche
”
kung“ wie eine streng sequentielle Ausführung der Transaktionen. Eine be-
reits gesetzte Lesesperre (durch Angabe von rlock) kann durch xlock in eine
Schreibsperre umgewandelt werden, ohne dass vorher die Lesesperre aufge-
hoben werden muss.

Durch legale, strikt zweiphasige Abarbeitungen werden das Lost Update-,
das Dirty Read- und das Unrepeatable Read - Problem vermieden. Bei den
sperrbasierten Synchronisationsmethoden kann ein schwerwiegendes Problem
auftreten. Es handelt sich um Verklemmungen oder Deadlocks. (für weitere
Ausführungen hierzu siehe Frühjahr 08 - Thema 1 Aufgabe 5.4. auf Seite 455) x


------------------------------------------------------------------------
440

5 Datenbanken

Aufgabe 5

ER-Model-
lierung,
relationales
Schema,
Schlüssel,
3NF

a) Erstellen Sie das Modell zur Organisation einer ﬁktiven Bundestagswahl in
E/R-Notation! Wo möglich bzw. sinnvoll, sollen 3-fache Beziehungen und
Generalisierung/Spezialisierung verwendet werden. Attribute von Entitäten
und Beziehungen sind anzugeben; Schlüsselattribute werden durch Unter-
streichen gekennzeichnet. Die Kardinalitäten von Beziehungen und - falls
nötig - Rollennamen sollen ins Diagramm aufgenommen werden. Führen
Sie Surrogatschlüssel nur ein, falls es nötig ist!

Bundestagswahl“

”

Bei der Bundestagswahl werden Wahlkreise durch eine eindeutige Wahl-
kreisnummer identiﬁziert und durch einen Namen genauer beschrieben.
In einem Wahlkreis tritt mindestens ein Kandidat zur Wahl an, jedoch
kann eine Kandidat maximal in einem Wahlkreis antreten. Jeder Kandi-
dat hat einen Namen, der ihn eindeutig identiﬁziert.
Jeder Kandidat ist Mitglied maximal einer Partei, die jedoch mindestens
10 Kandidaten stellen muss. Eine Partei kann vor der Wahl eine Koaliti-
onsaussage zu beliebig vielen anderen Parteien machen. Jede Partei wird
durch ihren Namen eindeutig identiﬁziert und durch ein Regierungspro-
gramm charakterisiert.
Jede Partei stellt für die Wahl genau eine Liste mit Kandidaten auf. Jede
Liste muss zu genau einer Partei gehören. Auf einer Liste sind mindestens
fünf Kandidaten positioniert. Jeder Kandidat darf maximal auf einer Li-
ste positioniert sein. Eine Liste wird durch eine Nummer gekennzeichnet
und verfügt über eine bestimmte Anzahl von Plätzen.

b) Ausgehend von der ER-Darstellung ist ein Relationenschema in dritter Nor-
malform (3NF) zu entwerfen. Wie gewohnt, werden dabei Primärschlüssel
durch Unterstreichen, Fremdschlüssel durch überstreichen kenntlich ge-
macht.

------------------------------------------------------------------------


------------------------------------------------------------------------
Herbst 07 - Thema 1

441

a)

W a h l k r e i s n r

W n a m e

W a h l k r e i s

1

t r i t t _ a n

1 . . *

K a n d i d a t

N a m e

1

1

L i s t e

1 0 . . *

s t e h t _ a u f

5 . . *

i s t _ M i t g l i e d

1

s t e l l t _ a u f

1

P a r t e i

P n a m e

P r o g r a m m

A n z a h l P l a e t z e

L i s t e n N r

n

k o a l i t i o n s a u s s a g e

m

b) Wahlkreis(WahlkreisNr: Int, WName: String)

Kandidat(Name: String)
Liste(ListenNr: Int, AnzahlPlätze: Int)
Partei(PName: String, Programm: String)
tritt an(Kandidat: String, WahlkreisNr: Int)
steht auf(Kandidat: String, ListenNr: Int)
ist Mitglied(Kandidat: String, Partei: String)
stellt auf(ListenNr: Int, Partei: String)
koalitionssaussage(Partei1: String, Partei2: String)
Verfeinerung:

Wahlkreis(WahlkreisNr: Int, WName: String)
Kandidat(Name: String, WahlkreisNr: Int,

ListenNr: Int, Partei: String)

Liste(ListenNr: Int, AnzahlPlätze: Int, Partei: String)
Partei(PName: String, Programm: String)
koalitionssaussage(Partei1: String, Partei2: String)


------------------------------------------------------------------------
442

5 Datenbanken

Aufgabe 6

SQL

Szenario 1: Tischreservierung

Für die Verwaltung der Reservierungen in einer Datenbank verwendet ein klei-
nes Gourmetrestaurant die folgenden Relationen:

GAST(GNR, Name, Vorname, Adresse)
RESERVIERUNG(GNR, TNR, Datum, Anzahl)
TISCH(TNR, Position, Plätze, Kinderplätze)
Die Primärschlüssel der Relationen sind unterstrichen GNR in RESERVIERUNG ist
Fremdschlüssel zu GNR in GAST, TNR in RESERVIERUNG ist Fremdschlüssel zu TNR
in TISCH. Formulieren Sie folgende Datenbankoperationen in SQL!
a) Geben Sie den Namen und Vornamen aller Gäste aus, die einen Tisch für

den 31.12.2005 reserviert haben!

b) Geben Sie eine Liste (TNR und Position) aller Tische aus, die für mindes-

tens drei Personen am 31.12.2005 reserviert sind!

c) Fügen Sie eine neue Reservierung mit folgenden Daten ein:

• Gastnummer (GNR): 17
• Tischnummer (TNR): 3
• Datum: 31.12.2005
• Anzahl: 4 Personen

d) ändern Sie die Anzahl der reservierten Plätze in folgender Reservierung von

4 auf 3:

• Gastnummer (GNR): 13
• Tischnummer (TNR): 9
• Datum: 31.12.2005

e) Löschen Sie den Gast mit der Nummer (GNR) 27 und alle zugehörigen Reser-

vierungen!

Szenario 2: Beim Paketdienst

Der internationale Paketdienst IPS (International Parcel Service) muss täglich
eine Vielzahl von Postsendungen ausliefern und verwendet dazu folgende Rela-
tionen in einer relationalen Datenbank:

POSTKUNDE(KNR, Name, Vorname, Straße, PLZ)
SENDUNG(SID, AbsenderNR, EmpfängerNR, Porto, Einschreiben)
TOUR(TNR, Fahrer, Startzeit, Dauer)
LADELISTE(TNR, SendungsID, Position)


------------------------------------------------------------------------
Herbst 07 - Thema 1

443

Es existieren folgende Fremdschlüsselbeziehungen: Das Attribut SendungsID
der Relation LADELISTE ist ein Fremdschlüssel auf das Attribut SID der Relati-
on SENDUNG. Die Attribute AbsenderNR und EmpfängerNR der Relation SENDUNG
sind Fremdschlüssel auf das Attribut KNR der Relation POSTKUNDE. Die At-
tribute KNR und PLZ der Relation POSTKUNDE, das Attribut SID der Relati-
on SENDUNG, sowie das Attribut TNR der Relation TOUR sind Ganzzahlen. Bei
dem Attribut Startzeit der Relation TOUR handelt es sich um eine Datum, dass
Attribut Dauer wird als Ganzzahl in Minuten angegeben. Bei dem Attribut
Einschreiben der Relation SENDUNG handelt es sich um einen boolschen Wert.
Die Datentypen der weiteren Attribute sind dem Kontext zu entnehmen. Geben
Sie SQL-Anweisungen für folgende Problemstellungen an:

a) Erzeugung des beschriebenen Relationenschemas mit Tabellen, Primary

Key Constraints und Foreign Key Constraints.

b) Geben Sie Namen, Vornamen und Straßen aller Postkunden im Postleit-

zahlenbereich (PLZ) 30999 bis 31999 aus!

c) Geben Sie eine Liste aller Touren, bestehend aus Fahrer, Startzeit und

Dauer, aufsteigend geordnet nach Tournummer (TNR) aus!

d) Geben Sie für die Tour mit der Tournummer (TNR 4227) eine Liste aller
SendungsIDs (SID), die als Einschreiben auszuliefern sind, aufsteigend
sortiert nach ihrer Position in der Ladeliste aus!

e) Berechnen Sie das durchschnittliche Porto aller Sendungen der Postkun-

din mit dem Vornamen

Pippi“ und dem Nachnamen
”

Langstrumpf“!
”

f) Geben Sie eine Liste aller Touren (TNR, Fahrer) mit der Anzahl ihrer Po-

sitionen/Sendungen geordnet nach der Dauer der Tour aus!

g) Fehlsendungen: Geben Sie eine Liste aller Sendungen jeweils mit dem
Vor- und Nachnamen des zugehörigen Postkunden aus, deren Sender
und Empfänger gleich sind!

a) SELECT Name, Vorname

FROM
WHERE

Gast, Reservierung
Gast.GNR =Reservierung.GNR
AND Datum = 31.12.2005;

b) SELECT T.TNR, Position

FROM
WHERE

Tisch T, Reservierung R
T.TNR = R.TNR
AND Datum = 31.12.2005
AND T.Plätze > 2;

c) INSERT INTO Reservierung

VALUES (17 , 3, 31.12.2005, 4, 0);

d) UPDATE Reservierung

SET

Plätze = 3


------------------------------------------------------------------------
444

5 Datenbanken

WHERE GNR = 13

AND TNR = 9
AND Datum = 31.12.2005;

e) DELETE FROM Reservierung

WHERE GNR = 27;
DELETE FROM Gast
WHERE GNR = 27;

a) CREATE TABLE Postkunde(KNR INTEGER, Name VARCHAR(255),

Vorname VARCHAR(255), Strasse VARCHAR(255), PLZ INTEGER,
PRIMARY KEY (KNR));

CREATE TABLE Sendung(SID INTEGER, AbsenderNR VARCHAR(255),

EmpfängerNR VARCHAR(255), Porto FLOAT,
Einschreiben bool, PRIMARY KEY (SID),
FOREIGN KEY (AbsenderNR, EmpfängerNR) REFERENCES Postkunde(KNR));

CREATE TABLE Tour(TNR INTEGER, Fahrer VARCHAR(255),
Startzeit DATE, Dauer FLOAT, PRIMARY KEY (TNR));
CREATE TABLE Ladeliste(TNR INTEGER, SendungsID INTEGER,

Position INTEGER, PRIMARY KEY (SendungsID)
FOREIGN KEY (SendungsID) REFERENCES Sendung(SID)
FOREIGN KEY (TNR) REFERENCES Tour(TNR));

b) SELECT Name, Vorname, Straße

FROM
WHERE PLZ >= 30999

Postkunde

AND PLZ <= 31999;

Fahrer, Startzeit, Dauer
c) SELECT
FROM
Tour
ORDER BY TNR;

d) SELECT SID

FROM
WHERE TNR = 4227

Sendung, Ladeliste

AND SendungsID = SID
AND Einschreiben = true;

e) SELECT AVG(Porto)

FROM
WHERE Vorname = ’Pippi’

Postkunde, Sendung

AND Name = ’Langstrumpf’
AND KNR = AbsenderNr;


------------------------------------------------------------------------
Herbst 07 - Thema 2

445

f) SELECT
FROM
WHERE
GROUP BY Tour.TNR;

Tour.TNR, Fahrer, COUNT(SendungsID)
Tour, Ladeliste
Tour.TNR = Ladeliste.TNR

g) SELECT SID, Name, Vorname
Sendung, Postkunde
KNR = AbsenderNR
AND AbsenderNR = EmpfängerNR;

FROM
WHERE

Herbst 07 - Thema 2

Aufgabe 1

ER-Modell,
relationales
Schema,
(Fremd-)
Schlüssel,
schwache
Entität,
SQL

Gegeben sei folgender Ausschnitt aus dem ER-Modell einer Universitätsdaten-
bank:

n

s e t z t _ v o r a u s

m

N a m e

V o r g a e n g e r

N a c h f o l g e r

S t u d e n t

M a t r N r

n

m

h o e r t

m

V o r l e s u n g

V o r l N r

p r u e f t

n

h o e r t

S e m e s t e r

n

1

m

D o z e n t

D o z N r

N a m e

a) übersetzen Sie das ER-Modell in das Relationenmodell!
b) Geben Sie für die Tabellen prüft, liest und hört CREATE TABLE-State-
ments an, welche auch die nötigen Schlüssel- sowie Fremdschlüsselbedingun-
gen enthalten!

c) Ergänzen Sie das ER-Modell um einen schwachen Entity-Typen übungs-
gruppe mit den Attributen Gruppennummer und Raum, der in Verbindung
zur Tabelle Vorlesung stehen soll!


------------------------------------------------------------------------
446

5 Datenbanken

a) Student(MatrNr: Int, Name: String)

Vorlesung(VorlNr: Int)
Dozent(DozNr: Int, Name: String)
hoert(MatrNr: Int, VorlNr: Int)
liest(DozNr: Int, VorlNr: Int, Semester: String)
setzt voraus(Vorgaenger: Int, Nachfolger: Int)
prueft(MatrNr: Int, VorlNr: Int, DozNr: Int)

b) Viele Aufgabensteller wollen an dieser Stelle erst einmal die Erzeugung der
von den explizit angefragten Tabellen benötigten grundlegenden Tabellen
sehen. Deshalb hier zuerst die Erzeugung von Student, Vorlesung, Dozent.

CREATE TABLE Student (

MatrNr Integer PRIMARY KEY,
Name Varchar(50));

CREATE TABLE Vorlesung (

VorlNr Integer PRIMARY KEY);

CREATE TABLE Dozent (

DozNr Integer PRIMARY KEY,
Name Varchar(50));

CREATE TABLE prueft (

MatrNr Integer REFERENCES Student(MatrNr),
VorlNr Integer REFERENCES Vorlesung(VorlNr),
DozNr Integer REFERENCES Dozent(DozNr),
PRIMARY KEY (MatrNr, VorlNr));

CREATE TABLE liest (

DozNr Integer REFERENCES Dozent(DozNr),
VorlNr Integer REFERENCES Vorlesung(VorlNr),
Semester Varchar(25),
PRIMARY KEY (DozNr, VorlNr));

CREATE TABLE hoert (

MatrNr Integer REFERENCES Student(MatrNr),
VorlNr Integer REFERENCES Vorlesung(VorlNr),
PRIMARY KEY (DozNr, MatrNr));


------------------------------------------------------------------------
Herbst 07 - Thema 2

447

c)

m

1

p r u e f t

m

N a c h f o l g e r

n

G r u p p e n N r

R a u m

s e t z t _ v o r a u s

V o r l e s u n g

1

g e h o e r t _ z u

n

U e b u n g s g r u p p e

V o r g a e n g e r

n

m

h o e r t

n

V o r l N r

Aufgabe 2

Gegeben seien die folgenden Tabellen:
• Student(MatNr, Name, Alter, Fachbereich, Fachsemester).
• hört(MatNr, Vorlesung, Semester, Note).
Erstellen Sie in SQL folgende Anfragen:
a) Bestimmen Sie alle Studierende, die älter sind als 23 Jahre!
b) Bestimmen Sie das durchschnittliche Fachsemester der Studierenden des

SQL-Anfra-
ge

Fachbereichs

Informatik“!
”

c) Bestimmen Sie für jeden Studierenden - gegeben durch die Matrikelnum-

mer - und jedes Semester die Durchschnittsnote für alle gehörten Vorlesun-
gen!

d) Bestimmen Sie für jeden Studierenden - gegeben durch den Namen - und je-
des Semester die Anzahl der Vorlesungen, die er in diesem Semester hört,
vorausgesetzt, dass der Studierende im betrachteten Semester mindestens
fünf Vorlesungen hört!

e) Bestimmen Sie alle Studierenden - gegeben durch den Namen - die diesel-
be Vorlesung (mindestens) in zwei verschiedenen Semestern gehört haben!

a) SELECT *
FROM
WHERE

Student
Alter > 23;

b) SELECT AVG(Fachsemester)
Student
Fachbereich = ’Informatik’;

FROM
WHERE

MatNr, Semester, AVG(Note)
c) SELECT
FROM
hoert
GROUP BY Semester, MatNr;


------------------------------------------------------------------------
448

5 Datenbanken

Student.MatNr, Name, Semester, COUNT(Vorlesung)
Student, hört
Student.MatNr = hoert.MatNr

d) SELECT
FROM
WHERE
GROUP BY Semester, Student.Matnr
HAVING

COUNT(Vorlesung)≥5;

e) SELECT
FROM
WHERE

DISTINCT s.MatNr, Name
Student s, hoert h1, hoert h2
h1.Vorl = h2.Vorl AND s.MatNr = h1.MatNr
AND h1.MatNr = h2.MatNr AND h1.Semester <> h2.Semester;

Aufgabe 3

Relationen-
schema,
funktionale
Abhängig-
keit,
Attributhül-
le,
Syntheseal-
gorithmus,
3NF,
BCNF

Gegeben sei das Relationenschema R = (U, F ) mit der Attributmenge
U = {A, B, C, D, E} und folgender Menge F von funktionalen Abhängigkeiten:
F = {A → B, AC → BD, BC → A}
F und {B, C}+
F .

a) Bestimmen Sie die Attributhüllen {A}+
b) Geben Sie alle Schlüssel für R an!
c) Zerlegen Sie R mittels des Synthesealgorithmus in ein 3NF-Datenbanksche-

ma!

d) Ist die Zerlegung von R in die beiden Relationenschemata Ri = (Ui, Fi),

i = 1, 2, mit U1 = {A, C, D} und U2 = {A, B, C} und entsprechenden Men-
gen Fi = Πvi (F +) von funktionalen Abhängigkeiten verlustfrei? Ist sie
in BCNF?

a) Bestimmung von {A}+
F :

F = {A, B}

überprüfe FD A → B: ⇒ {A}+
überprüfe die FDs AC → BD und BC → A:
die linke Seite ist jeweils nicht in {A}+
änderung mehr an {A}+
F .
=⇒ {A}+
F = {A, B}
Bestimmung von {B, C}+
F :
{B, C}+
F = {A, B, C}
keine änderung an {B, C}+
F
{B, C}+
F = {A, B, C, D}

BC → A
A → B
AC → BD

F enthalten, es ergibt sich also keine

b) Da wegen der zweiten FD {A, C}+

F = {A, B, C, D} gilt, bis auf E also jedes
Attribut von U erreicht wird, sind die Schlüsselkandidaten {A, C, E} und
{B, C, E}.

c) Zuerst muss die minimale überdeckung bestimmt werden:


------------------------------------------------------------------------
Herbst 07 - Thema 2

449

1. Zerlege F in einfache FDs:

F = {A → B, AC → B, AC → D, BC → A}

2. Eliminiere redundante Attribute:

Betrachte FD AC → B: C redundant?
{A}+
F = {A, B} ⇒ C redundant.
F 0 = {A → B, AC → D, BC → A}
{B}+
F = {B}, {C}+
Es gibt also keine weiteren redundaten Attribute.

F = {C} und D /∈ {A}+

F

3. Eliminiere redundante FDs:

Auf der rechten Seite aller FDs kommen die Attribute nur jeweils einmal
vor, so dass es keine redundanten FDs geben kann.

Jetzt kann der Synthesealgorithmus angewendet werden:

1. Erstelle für jede FD eine Relation:

R1(A, B)
R2(A, C, D)
R3(B, C, A)

2. überprüfe, ob eine der Relationen bereits einen Schlüsselkandidaten

enthält:
Keine Relation enthält einen Schlüsselkandidaten, es ist also noch eine
zusätzliche Relation R4(A, C, E) (oder R4(B, C, E)) notwendig.

3. überprüfe, ob R = R1 ∪ R2 ∪ R3 ∪ R4. Dies ist erfüllt, es werden keine

weiteren Relationen benötigt.

4. Die Relationen R1 und R3 können nun zusammengefasst werden:

R13(A, B, C)
R2(A, C, D)
R4(A, C, E)

d) Eine Relation ist in Boyce-Codd Normalform, wenn kein Attribut funktional

abhängig von einer Attributgruppe ohne Schlüsseleigenschaft ist.
F1 = {AC → D}: AC ist einziger Schlüssel von R1 ⇒ R1 ist in BCNF.
F2 = {A → B, BC → A} ist nicht in BCNF, da A kein Schlüssel ist.
Die Zerlegung ist also abhängigkeitserhaltend, da F1 ∪ F2 = F 0; aber sie ist
nicht verlustfrei, da E /∈ U1 ∪ U2 ist.


------------------------------------------------------------------------
450

5 Datenbanken

Frühjahr 08 - Thema 1

Aufgabe 1

Grundbe-
griffe
Datenban-
ken

1. Bewerten Sie die folgenden Aussagen!

Richtig oder falsch? Geben Sie für jede Aussage an, ob diese richtig oder
falsch ist! Begründen Sie Ihre Aussage in jedem Fall!

a) Für den Datenaustausch zwischen Datenbank und Anwendungspro-
grammen ist das Datenbankmanagementsystem verantwortlich.

b) Das Datenbankmanagementsystem erlaubt auch unkontrollierten Zu-

griﬀ auf den Datenbestand.

c) Jeder Benutzer/jedes Anwendungsprogramm eines Datenbanksystems
muss für den Datenzugriﬀ die eigentliche Organisation der Daten ken-
nen.

d) Das Drei-Schichten-Modell nach ANSI/SPARC besteht aus der exter-

nen, der logischen und der physischen Schicht.

e) Der Zugriﬀ auf sehr große Datenbestände ist per Datenbanksystem ef-

ﬁzient möglich.

f) Integrität und Redundanzfreiheit wird mit Hilfe der mengenorientier-
ten Datenmanipulation durch relationale Operatoren gewährleistet.
g) Das relationale Datenmodell diente als Grundlage zur Entwicklung des

hierarchischen Modells und des Netzwerkmodells.

h) Die Ordnung der Tupel wird durch die Primärschlüsselwerte festgelegt.
i) Sichten dienen der Vermeidung von redundanter Speicherung.
j) Fremdschlüssel sind immer einmalig.

2. Beschreiben Sie kurz folgende Begriﬀ bzw. Abkürzungen im Kontext von

Datenbanksystemen.
a) Primärschlüssel
b) DML
c) Datenbankmanagementsystem
d) Satz

1.

a) Richtig

b) Falsch - es ist im Gegenteil gerade dazu da, den Zugriﬀ zu kontrollieren.

c) Falsch - es reicht, die Anwendersicht zu verstehen. Sinnlose und falsche

Benutzereingaben werden vom DBMS abgefangen.

d) Falls die im Vergleich zum Duden ([DUD], S. 168) diﬀerierenden Begrif-
logisch“ mit
fe Absicht sind, ist die Aussage falsch. Ansonsten muss
”
der Bezeichnung
phy-
konzeptionell“ und
”
”
intern“ ersetzt werden. Dann ist diese Aussage richtig.
sikalisch“ oder
”

physisch“ entweder durch
”

e) Richtig (die Eﬃzienz wird vor allem durch schnelle Zugriﬀsverfahren wie
z. B. B-Bäume und Hash-Verfahren erreicht, die das DBS bereitstellt).

f) Falsch - dies wird durch die Normalformen gesichert.

(cid:27)

------------------------------------------------------------------------
Frühjahr 08 - Thema 1

451

g) Falsch - denn die beiden zuletzt genannten waren bereits in den 60er
Jahren aktuell und somit Vorläufer des relationalen Datenmodells.
h) Falsch - die Ordnung der Attributwerte innerhalb der Tupel wird durch
die Ordnung der Attribute im Relationenschema vorgegeben, die Ord-
nung der Tupel untereinander kann bei jeder Ausgabe neu vorgegeben
werden, hat also auch nichts mit dem Primärschlüssel zu tun.

i) Richtig - mit Hilfe von Views können aus Basistabellen (und bereits
existierenden Views) bei Bedarf neue virtuelle Tabellen erstellt werden,
die keinen zusätzlichen Speicherbedarf besitzen.

j) Falsch - Fremdschlüssel auf das gleiche Attribut können in mehreren
Schemata auftauchen; ein Schema kann auch mehrere Fremdschlüssel
enthalten.

2.

a) Primärschlüssel sind minimale Mengen von Attributen, die zur eindeu-

tigen Identiﬁzierung von Datensätzen dienen.

b) DML bedeutet Data Manipulation Language. Diese dient zur Formulie-
rung von Anfragen an Datenbanken und damit zur Eingabe, Ausgabe,
Veränderung und Löschung von Daten.

c) Das Datenbankmanagementsystem kontrolliert den Zugriﬀ auf die Da-
tenbank. Des weiteren sorgt es für eﬃziente Speicherung und schnelles
Wiederauﬃnden von Daten.

d) Ein Satz (oder auch Datensatz) ist ein Tupel von Attributwerten, das

zu einer oder mehreren Relationen gehört.

Aufgabe 2

Die relationale Algebra wird aufgebaut über einer Grundmege von mengenwer-
tigen Operationen. Diese Grundoperationen können auf Relationen angewendet
werden und erzeugen als Ergebnis wieder eine Relation.
σ = Selektion;
Notation:

./ = Join;

π = Projektion;
× = kartesisches Produkt; \ = Mengendiﬀerenz;
∩ = Schnittmenge;
ρ = Umbenennen;

∪ = Vereinigungsmenge;
÷ = relationale Division

relationale
Algebra,
relationale
Division,
kartesi-
sches
Produkt,
(Natural)
Join

1. Welche Operationen können sowohl auf Mengen als auch auf Relationen

angewandt werden?

2. Deﬁnieren Sie die Operation

Division“! Auf welche Grundoperation kann
”
die Division zurückgeführt werden und wie? Ein Beweis ist nicht erforder-
lich.

3. Eine Relation A mit den Attributen u, v, w, x habe 5 Tupel, eine Relation

B mit den Attributen x, y, z habe 3 Tupel.

a) Wie viele Tupel und Attribute hat das kartesische Produkt aus A

und B?

b) Wie viele Tupel und Attribute hat der Natural Join aus A und B?


------------------------------------------------------------------------
452

5 Datenbanken

1. Die sowohl als Mengenoperationen als auch für Relationen verwendbaren
Operationen sind Schnittmenge, Vereinigungsmenge, Mengendiﬀerenz und
kartesisches Produkt. Projektion, Selektion, Join und relationale Division
können nur auf Relationen angewendet werden. Umbenennung ist nur bei
Attributen von Relationen möglich.

2. Division:

Seien die Relationen R und S gegeben und sei {A1, ..., An} die Attributmenge
von R und {B1, ..., Bm} die Attributmenge von S, wobei gilt:
{B1, ..., Bm} ⊆ {A1, ..., An} und {B1, ..., Bm} 6= ∅.
Sei Dif f := {A1, ..., An} − {B1, ..., Bm}.
Die Division R ÷ S von R durch S ist dann deﬁniert durch

R ÷ S = {µ ∈ πDif f (R) | F ür alle ν ∈ S gilt µ ∗ ν ∈ R}

Die Division kann auch durch Projektion, Diﬀerenz und kartesisches Produkt
ausgedrückt werden.

R ÷ S = πDif f (R) − πDif f ((πDif f (R) × S) − R)

3.

a) Es sind 3 · 5 = 15 Tupel und 4 + 3 = 7 Attribute.
b) Beim Join entsteht ein Attribut weniger, also 6, da x in der Ergeb-
nisrelation nur einmal auftritt. Die Anzahl der Tupel hängt von den
Attributwerten von A.x bzw. B.x ab. Falls es keine übereinstimmung
gibt, sind es 0. Falls alle Tupel von A.x und B.x mit dem gleichen Wert
besetzt sind, entstehen 15 Tupel.

Aufgabe 3

Drei-
Schichten-
Modell

1. Wozu dient das Drei-Schichten-Modell nach ANSI/Sparc?
2. Geben Sie ein selbst gewähltes Beispielsszenario an, an dem Sie die Vorteile

des Vorgehens nach ANSI/Sparc erläutern!

1. (siehe [DUD]

Datenbankentwurf“)

”

Ein Datenbanksystem, das auf dem 3-Schichten-Modell basiert, besteht aus
drei Ebenen: der konzeptionellen, der internen und der externen Ebene. Auf
der konzeptionellen Ebene steht die logische Gesamtstruktur der Daten, ih-
rer Eigenschaften und ihre Beziehungen untereinander im Vordergrund. Die
Umsetzung des relationalen Schemas erfolgt auf dieser Ebene. Auf der in-
ternen Ebene werden alle implementierungsabhängigen Eigenschaften (z. B.
Darstellung oder Organisation) der Daten implementiert. Desweiteren wer-
den Funktionen für den schnellen Datenzugriﬀ bereitgestellt. Die externe
Ebene beschreibt die Datenbank aus Sicht des Anwenders. Diese Sicht kann
je nach Anwendungsprogramm und User unterschiedlich sein.

(cid:27)

------------------------------------------------------------------------
Frühjahr 08 - Thema 1

453

2. Für die Verwaltung von Abteilungen, Mitarbeitern und Gehältern einer gro-
ßen Firma wird eine Datenbank eingesetzt. Das 3-Schichten-Modell ermöglicht
es nun eine bereits bestehende logische Struktur einer anderen Firma zu über-
nehmen und nur die interne und externe Ebene anzupassen. Des weiteren ist
es möglich eine neue Anwendersoftware zu integrieren ohne das komplette
Datenbanksystem zu überarbeiten. Auch neue Benutzersichten beeinﬂussen
nur die externe Ebene.

Aufgabe 4

Die Normalformenlehre befasst sich mit der Fragestellung, wie
lationenschemata erkannt und gegebenenfalls verbessert werden können.
1. Nennen Sie die drei möglichen grundlegenden Anomalien, die durch Norma-

schlechte“ Re-
”

lisierung vermieden werden, beim Namen!

2. Welche Aussagen sind für funktionale Abhängigkeit richtig (W, X, Y und Z

Anomalien,
funktionale
Abhängig-
keit,
Normalfor-
men

sind beliebige Attributmengen)?

a) X → Y
b) X → Y und Z ⊆ Y
c) X → Y und Y W → Z ⇒ XW → Z
d) X → Y und Z → Y

⇒ Y ⊆ X
⇒ X → Z

⇒ Z → X

3. Warum ist folgende Relation nicht in zweiter Normalform? Und warum

werden Adressen dennoch häuﬁg so gespeichert?
Adresse{Straße, Hausnummer, Postleitzahl, Wohnort}

4. Wie muss folgende Relation mit weiteren funktionalen Abhängigkeiten

B → D und D → E zerlegt werden, damit sie in dritter Normalform vor-
liegt?

R{A, B, C, D ,E}

1. Update-Anomalie, Insert-Anomalie, Delete-Anomalie

2.

a) falsch
b) richtig
c) richtig
d) falsch

3. Da der Wohnort bereits durch Postleitzahl und Straße bestimmt ist, ist
die 2NF verletzt. Andererseits muss Hausnummer im Primärschlüssel enthal-
ten sein, da es keine funktionale Abhängigkeit gibt, bei der Hausnummer auf
der rechten Seite steht. Würde man die Relation Adresse in zwei Relationen
Adresse(Straße, Hausnummer, Postleitzahl) und
Wohnort(Straße, Postleitzahl, Wohnort)
aufteilen, müssen bei einer Adressänderung immer zwei Tabellen upgedatet
werden. Es kann also zu einer Update-Anomalie kommen.


------------------------------------------------------------------------
5 Datenbanken

454

4.

R1(A, B, C)

R2(B, D)
R3(D, E)

Aufgabe 5

2 Phasen-
Commit-
Protokoll,
Transak-
tion,
Operation,
ACID-
Prinzip

1. Welche grundlegenden Eigenschaften müssen Datenbanktransaktionen heu-
te garantieren? Benennen Sie jede Eigenschaft und beschreiben Sie jede
mit maximal einem Satz!

2. Können zwei parallel ablaufende Transaktionen (eine lesend die andere
schreibend), unter Garantie der oben deﬁnierten Eigenschaften, gleich-
zeitig auf dasselbe Datenbankobjekt zugreifen? Begründen Sie Ihre Ant-
wort mit maximal drei Sätzen!

3. Geben Sie an, welche Operationen auf Transaktionsebene Sie kennen, und

beschreiben Sie jede mit maximal zwei Sätzen!

4. Sie haben das sogenannte

2 Phasen-Commit-Protokoll“ kennengelernt.
”

Skizzieren Sie das Szenario und erklären Sie die unterschiedlichen Abläufe,
die entweder zu einem erfolgreichen oder nicht erfolgreichen Abschluss
führen!

1. ACID-Prinzip:

Atomicity:

Eine Transaktion ist atomar, d. h. es werden entweder keine
oder alle änderungen durchgeführt.

Consistency: Eine Transaktion überführt eine Datenbank von einem kon-

Isolation:

Durability:

sistenten Zustand in einen konsistenten Zustand.
Eine Transaktion beeinﬂusst andere Transaktionen nicht
und wird auch nicht von ihnen beeinﬂusst.
Die durch eine Transaktion vorgenommenen änderungen
sind dauerhaft.

2. Es kann nicht vorkommen, dass zwei Transaktionen gleichzeitig lesend und
schreibend auf ein Datenobjekt zugreifen, denn dadurch wäre das Prinzip
der Isolation verletzt. Die lesende Transaktion würde von der schreibenden
beeinﬂusst.


------------------------------------------------------------------------
Frühjahr 08 - Thema 1

455

3. Folgende grundlegende Operationen können mittels Transaktionen ausgeführt

werden:
read:
write:

trans-

begin of
action (BOT):
commit:

abort:

Ein Objekt wird aus der Datenbank gelesen.
Ein (geändertes) Objekt wird in die Datenbank geschrie-
ben.
Dadurch wird der Beginn einer Transaktion gekennzeich-
net.
Dieser Befehl wird bei einem erfolgreichen Ende der
Transaktion ausgeführt. Dadurch werden alle änderun-
gen permanent in die Datenbank geschrieben.
Bei einem auftretenden Fehler wird abort ausgeführt.
Dadurch werden alle änderungen wieder rückgängig ge-
macht. Eine Transaktion endet immer entweder mit abort
oder commit.

Zusätzlich sind noch die Sperren zu erwähnen:

rlock:

xlock:
unlock:

Lesesperre auf Daten, kann auch mehreren Transaktionen
parallel gewährt werden
Schreibsperre zum exklusiven Zugriﬀ auf Daten
Aufhebung von Sperren

4. Das 2-Phasen-Commit-Protokoll:

Die Abarbeitung von Transaktionen erfolgt zweiphasig, wenn keine Transak-
tion eine Sperre freigibt, bevor sie alle benötigten Sperren angefordert hat.
Ein 2-Phasen-Commit-Protokoll wird dadurch realisiert, dass

• eine Transaktion sukzessive alle benötigten Sperren anfordert,
• alle Lesesperren bis zum Ende, d. h. bis zur Aktion commit, hält und
• alle Schreibsperren bis nach commit hält.

Im folgenden Beispiel wollen zwei Transaktionen auf die gleichen Daten A zu-
greifen. Bevor jedoch der Datensatz gelesen werden kann, muss eine Schreib-
sperre angefordert werden (Da die Daten auch geändert werden sollen, reicht
eine Lesesperre nicht aus.). Nachdem Transaktion1 die Schreibsperre vom
DBMS bewilligt bekommen hat, können die Daten gelesen werden. Solan-
ge Transaktion1 die Schreibsperre hält, bekommt Transaktion2 die ebenfalls
angeforderte Schreibsperre nicht bewilligt. Transaktion2 muss also warten,
bis Transaktion1 beendet ist und die Sperre wieder frei gibt. Erst danach
kann Transaktion2 weiter ausgeführt werden. Beide Transaktionen kommen
so zu einem erfolgreichen Abschluss ohne Konﬂikte.


------------------------------------------------------------------------
456

5 Datenbanken

Falls aus irgendeinem Grund Transaktion1 in Schritt 9 abgebrochen wird,
werden alle bis dahin vorgenommenen änderungen verworfen und danach
die Sperren wieder frei gegeben. Auch in diesem Fall kann es keine Konﬂikte
mit anderen Transaktionen geben.

Schritt Transaktion1
BOT

xlock (A)
read(A) -> x

x: = x + 3
x -> write(A)
commit
unlock (A)

Schritt Transaktion1
BOT

xlock (A)
read(A) -> x

x: = x + 3
x -> write(A)
abort
unlock (A)

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15

Transaktion2

BOT

xlock (A)
DELAY

read(A) -> y
y: = y + 1
y -> write(A)
commit
unlock (A)

Transaktion2

BOT

xlock (A)
DELAY

read(A) -> y
y: = y + 1
y -> write(A)
commit
unlock (A)

Obwohl durch das 2-Phasen-Commit-Protokoll das Lost-Update-, das Un-
repeatable-Read- und das Dirty-Read-Problem verhindert werden, kann es
zu Verklemmungen und damit zu einem nicht erfolgreichen Abschluss von
Transaktionen kommen.


------------------------------------------------------------------------
Frühjahr 08 - Thema 1

457

Schritt Transaktion1 Transaktion2

1
2
3
4
5
6
7
8
9
10
11
12

BOT

rlock (A)
read(A) -> x

BOT

x: = x + 3

xlock (A)
DELAY

rlock (A)
read(A) -> y

y := y + 1

xlock (A)
DELAY

Transaktion1 benötigt nach Schritt 7 eine Schreibsperre um die geänderten
Daten in die Datenbank zu übertragen. Eine Schreibsperre wird der Transak-
tion aber nur gewährt, wenn auf dem entsprechenden Objekt keine anderen
Sperren, insbesondere auch keine Lesesperren existieren. Transaktion1 muss
also warten, bis Transaktion2 die Lesesperre auf A aufhebt. Transaktion2
will aber ebenfalls geänderte Daten schreiben und fordert eine Schreibsperre
in Schritt 11 an und muss warten, bis Transaktion1 die Lesesperre aufhebt.
Nun warten die beiden Transaktionen gegenseitig und es kommt zum Dead-
lock, der vom DBMS erkannt und aufgelöst werden muss.

Aufgabe 6

1. Erstellen Sie das ER-Diagramm einer ﬁktiven Zimmerverwaltung

eines Krankenhauses!
Wo möglich bzw. sinnvoll sollen dreifache Beziehungen und Generalisie-
rung/Spezialisierung verwendet werden. Attribute von Entitäten und Be-
ziehungen sind anzugeben; Schlüsselattribute werden durch Unterstrei-
chung gekennzeichnet. Die Kardinalitäten von Beziehungen und - falls nö-
tig - Rollennnamen sollen ins Diagramm aufgenommen werden. Verwenden
Sie zur Angabe der Kardinalität die (min, max)-Notation! Führen Sie Sur-
rogatschlüssel nur ein, falls es nötig ist!

ER-Model-
lierung,
Relationen-
schema


------------------------------------------------------------------------
458

5 Datenbanken

”

Im Krankenhaus“
Zimmer werden durch eine eindeutige Zimmernummer identiﬁziert. Wei-
terhin sind noch die Anzahl der Betten und die Größe in qm des Zimmers
angegeben.
Das Krankenhaus beschäftigt Personal, wobei es zwei besondere Personen-
gruppen gibt: ärzte und Schwestern. Jede Person hat eine Personalnum-
mer, Vorname und Nachname. Schwestern haben zusätzlich eine vereinbarte
Wochenarbeitszeit und ärzte ihr Approbationsjahr und die -behörde gespei-
chert.
Das Personal ist in verschiedenen Stationen (als Krankenhausabteilun-
gen) beschäftigt. Jede Station wird durch genau eine Schwester geleitet.
Außerdem gibt es zu jeder Station genau einen Arzt, der zu ihr in Chefarzt-
Beziehung steht. Es gibt im Krankenhaus ärzte, die nicht Chefarzt einer
Station sind.
Jeder Dienstplan hat ein Beginn- und Enddatum. Durch den Dienstplan
wird festgelegt, welche Schwester welches Zimmer betreuen muss. Es gibt
keine leeren Dienstpläne und auch keine untätigen Schwestern; manche der
Zimmer werden allerdings nicht von Schwestern betreut, da sie nicht der
Patientenunterbringung dienen.

2. Ausgehend von Ihrem ER-Diagramm-Entwurf aus Aufgabenteil

1. ist ein Relationenschema in dritter Normalform (3NF) zu ent-
werfen.
Primärschlüssel werden dabei durch Unterstreichen, Fremdschlüssel durch
Nennung der referenzierten Relation in eckigen Klammern hinter dem Attri-
butnamen kenntlich gemacht. Attribute, die nicht Primärschlüssel sind,
aber dennoch
nen.

UNIQUE“ sein müssen, sind zu kennzeich-
”

NOT NULL“ bzw.
”

Folgende willkürliche Beispiele dienen als Hinweis auf die Notation:

Haus (Straße, OrtId[Ort])
Ort (OrtId, PLZ, Name)
Mitarbeiter (PersNr, Vorname, Nachname, SozialversNr)
SozialversNr: UNIQUE


------------------------------------------------------------------------
Frühjahr 08 - Thema 1

459

1.

B e g i n n

D i e n s t p l a n N r

E n d e

D i e n s t p l a n

B e t t e n a n z a h l

( 1 , * )

Z i m m e r N r

G r o e s s e

( 1 , * )

g i l t _ f u e r

( 0 , * )

Z i m m e r

W o c h e n a r b e i t s z e i t

S c h w e s t e r

( 0 , 1 )

l e i t e t

( 1 , 1 )

i s   a

P e r s o n a l N r

N a c h n a m e

P e r s o n

( 1 , 1 )

a r b e i t e t _ a u f

( 2 , * )

S t a t i o n

S t a t i o n s n a m e

V o r n a m e

i s   a

( 0 , 1 )

A r z t

i s t _ C h e f a r z t

( 1 , 1 )

A p p J a h r

A p p B e h

2. Relationenschema nach ER-Modell (noch ohne Verfeinerung, Primärschlüs-

sel sind unterstrichen, Fremdschlüssel kursiv dargestellt):

Entitäten:
Zimmer(ZimmerNr, Bettenanzahl, Groesse),
Dienstplan(DienstplanNr, Beginn, Ende),
Station(Stationsname),
Person(PersonalNr, Vorname, Nachname),
Schwester(PersonalNr, Wochenarbeitszeit),
Arzt(PersonalNr, AppJahr, AppBeh)


------------------------------------------------------------------------
460

5 Datenbanken

Relationships:
gilt fuer(DienstplanNr, PersonalNr, ZimmerNr),
(Dabei wird angenommen, dass ein Dienstplan für jede Schwester festlegt,
in welchem Zimmer sie arbeitet.)
leitet(Stationsname, PersonalNr),
arbeitet auf(PersonalNr, Stationsname),
ist Chefarzt(Stationsname, PersonalNr)

Folgende Attribute müssen
Groesse, Beginn, Ende, Vorname, Nachname, AppJahr, AppBeh
Es gibt keine Attribute, die

NOT NULL“ sein:
”

UNIQUE“ sein müssen.
”

Verfeinerung des Relationenschemas:
Die Relationen leitet und ist Chefarzt können mit Station und ar-
beitet auf kann mit Person zusammengefasst werden.

Zimmer(ZimmerNr, Bettenanzahl, Groesse),
Dienstplan(DienstplanNr, Beginn, Ende),
Station(Stationsname, Leiterin, Chefarzt),
Person(PersonalNr, Vorname, Nachname, Station),
Schwester(PersonalNr, Wochenarbeitszeit),
Arzt(PersonalNr, AppJahr, AppBeh),
gilt fuer(DienstplanNr, PersonalNr, ZimmerNr)

Alle Attribute seien atomar, damit erfüllt das Relationenschema die 1NF.
Außerdem ist das Relationenschema auch in 2NF, da alle Attribute voll funk-
tional vom gesamten Schlüsselkandidaten abhängen (eine Verletzung kann
nur bei zusammengesetzten Schlüsselkandidaten vorliegen und auch das ist
bei gilt fuer nicht der Fall). Weil für die einzelnen Relationenschemata kei-
ne weiteren funktionalen Abhängigkeiten bekannt sind, können auch keine
transitiven Abhängigkeiten vorliegen und damit ist auch die 3NF erfüllt.

Aufgabe 7

SQL Beachten Sie:

Primärschlüssel werden durch Unterstreichen, Fremdschlüssel durch Nennung
der referenzierten Relation in eckigen Klammern hinter dem Attributnamen
kenntlich gemacht.
Beispiel:
Haus (Straße, OrtId[Ort])
Ort
Interpretation:
Das Attribut OrtId der Relation Haus verweist als Fremdschlüssel auf das At-
tribut OrtId der Relation Ort.

(OrtId, PLZ, Name)


------------------------------------------------------------------------
Frühjahr 08 - Thema 1

461

”

Kundenverwaltung“
Ein Unternehmen verwendet folgendes Datenbankschema für seine Verwal-
tung:
Kunde(KNr, Name, Vorname)
Bestellung(BNr, Datum)
Artikel(ANr, Bezeichnung , KatNr[Kategorie])
Best K A(BNr[Bestellung], ANr[Artikel], KNr[Kunde], Anzahl)
Kategorie(KatNr, Bezeichnung)

In Best K A sind Teilbestellungen gespeichert.
Formulieren Sie folgende Datenbankoperation in SQL:
Einfache Anfragen:
a) Bestellungen sollen als Ganzes geliefert werden. Für Verhandlungen mit ei-
nem Lieferdienst soll ermittelt werden, wie viele Artikel eine Bestellung
durchschnittlich enthält.

b) Es soll eine Kundenliste erstellt werden und dabei ausgegeben werden,
wann der Kunde zuletzt eine Bestellung aufgegeben hat. Darzustellen
sind KNr, Name, Vorname und Datum der letzten Bestellung. Das Ergebnis
soll nach Datum absteigend sortiert sein.

Datenänderungen:
c) Ein neuer Kunde ist einzufügen. Er heißt ’Hans Müller’ und er soll die
Kundennummer bekommen, die eins größer ist als die bisher größte!
d) Einige Artikel wurden noch keiner Kategorie zugeordnet (Artikel.KatNr

ist NULL). Diese Artikel sind der Kategorie zuzuordnen, die die Bezeichnung
’Sonstiges’ trägt.

e) Um zukünftige Produktverwechslungen bei Bestellungen auszuschließen, sol-
len alle Artikel mit der Bezeichnung ’Waage’ aus der Kategorie ’Kuechen-
geraet’ in ’Kuechenwaage’ umbenannt werden.

f) Im Datenbestand ist ein Fehler aufgetreten. Natürlich ergeben Teilbestel-

lungen keinen Sinn, wenn Anzahl = 0 ist. Daher sind alle Einträge
aus Best K A zu löschen, deren Anzahl = 0 ist.

Komplexe Anfragen: (Es dürfen kein TOP(n) oder LIMIT verwendet werden!
Sichten sind ausdrücklich erlaubt!)
g) Es sollen die fünf Kunden mit der größten Anzahl an bestellten Artikeln

(Summe) ermittelt werden. Auszugeben sind Vorname, Name und Gesamt-
zahl der verkauften Artikel sortiert nach Name aufsteigend.

h) Es sollen die fünf am meisten (nicht am häuﬁgsten) bestellten Artikel

(Summe der Anzahl) ermittelt werden. Auszugeben sind Artikelbezeich-
nung und Gesamtzahl sortiert nach Artikelbezeichnung aufsteigend.
Achtung: Unterschiedliche Artikel (unterschiedliche Artikelnummer) kön-
nen die gleiche Bezeichnung tragen!

a) SELECT AVG(SUM(Anzahl))

FROM Best K A
GROUP BY BNr;


------------------------------------------------------------------------
462

5 Datenbanken

b) SELECT DISTINCT KNr,Name,Vorname,MAX(Datum) AS letzteBestellung

FROM Kunde, Bestellung, Best K A
WHERE Bestellung.BNr = Best K A.BNr

AND Kunde.KNr = Best K A.KNr

GROUP BY Kunde.KNr
ORDER BY letzteBestellung DESC;

c) INSERT INTO Kunde

VALUES ( (SELECT MAX(KNr) FROM Kunde) +1, ’Mueller’, ’Hans’);

d) UPDATE Artikel

SET KatNr = (SELECT KatNr

FROM Kategorie

WHERE Bezeichnung = ’sonstiges’)

WHERE KatNr = NULL;

e) UPDATE Artikel

SET Bezeichnung = Kuechenwaage
WHERE Bezeichnung = ’Waage’ AND KatNr = (SELECT KatNr

FROM Kategorie

WHERE Bezeichnung = ’Kuechengeraet’);

f) DELETE FROM Best K A
WHERE Anzahl = 0;

g) CREATE VIEW Gesamtzahl AS

SELECT Vorname, Name, SUM(Anzahl) AS Gesamt
FROM Kunde, Bestellung, Best K A
WHERE Kunde.KNr = Best K A.KNr
GROUP BY Kunde.KNr
ORDER BY Gesamt DESC;

SELECT Vorname, Name, Gesamt
FROM Gesamtzahl
WHERE ROWNUM BETWEEN 1 AND 5
ORDER BY Name ASC;

h) CREATE VIEW Gesamtzahl2 AS

SELECT Bezeichnung, Artikel.ANr, SUM(Anzahl) AS Gesamt
FROM Artikel, Best K A
WHERE Artikel.ANr = Best K A.ANr
GROUP BY Artikel.ANr
ORDER BY Gesamt DESC;

SELECT Bezeichnung, Gesamt
FROM Gesamtzahl2
WHERE ROWNUM BETWEEN 1 AND 5
ORDER BY Bezeichnung ASC;


------------------------------------------------------------------------
ER-Model-
lierung,
Relationen-
schema

Frühjahr 08 - Thema 2

463

Frühjahr 08 - Thema 2

Aufgabe 1

Das Fremdenverkehrsamt will sich einen besseren überblick über Zirkusse ver-
schaﬀen. In einer Datenbank sollen dazu die Zirkusse, die angebotenen Vorstel-
lungen, die einzelnen Darbietungen in einer Vorstellung sowie die zugehörigen
Dompteure und Tiere verwaltet werden.
Ein Zirkus wird eindeutig durch seinen Namen gekennzeichnet und hat einen
Besitzer. Vorstellungen haben eine VorstellungsID und ein Datum. Darbie-
tungen neben der eindeutigen ProgrammNr ein Uhrzeit. Ein Dompteur hat eine
eindeutige AngestelltenNr sowie einen Künstlernamen. Tiere sind eindeutig
durch eine TierNr bestimmt und haben außerdem eine Bezeichnung der Tier-
art.
Vorstellungen werden von genau einem Zirkus angeboten. Ein Zirkus bietet
mehrere Vorstellungen an und stellt mehrere Dompteure an. Ein Dompteur ist
genau bei einem bestimmten Zirkus angestellt. Eine Darbietung ﬁndet in ei-
ner bestimmten Vorstellung statt. Des weiteren trainiert ein Dompteur mehrere
Tiere, ein Tier kann allerdings auch von mehreren Dompteuren trainiert wer-
den. In einer Darbietung tritt genau ein Dompteur mit mindestens einem Tier
auf.
1. Erstellen Sie ein Entity-Relationship-Diagramm für obige Datenbank!
2. Setzen Sie das in a) erstellte Entity-Relationship-Diagramm in ein Relatio-
nenschema um! Dabei sind Relationships mit einer möglichst geringen An-
zahl von Relationen zu realisieren, wobei unnötige Redundanzen vermieden
werden sollen. Ein Relationenschema ist in folgender Form anzugeben:
Relation(Attribut1, Attribut2, ...). Schlüsselattribute sind dabei zu
unterstreichen. Achten Sie bei der Wahl des Schlüssels auf Eindeutigkeit
und Minimalität!


------------------------------------------------------------------------
464

1.

5 Datenbanken

Z - N a m e

B e s i t z e r

V o r s t e l l u n g s I D

D a t u m

Z i r k u s

1

b i e t e t _ a n

n

V o r s t e l l u n g

1

f i n d e t _ s t a t t

1

t r i t t _ a u f

n

D a r b i e t u n g

n

P r o g r a m m N r

m

U h r z e i t

1

s t e l l t _ a n

n

D o m p t e u r

n

t r a i n i e r t

m

T i e r

A n g e s t e l l t e n N r

K u e n s t l e r n a m e

T i e r a r t

T i e r N r

2. Relationenschema nach ER-Modell (noch ohne Verfeinerung, Primärschlüs-

sel sind unterstrichen, Fremdschlüssel kursiv dargestellt):
Entitäten:
Zirkus(Z-Name, Besitzer),
Vorstellung(VorstellungsID, Datum),
Darbietung(ProgrammNr, Uhrzeit),
Dompteur(AngestelltenNr, Kuenstlername),
Tier(TierNr, Tierart)

Relationships:
bietet an(Z-Name, VorstellungsID),
findet statt(VorstellungsID, ProgrammNr),
stellt an(Z-Name, AngestelltenNr),
trainiert(AngestelltenNr, TierNr),
tritt auf(ProgrammNr, TierNr, AngestelltenNr)

Verfeinerung des Relationenschemas:
Die Relationen bietet an und Vorstellung, findet statt und Darbie-
tung, stellt an und Dompteur können zusammengefasst werden.

Zirkus(Z-Name, Besitzer),
Vorstellung(VorstellungsID, Datum, Z-Name),
Darbietung(ProgrammNr, Uhrzeit, VorstellungsID),
Dompteur(AngestelltenNr, Kuenstlername, Z-Name),
Tier(TierNr, Tierart),
trainiert(AngestelltenNr, TierNr),
tritt auf(ProgrammNr, TierNr, AngestelltenNr)


------------------------------------------------------------------------
Frühjahr 08 - Thema 2

Aufgabe 2

465

Normalfor-
men,
funktionale
Abhängig-
keit,
Normalisie-
rung,
Syntheseal-
gorithmus

Gegeben sei das Relationenschema R(A, B, C, D, E, F, G). Die Attribute sei-
en atomar, d. h. R ist in 1. Normalform. Neben {A} gibt es keine weiteren
Schlüsselkandidaten. Zusätzlich zu den durch die Schlüsselkandidaten gelten-
den funktionalen Abhängigkeit: D → E, D → F, F → G.
a) Ist R in 2. Normalform? Begründen Sie Ihre Antwort!
b) Ist R in 3. Normalform? Begründen Sie Ihre Antwort!
c) Zerlegen Sie R in mehrere Relationen, die alle in 3. Normalform (wenden

Sie ein Verfahren Ihrer Wahl an)! Geben Sie für jede der neuen Relationen
einen Schlüssel an!

Geben sei das Relationenschema S(A, B, C, D, E, F ). Die Attribute seien ato-
mar, d. h. S ist in 1. Normalform. Neben {A, B} gibt es keine weiteren Schlüssel-
kandidaten. Zusätzlich zu den durch die Schlüsselkandidaten geltenden funktio-
nalen Abhängigkeit: A → C, A → E, B → E.
d) Ist R in 2. Normalform? Begründen Sie Ihre Antwort!
e) Ist R in 3. Normalform? Begründen Sie Ihre Antwort!
f) Zerlegen Sie R in mehrere Relationen, die alle in 3. Normalform (wenden

Sie ein Verfahren Ihrer Wahl an)! Geben Sie für jede der neuen Relationen
einen Schlüssel an!

a) Die zweite Normalform ist dann verletzt, wenn Attribute nur von Teilen des
Schlüsselkanditaten abhängen. Bei einem einelementigen Schlüsselkandida-
ten gibt es keine Teilmengen und damit müssen alle Attribute vom ganzen
Schlüsselkandidaten abhängen. Die zweite Normalform ist also zwangsläuﬁg
erfüllt.

b) Das Relationenschema ist nicht in dritter Normalform, da z. B. die transitive

Abhängigkeit A → D, D → E besteht.

c) Methode

scharfes Hinsehen“:
”
R1(A, B, C, D)
R2(D, E, F )
R3(F , G)

d) Aufgrund der funktionalen Abhängigkeit A → C ist die zweite Normalform
verletzt, da C nur von einem Teil des Schlüsselkandidaten A, B abhängt.

e) Da das Relationenschema bereits die zweite Normalform verletzt, kann es
nicht in dritter Normalform sein, da jedes Schema in dritter Normalform
auch in erster und zweiter Normalform ist.


------------------------------------------------------------------------
466

5 Datenbanken

f) Anwendung des Synthese-Algorithmus

überführung in einfache FDs:

A, B → C; A, B → D; A, B → E; A, B → F
A → C; A → D
B → E

Eliminieren redundanter Attribute und FDs:
Das Entfernen von B in A, B → C führt zu A → C, was bereits enthalten
ist und damit ist sogar die ganze FD A, B → C redundant.
Gleiches gilt für A, B → D und A, B → E analog. Bei der FD A, B → F
ist weder A noch B redundant, da F nur in dieser FD vorkommt und nicht
anders erreicht werden kann.
Es bleiben also:

A, B → F
A → C; A → D
B → E

Alle Attribute auf der rechten Seite kommen nur einmal vor, deshalb kann
es keine weiteren redundanten FDs mehr geben.

Zerlegen in Teilschemata:

R1(A, B, F )

R2(A, C)
R3(A, D)
R4(B, E)

Es werden keine weiteren Relationen benötigt, da der Schlüsselkandidat in
R1 enthalten ist und alle Attribute bereits enthalten sind. Weil aufgrund
der vorangegangenen Schritte die Menge der verbliebenen FDs minimal ist,
können R2 und R3 zusammengefasst werden.

R1(A, B, F )

R23(A, C, D)
R4(B, E)


------------------------------------------------------------------------
Frühjahr 08 - Thema 2

Aufgabe 3

467

SQL

(FNR, Ort)

(ANR, Bezeichnung, LeiterPNR, FNR)

Gegeben sei das folgende relationale Datenbankschema (Schlüsselattribute sind
jeweils unterstrichen):
Personal (PNR, Name, Geburtsdatum, Gehalt, ANR)
Abteilung
Filiale
In der Datenbank sind die Daten von Mitarbeiter, Abteilungen und Filialen
eines Handelsunternehmens gespeichert. Jeder Mitarbeiter hat eine Personal-
nummer (PNR), einen Namen, ein Geburtsdatum, ein Gehalt und ist in einer
bestimmten Abteilung beschäftigt. Jede Abteilung hat eine Anteilungsnummer
(ANR), eine Bezeichnung, die Personalnummer des Abteilungsleiters (LeiterP-
NR) und gehört zu einer bestimmten Filiale. Jede Filiale hat eine Filialnummer
(FNR) und ist in einem Ort beheimatet.
Formulieren Sie folgende Anfragen in SQL:
a) Geben Sie für jede Abteilung die Nummer und die Bezeichnung der Abtei-
lung zusammen mit der Personalnummer und dem Namen des Abteilungs-
leiters aus. Das Ergebnis soll aufsteigend nach der Abteilungsnummer sor-
tiert werden.

b) Geben Sie diejenigen Orte aus, in denen mehr als zwei Filialen beheima-

tet sind.

c) Finden Sie die Personalnummern derjenigen Mitarbeiter, für die ein ande-

rer Mitarbeiter mit dem gleichen Geburtsdatum existiert.

a) SELECT ANR, Bezeichnung, PNR, Name

FROM Abteilung, Personal
WHERE Personal.PNR = Abteilung.LeiterPNR
ORDER BY ANR;

b) SELECT Ort

FROM Filiale
GROUP BY Ort
HAVING COUNT (*) >2;

c) SELECT DISTINCT PNR

FROM Personal AS P1, Personal AS P2
WHERE (P1.Geburtsdatum = P2.Geburtsdatum)

AND NOT (P1.PNR = P2.PNR);


------------------------------------------------------------------------

------------------------------------------------------------------------
Literaturverzeichnis

Balzert, Heide: Lehrbuch der Objektmodellierung - Analyse und Entwurf, Spek-
trum, Akademischer Verlag, Heidelberg (1999).

Blöchl, Barbara / Meyberg, Carola: Repetitorium der Informatik, Oldenbourg Wis-
senschaftsverlag, München (2003).

Dr. Claus, Volker / Dr. Schwill, Andreas: Duden Informatik - Ein Fachlexikon für
Studium und Praxis, Dudenverlag, Mannheim (2001).

Prof. Gumm, Heinz Peter/ Prof. Sommer, Manfred: Einführung in die Informatik,
Oldenbourg Wissenschaftsverlag, München (2006).

Prof. Kemper, Alfons / Dr. Eickler, Andr´e: Datenbanksysteme - Eine Einführung,
Oldenbourg Wissenschaftsverlag, München (2001).

Schöning, Uwe: Logik für Informatiker (5. Auﬂage), Spektrum, Akademischer Ver-
lag, Heidelberg (2000).

Schöning, Uwe: Theoretische Informatik - kurzgefasst (4. Auﬂage), Spektrum, Aka-
demischer Verlag, Heidelberg (2001).

Tanenbaum, Andrew S.: Moderne Betriebssysteme (2. überarbeitete Auﬂage), Pear-
son Studium, München (2002).


------------------------------------------------------------------------

------------------------------------------------------------------------
Index

1NF, 378, 382, 407, 412, 438, 465
2 Phasen-Commit-Protokoll, 395, 454
2-3-4 Baum, 127, 175
2NF, 346, 357, 372, 378, 382, 390,

407, 412, 438, 453, 465

3NF, 346, 357, 362, 367, 372, 378,
382, 388, 390, 405, 407, 412,
428, 438, 440, 448, 453, 465

Ableitung eines Wortes, 3, 6, 13, 40,

42, 56, 88, 105
Ableitungsbaum, 29, 71
Ableitungsregel, 88
Abstiegsfunktion, 120, 132, 150, 153
abzählbar, 39
ACID-Prinzip, 257, 379, 381, 395, 419,

424, 438, 454

Adjazenzliste, 192
Adjazenzmatrix, 145, 156, 192
Adressraum, 258
äquivalenzklasse, 65, 79
Algorithmus, 122, 134, 152, 153, 171,

187, 200
Greedy-, 199
iterativer, 119, 153, 167, 177, 192
nichtdeterministischer, 60
rekursiver, 167, 177, 189, 192
Sortier-

Insert, 165
Quicksort, 185

terminierend, 119, 136, 150, 153,

160

Algorithmus von Dijkstra, 145, 156,

168, 184, 207

allgemeingültig, 37
Anomalie, 346, 362, 367, 379, 412, 420,

453

Anomalie (Fortsetzung)

INSERT-, 346, 362, 367, 382, 412,

420, 453

UPDATE-, 346, 362, 367, 382,

412, 420, 453

ANSI/Sparc, 416, 450, 452
Assoziation, 221
Attribut, 375, 379, 394, 435
Attributhülle, 388, 405, 448
Aufzugsstrategie, 232
Aussagenlogik, 12, 26, 36, 47
Automat, 56, 75, 83, 98, 100, 105,

109, 172

DEA, 22, 28, 40, 42, 45, 48, 54,
56, 59, 64, 75, 80, 83, 93, 98,
100, 105, 109

deterministischer, 10, 28, 45, 67,

68, 80, 93

endlicher, 22, 28, 42, 56, 65, 75,

83, 98, 100, 105, 109, 172
deterministischer, 1, 6, 10, 13,
22, 40, 42, 45, 48, 54, 56, 59,
64, 67, 68, 75, 80, 83, 89, 93,
98, 100, 105, 109

nicht-deterministischer, 1, 22,
28, 40, 42, 48, 54, 56, 75, 83,
98, 100, 105, 109
erkennender, 10, 45, 65, 68
Keller-, 17, 31, 52, 55, 62, 65
LBA, 31, 103
linear beschränkter, 31, 103
NEA, 22, 28, 40, 42, 48, 54, 56,
75, 83, 98, 100, 105, 109

Zustands-, 61
AVL-Baum, 154, 182

Banker’s Algorithmus, 264, 302, 325
Baum, 122, 127, 149, 170, 175

2-3-4 ∼, 127, 175
AVL-, 154, 182


------------------------------------------------------------------------
472

Index

Baum (Fortsetzung)

B-Baum, 365, 370
balancierter, 131, 146, 179
binärer, 116, 140, 146, 149, 179
binärer Such-, 131, 140, 146, 154,

179, 193, 234
Such-, 140, 146, 179

BCNF, 346, 357, 448
Beladys Anomalie, 236
Bereich

sicherer, 270
unmöglicher, 270
unsicherer, 270

Best Fit, 232, 284, 292, 322
Betriebsmittel, 230, 244, 262, 264, 270,

339

Zugriﬀ auf, 262, 264, 339
Betriebsmittelgraph, 244, 262, 339
Breitensuche, 149

call by reference, 160
call by value, 160
charakteristische Funktion, 46
Chomsky-Hierarchie, 17, 38, 55, 72,

96

Clock-Algorithmus, 271, 298, 300

Data Manipulation Language, 450
Dateiattribut, 308, 314, 329
Dateisystem, 275, 303, 308, 314, 326,

329

Hard-Link, 314, 329
Symbolic-Link, 314, 329
UNIX, 237, 308, 314, 329
Datenbank, 394, 403, 435, 436, 450
Datenbankanfrage, 341, 349, 365, 390,
400, 402, 403, 421, 432, 435,
436, 445, 447, 460, 467

relational, 355, 368, 373
SQL, 345, 348, 352, 355, 360, 364,
368, 373, 376, 380, 385, 386,
390, 400, 402, 403, 408, 414,
421, 432, 442, 460, 467

Datenbankentwurf, 390, 398, 403, 412,

424

Datenbankmanagementsystem, 450
Datenbanksystem, 394, 398, 415, 416,

424, 435

Datentyp, 134
DBMS, 450
DBS, 398, 415, 416, 424
DDL, 394
DEA, 22, 28, 40, 42, 45, 48, 54, 56,
59, 64, 75, 80, 83, 93, 98,
100, 105, 109

Deadlock, 230, 233, 244, 256, 262, 270,
286, 295, 296, 302, 325, 339

Design-Pattern, 215
Dijkstra-Algorithmus, 145, 156, 168,

184, 207

Dispatcher, 239
Dispatching, 240, 311
DML, 435, 450
Drei-Schichten-Modell, 416, 450, 452

Entity, 343, 375, 376, 379, 396, 435,

445

schwache, 396, 435, 445

entscheidbar, 9, 10, 13, 20, 24, 35, 87,

102, 103

Entscheidbarkeit, 24
Entwurfsmuster, 215
ER-Modellierung, 341, 343, 352, 359,
365, 375, 376, 379, 380, 383,
386, 390, 396, 398, 403, 410,
412, 417, 421, 423, 424, 428,
440, 445, 457, 463

erfüllbar, 36, 37
Erzeuger-Verbraucher-Problem, 229,
245, 258, 276, 279, 295, 296,
309, 317, 321

FCFS, 282, 290, 300, 319
Feld, 149, 151, 152

zweidimensionales, 117, 179

FIFO, 236, 266
First Fit, 232, 284, 292, 322
First-come, First-served, 282, 290, 300,

319
Fragmentierung, 241
interne, 232

Fremdschlüssel, 375, 379, 386, 398,
403, 410, 412, 424, 428, 435,
440, 450

Funktion

assoziative, 69


------------------------------------------------------------------------
Index

473

Funktion (Fortsetzung)

Kardinalität, 221, 224, 359, 375, 379,

berechenbare, 87, 99
bijektive, 25, 69
charakteristische, 46
primitiv rekursive, 4, 23, 25, 119
rekursive, 124, 177
totale, 87

funktionale Abhängigkeit, 346, 350,
372, 378, 388, 390, 405, 412,
448, 453, 465

transitive, 346, 372
Funktionalität, 359, 386, 396

Gantt-Diagramm, 282, 319
Generalisierung, 396, 417, 428
Grammatik, 17, 19, 28, 29, 31, 45, 59,

64

eindeutige, 3, 29, 55, 71, 85
kontextfreie, 6, 9, 19, 29, 31, 34,
43, 52, 57, 59, 67, 88, 93, 102

mehrdeutige, 29, 85
rechtslineare, 1, 28, 41, 42
reguläre, 13, 17, 41, 42, 57, 83,

88, 93, 100, 105

Graph, 200
Greedy-Algorithmus, 199

Halteproblem, 99
Hard-Link, 314, 329
Hashfunktion, 146, 169
Hashing, 146, 169, 174
Hashtabelle, 146, 169
Hashverfahren, 146, 169, 174
Heap, 156, 203, 207
Heapsort, 151, 203
Hoare-Kalkül, 115, 149, 162

imperativ, 125
Index, 65
Inkonsistenz, 415
Integrität, 415

396

kartesisches Produkt, 451
Kellerautomat, 17, 31, 52, 55, 62, 65
nichtdeterministischer, 6, 55

Kelleroperation, 11, 25

empty, 11
leer, 25
pop, 11
push, 11, 25
rest, 25
top, 11, 25

Kernel-Level-Thread, 318
Klasse, 158, 160

abstrakte, 209
Konstruktor einer, 209

Klassendiagramm, 209, 213, 215, 216,

219–221, 224

Klausel, 12, 26, 36
Komplexität, 16, 44, 60, 102, 103, 107,
119, 125, 131, 137, 151, 164,
165, 187, 200, 203

Konﬂikt, 256
Konstruktor einer Klasse, 209
Korrektheit, 149
kritischer Bereich, 245, 249, 308

Laufzeit, 60, 154, 187, 200
least recently used, 271
Leser-Schreiber-Problem, 249
LFU, 254, 337
LIFO, 254
Liste, 80, 134, 138, 158, 179, 187

verkettete, 196
doppelt, 158
einfach, 131

logische Adresse, 241, 293, 306, 311,

323, 327

LRU, 236, 254, 266, 271, 298, 300,

337

referentielle, 375, 379, 394

iterativ, 137, 167, 177, 192

Mergesort, 196
Methode, 140, 149, 158, 160, 209, 216,

join, 451

künstlicher Schlüssel, 383

221
abstrakte, 209

Minimalisierung von Automaten, 1,

28, 48, 75, 79, 93, 98, 109


------------------------------------------------------------------------
474

Index

Minimalisierungsoperation, 66
Monitor, 242
µ-Operator, 66
Multi-Level-Scheduling, 319
Myhill-Nerode, 79

Nachbedingung, 116, 132, 162, 198
natural join, 451
NEA, 22, 28, 40, 42, 48, 54, 56, 75,
83, 98, 100, 105, 109
Normalform, 346, 357, 362, 367, 372,
378, 390, 398, 405, 407, 412,
420, 424, 438, 465

1NF, 378, 407, 412, 438
2NF, 378, 390, 407, 412, 438
3NF, 378, 388, 390, 398, 405, 407,

412, 428, 438, 440
Boyce-Codd-, 346, 357, 448
dritte, 346, 357, 362, 367, 372,
378, 382, 388, 398, 405, 407,
412, 428, 438, 440, 448, 453,
465

erste, 378, 382, 407, 412, 438, 465
zweite, 346, 357, 372, 378, 382,
407, 412, 438, 453, 465

Normalisierung, 346, 350, 357, 362,
367, 372, 378, 379, 382, 412,
438, 465

NP-hart, 56, 95
NP-vollständig, 56, 76, 95

O-Notation, 107, 137, 151, 154, 164,

165, 179, 200
Objektdiagramm, 216, 221, 224
objektorientierter Entwurf, 216, 219
Operation, 454
OPT, 266

Paarungsfunktion, 11, 25
paging, 254, 266

demand, 233, 234

partiell korrekt, 115, 132, 136
Partitionsproblem, 60, 76
Philosophenproblem, 287
physi(kali)sche Adresse, 233, 241, 293,
307, 311, 323, 327

Plattenzugriﬀsstrategie

SCAN, 232
shortest seek time ﬁrst, 232
SSF, 232

polynomiell reduzierbar, 56
Postsches Korrespondenzproblem, 20
Potenzmengenalgorithmus, 22, 48, 101,

105

Prädikatenlogik, 37
Preemptive SJF, 319
Preemptive-Shortest-Job-First, 319
Primärschlüssel, 345, 375, 379, 383,
394, 398, 403, 412, 424, 428,
435, 440, 450

primitiv-rekursiv, 4, 35, 36
Prioritätswarteschlange, 156
priority scheduling, 290
Produktion, 88
Produktionsregeln, 6, 29
Programm, 290, 304
FOR-, 143
GOTO-, 191
LOOP-, 131, 143, 191
WHILE-, 11, 131, 143, 173, 191

Programmierung

funktionale, 80, 125, 134, 136–

138, 149, 150
imperative, 125, 149
iterative, 137, 167, 177, 192
objektorientiert, 140
rekursive, 125, 137, 140, 167, 177,

192

Prozess, 229, 239, 240, 242, 245, 262,
270, 279, 290, 293, 295, 296,
300, 304, 323, 327, 328, 332,
334, 339
blockierter, 262
terminierender, 264, 270
Prozessfortschrittsdiagramm, 270
Prozesskontext, 334
Prozesskoordination, 242, 268, 276, 295,

296

Prozessor, 249
Prozessverwaltung, 239
Prozesswechsel, 334
Prozesszustand, 229, 240, 290, 293,

300, 323, 332


------------------------------------------------------------------------
Index

475

Prozesszustandsgraph, 231, 239, 240,

First-come, First-served, 290, 300,

332

Pumping-Lemma, 9, 62, 67, 72, 89,

102, 113

Quicksort, 151, 185

Reduktionsprinzip, 143
Redundanz, 415
regulärer Ausdruck, 1, 13, 22, 23, 28,
31, 34, 35, 45, 48, 54, 59, 64,
65, 67, 75, 83, 100, 109

Rekursion, 124, 189
rekursiv, 125, 137, 140, 167, 177, 192
rekursiv aufzählbar, 35, 39
Relation, 394

Schlüssel einer, 341, 345, 359, 365,
394, 423, 435, 440, 445

relationale Algebra, 341, 349, 400, 421,
424, 432, 436, 451

relationale Division, 424, 451
relationales Schema, 341, 345, 346,
349, 357, 359, 362, 365, 367,
372, 382, 386, 390, 394, 398,
405, 407, 412, 424, 435, 436,
440

Relationenalgebra, 355, 368, 373, 421,

432

Relationenschema, 352, 386, 390, 394,
398, 405, 407, 410, 412, 417,
423, 424, 428, 435, 436, 445,
448, 457, 463

Verfeinerung des, 352, 410
Relationship, 343, 375, 376, 379, 386
Resolution, 12, 26, 36
Ringpuﬀer, 245, 327, 328
Rolle, 375
Rotation, 154
Round-Robin, 252, 282, 290, 300, 319,

334
Rucksackproblem, 76

SCAN, 232
Scheduling, 240, 252, 306, 337
Schedulingverfahren, 252, 282, 290, 300,
306, 316, 319, 334, 337

FCFS, 290, 300, 319

319

LFU, 337
LRU, 337
Multi-Level-Scheduling-, 319
nicht-preemptive, 252
preemptive, 252
Preemptive SJF, 319
Preemptive-Shortest-Job-First, 319
priority scheduling, 290
Reaktionszeit, 252
Round-Robin, 252, 282, 290, 300,

319, 334
RR, 282, 319, 334
Shortest-Job-First, 252, 319
SJF, 252, 319

Schlüssel, 341, 357, 359, 365, 375, 382,
386, 394, 423, 435, 440, 445

künstlicher, 383

Schlüsselkandidat, 343, 357, 375, 379,
382, 394, 398, 407, 410, 424,
435

Schleifeninvariante, 115, 149, 162, 176,

198

second-chance, 271, 298, 300
Segment, 254
segmentation fault, 311
Segmentierung, 241, 292, 293

dynamische, 292
Segmentierungsverfahren

Best Fit, 232, 292, 322
First Fit, 232, 292, 322
Worst Fit, 292, 322

Segmenttabelle, 241
Seite, 254, 307
Seiten-Kachel-Tabelle, 233, 307, 311,

323

Seitenadressierung, 232, 233, 257, 293,
307, 311, 323, 327

logische, 241, 293, 306, 311, 323,

327

physi(kali)sche, 233, 241, 293, 307,

311, 323, 327

Seitendeskriptor, 311
Seitenersetzungsstrategien, 236, 254,

266, 298, 337
Belady’s optimale, 266


------------------------------------------------------------------------
476

Index

Seitenersetzungsstrategien (Fortsetzung)
Clock-Algorithmus, 271, 298, 300
FCFS, 282
FIFO, 236, 266
ﬁrst in ﬁrst out, 236, 266
First-come, First-served, 282
last in ﬁrst out, 254
least frequently used, 254, 337
least recently used, 236, 254, 266,

271, 298, 300, 337

LFU, 254
LIFO, 254
LRU, 236, 254, 266, 271, 298, 300,

337

OPT, 266
second-chance, 271, 298, 300
Shortest-Job-First, 282
SJF, 282

Seitenfehler, 236, 266
Seitenﬂattern, 257, 298, 300, 337
Seitengröße, 232
Seitenrahmen, 311, 323
Seitentabelle, 232
Semaphor, 229, 231, 242, 245, 249,
256, 261, 268, 276, 287, 293,
309, 321
binärer, 242
boolescher, 242, 256, 261
Zähl-, 242, 261, 268, 276, 287,

293, 309

semi-entscheidbar, 10, 35, 87, 103
Sequenzdiagramm, 213, 221, 224
shortest seek time ﬁrst, 232
Shortest-Job-First, 252, 282, 319
sicherer Zustand, 264, 270, 302, 325
SJF, 252, 282, 319
Sondierungsfunktion, 174
Sortieralgorithmus, 151, 196
Heapsort, 151, 203
Mergesort, 196
Quicksort, 151, 185
Sortieren durch Einfügen, 165

Sortieren durch Einfügen, 165
Spannbaum, 200
Speicherverwaltung, 232, 241, 257, 284,

292, 293, 297, 311, 322, 323

Spezialisierung, 396, 417, 428

Sprache, 17, 21, 31, 45, 54, 55, 59, 67,
68, 71, 72, 79, 80, 88, 93–96,
99, 105, 107, 109, 113, 133

entscheidbare, 9, 13, 87, 103
kontextfreie, 9, 13, 17, 21, 57, 62,

65, 95, 96, 107, 113

kontextsensitive, 9, 17, 19, 21, 96,

103

reguläre, 6, 9, 13, 17, 21, 34, 42,
43, 52, 57, 62, 65, 67, 68, 79,
80, 89, 93, 94, 96, 102, 105,
109

SQL, 341, 348, 349, 352, 355, 364,
365, 368, 373, 376, 380, 385,
386, 390, 400, 402, 403, 408,
414, 421, 432, 435, 442, 445,
447, 460, 467

SSF, 232
Stack

pop, 129
push, 129
top, 129

stack, 129
Stackoperationen, 129
Superschlüssel, 382
swapping, 240, 254
Symbolic-Link, 314, 329
Synchronisation, 231
Syntaxbaum, 3, 85
Synthesealgorithmus, 362, 367, 388,

448, 465

Systementwurf, 215

Tautologie, 12, 26, 36
Termination, 132, 153, 160, 162, 198
Terminierung eines Prozesses, 264
Terminierungsfunktion, 136
Thrashing, 257, 298, 300
Thread, 229, 245, 249, 258, 304, 317,

327, 328
Kernel-Level-, 318
User-Level-, 317
Thread in Java, 258
Tiefendurchlauf, 184
total korrekt, 132
Transaktion, 257, 379, 381, 395, 419,

424, 438, 454


------------------------------------------------------------------------
Index

477

Transaktion (Fortsetzung)

Lost-Update-Problem, 395, 438
Turingmaschine, 9, 10, 12, 16, 24, 40,
44, 46, 60, 74, 99, 102, 103,
107, 143

deterministische, 6, 9, 16, 44, 102,

107

Einband-, 60, 143
Mehrband-, 107, 143

überabzählbar, 39
überführungsfunktion, 83
übergangsdiagramm, 52
Unentscheidbarkeit, 99, 143
unerfüllbar, 12, 26, 36, 37
Unerfüllbarkeitstest, 12, 26, 36
UNIX-Dateisystem, 237, 303, 314, 329
Unterbrechungsvermeidung, 242
Unterklasse, 375
User-Level-Thread, 317

Vererbung, 209, 221
Verfeinerung, 352, 410, 440
Veriﬁkation, 162, 176
Verklemmung, 230, 233, 244, 245, 249,
256, 262, 270, 286, 295, 296,
302, 325, 328, 339

Verweilzeit, 334
vollständige Induktion, 19, 23, 34, 45,

57, 124, 134, 136, 171

Vorbedingung, 132, 162, 198

Wartezeit, 334
wechselseitiger Ausschluss, 242, 245,

258, 286
Worst Fit, 284, 292, 322

Zahldarstellung, 37, 89
Zusicherung, 162
Zustandsautomat, 61, 172
Zustandsdiagramm, 220, 229, 290
Zuteilung eines Betriebsmittels, 262,

264, 339


------------------------------------------------------------------------
