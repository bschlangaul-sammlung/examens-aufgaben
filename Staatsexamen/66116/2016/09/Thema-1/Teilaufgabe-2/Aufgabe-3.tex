\documentclass{lehramt-informatik-aufgabe}
\liLadePakete{syntax,kontrollflussgraph}
\begin{document}
\let\c=\liKontrollCode
\let\bWahr=\liBedingungWahr
\let\bFalsch=\liBedingungFalsch

\liAufgabenTitel{Sort-Methode und datenflussorientierte Überdeckungskritierien}
\section{Aufgabe 4: Datenflussorientiertes Testen
\index{Datenflussorientiertes Testen}
\footcite{sosy:ab:7}}

Gegeben Sei folgende Java-Methode \liJavaCode{sort} zum Sortieren eines Feldes
ganzer Zahlen:
\footcite[Thema 1 Teilaufgabe 2 Aufgabe 3]{examen:66116:2016:09}

\liJavaDatei[firstline=4]{aufgaben/sosy/ab_7/Aufgabe4}

\begin{enumerate}

%%
% (a)
%%

\item Konstruieren Sie den
Kontrollflussgraphen\index{Datenfluss-annotierter Kontrollflussgraph}
des obigen Code-Fragments und annotieren Sie an den Knoten und Kanten
die zugehörigen Datenflussinformationen (Definitionen bzw. berechnende
oder prädikative Verwendung von Variablen).

\begin{liAntwort}
\begin{liKontrollflussgraph}[xscale=1.5,yscale=-1.2]
\node[
  pin={\c{boolean swapped; int swapTmp; int[] = (int[]) array.clone()}}
] at (0,1) (1) {1};

\node[
  pin={\c{do; swapped = false; int index = 0;}}
] at (0,2) (2) {2};

\node[
  pin={\c{for}}
] at (1,3) (3) {3};

\node[
  pin={\c{if (newArray[index] > newArray[index + 1])}}
] at (2,4) (4) {4};

\node[
  pin={\c{swapTmp = newArray[]; ... swapped = true;)}}
] at (2,5) (5) {5};

\node[
  pin={\c{i++}}
] at (1,6) (6) {6};

\node[
  pin={\c{while (swapped))}}
] at (0,7) (7) {7};

\node[
  pin={\c{return newArray;)}}
] at (0,8) (8) {8};

\path (1) -- (2);
\path (2) -- (3);
\path[wahr] (3) -- node[draw=none,name=34]{} (4);
\path[falsch] (3) -- node[draw=none,name=37]{} (7);
\path[wahr] (4) -- node[draw=none,name=45]{} (5);
\path[falsch] (4) -- node[draw=none,name=46]{} (6);
\path (5) -- (6);
\path (6) -- (3);
\path (6) -- (7);
\path[wahr] (7) -- node[draw=none,name=72]{} (2);
\path[falsch] (7) -- node[draw=none,name=78]{} (8);

\node[usebox] at (0,0) {def(array, newArray) c-use(array)} edge[dashed] (1);
\node[usebox] at (-3,1) {def(swapped, index) c-use(array)} edge[dashed] (2);
\node[usebox] at (2,7) {def(swapTmp, newArray, swapped) \\c-use(newArray, swapTmp, index)} edge[dashed] (5);
\node[usebox] at (0,9) {c-use(newArray)} edge[dashed] (8);

\node[usebox] at (-3,4) {p-use(newArray)} edge[dashed] (72) edge[dashed] (78);
\node[usebox] at (3,4.5) {p-use(newArray)} edge[dashed] (45) edge[dashed] (46);
\node[usebox] at (3,4.5) {p-use(index)} edge[dashed] (34) edge[dashed] (37);

\end{liKontrollflussgraph}
\end{liAntwort}

%%
% (b)
%%

\item Nennen Sie die maximale Anzahl linear unabhängiger Programmpfade,
also die zyklomatische Komplexität nach McCabe.\index{Zyklomatische
Komplexität nach Mc-Cabe}

%%
% (c)
%%

\item Geben Sie einen möglichst kleinen Testdatensatz an, der eine
100\%-ige Verzweigungsüberdeckung dieses Moduls erzielt.\index{C1-Test
Zweigüberdeckung (Branch Coverage)}

%%
% (d)
%%

\item Beschreiben Sie kurz, welche Eigenschaften eine Testfallmenge
allgemein haben muss, damit das datenflussorientierte
Überdeckungskriterium „all-uses“\index{all uses} erfüllt.

\end{enumerate}
\end{document}
