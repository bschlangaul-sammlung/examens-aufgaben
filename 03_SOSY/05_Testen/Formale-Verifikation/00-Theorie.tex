\documentclass{lehramt-informatik-haupt}
\liLadePakete{syntax,mathe,wpkalkuel}
\usepackage{array}
\usepackage{multicol}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Theorie-Teil
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Formale Verifikation}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Programmverifikation, Korrektheit\footcite[Seite 14]{sosy:fs:5}}

Verifikation dient dazu, die Korrektheit eines Programms
\memph{mathematisch} zu beweisen.

Ein Algorithmus ist dabei

\begin{itemize}

\item \memph{partiell korrekt}, wenn er bei gültiger Eingabe
(Vorbedingung) immer ein gültiges Ergebnis (Nachbedingung) liefert.

\item \memph{total korrekt}, wenn er partiell korrekt ist und terminiert.
\end{itemize}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{\text{wp}-Kalkül zur Verfikation\footcite[Seite 15]{sosy:fs:5}}

Der \text{wp}-Kalkül ist ein Kalkül in der Informatik zur Verifikation
eines imperativen Programmcodes. Die Abkürzung \text{wp} steht für
\memph{weakest precondition}, auf deutsch schwächste Vorbedingung. Bei
der Verifikation geht es nicht darum, die Funktion mit einer bestimmten
Menge an Eingabedaten auf korrekte Ergebnisse zu testen, sondern darum,
eine \memph{allgemeingültige Aussage über das korrekte Ablaufen} des
Programms zu erhalten.

Die Überprüfung der Korrektheit geschieht durch \memph{Rückwärtsanalyse}
des Programmcodes. Ausgehend von der Nachbedingung wird geprüft, ob
diese durch die Vorbedingung und den Programmcode garantiert wird.

Alternativ kann auch der \memph{Hoare-Kalkül} benutzt werden, bei dem im
Gegensatz zum \text{wp}-Kalkül eine \memph{Vorwärtsanalyse} stattfindet.

Der \text{wp}-Kalkül hilft gewisse Zusicherungen im Programm zu machen.
Eine Zusicherung ist eine prädikatenlogische Aussage über den Inhalt der
Variablen an der bestimmten Stelle. Eine Zusicherung vor einem
Programmtext heißt \memph{Vorbedingung P}, eine Zusicherung danach
\memph{Nachbedingung Q}.\footcite{wiki:wp-kalkuel}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Beispiel}

$\wp{x += 5; y *= 2; z = z \% 4; y--;}{x + y = 17}$

$\wp{x += 5; y *= 2; z = z \% 4;}{x + y - 1 = 17}$

$\wp{x += 5; y *= 2; z = z \% 4;}{x + y = 18}$

$\wp{x += 5; y *= 2;}{x + y = 18}$

$\wp{x += 5;}{x + y \cdot 2 = 18}$

$x + 5 + y \cdot 2 = 18$

$x + y \cdot 2 = 13$\footcite[Seite 21-26]{sosy:fs:5}

\section{Verzweigung}

$\text{\text{wp}}(\text{„}\texttt{IF B THEN <}A_1\texttt{> ELSE <}A_2\texttt{>}\text{“}, Q)
\equiv
(B \land \text{\text{wp}}(\texttt{<}A_1\texttt{>}, Q))
\lor
(\neg B \land \text{\text{wp}}(\texttt{<}A_2\texttt{>}, Q))$

\section{Transformationen}

\begin{enumerate}
\item $\wp{}{Q} = Q$
Nichts passiert, die Vorbedingung bleibt gleich

\item $\wp{Fehler}{Q} = \text{falsch}$
Fehler dürfen nicht auftreten

\item $\wp{A}{Q} \land \wp{A}{R} = \wp{A}{Q \land R}$
Distributivität der Konjunktion

\item $\text{\text{wp}}(A, Q) \lor \text{\text{wp}}(A, R) = \text{\text{wp}}(A, Q \lor R)$
Distributivität der Disjunktion
\end{enumerate}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Schleifen}

Die Behandlung von Schleifen ist etwas schwieriger als die von anderen
Konstrukten, da die Variablen innerhalb jedes einzelnen
Schleifendurchgangs verändert werden. Daher ist es nicht einfach möglich
eine starre Ersetzung vorzunehmen. Anstattdessen verwendet man eine Art
Vollständige Induktion um die Funktion der Schleife nachzuweisen.

Um die schwächste Vorbedingung eines Ausdrucks der Form „\java{while b
{ A }}“ zu finden verwendet man eine \memph{Schleifeninvariante}. Sie
ist ein Prädikat für das

\begin{displaymath}
\{ I \wedge b \} A \{ I \}
\end{displaymath}

\noindent
gilt. Die Schleifeninvariante gilt also sowohl vor, während und nach der
Schleife. Das Schema einer Schleife sieht dann wie folgt aus:

\begin{minted}{java}
// { I } - Invariante gilt vor der Schleife
while (b) {
  // { I && b} - Invariante gilt vor dem Schleifenkörper
  A;
  // { I } - Invariante gilt nach dem Schleifenkörper
}
// { I ∧ (¬b) }
\end{minted}

Nun gilt es nur noch folgende Schritte zu beweisen:

\begin{enumerate}
\item Die Invariante gilt vor Schleifeneintritt

\item $\{ I \wedge b \} A \{ I \}$, dass also $I$ wirklich eine
Invariante ist

\item $(I \wedge \neg b) \Rightarrow Q$, dass also bei der Terminierung
auch die Nachbedingung aus der Invariante folgt. Dass die Schleife
terminiert (mittels Schleifenvariante/Terminierungsfunktion)
\end{enumerate}

\subsection{Beispiel}

Dazu ein Beispiel, das die Fakultät einer Variable $x$ ausrechnet und in
der Variable $fak$ ausgibt

\begin{minted}{java}
int berechneFakultaet(int x) {
  int i = 1;
  int fak = 1;
  // I: fak = i!
  while (i < x) {
    // I: fak = i! && i < x
    i = i + 1;
    fak = fak * i;
    // I: fak = i!
  }
  // I: fak = i! && i >= x
  return x;
}
\end{minted}

\noindent
Die Schleifeninvariante ist hier $(\text{fak} = i!)$. Der Ausdruck $(x -
i)$ fällt streng monoton während der Schleifenausführung gegen $0$ und
ist die Abbruchbedingung.

\subsubsection{Am Beispiel von $x = 3$}

\begin{multicols}{2}
\liPseudoUeberschrift{1. Durchgang}

\begin{minted}{java}
int i = 1;
int fak = 1;
// I: fak = i! -> 1 = 1
while (i < x) {
  // I: fak = i! && i < x -> 1 = 1 && 1 < 3
  i = i + 1;
  // i = 2
  fak = fak * i;
  // I: fak = i! -> 2 = 2
}
\end{minted}

\liPseudoUeberschrift{2. Durchgang}

\begin{minted}{java}
while (i < x) {
  // I: fak = i! && i < x -> 2 = 2 && 2 < 3
  i = i + 1;
  // i = 3
  fak = fak * i;
  // I: fak = i! -> 6 = 3! -> 6 = 3
}
// I: fak = i! && i >= x -> 6 = 6 && 3 >= 3
\end{minted}

\end{multicols}

\literatur

\end{document}
