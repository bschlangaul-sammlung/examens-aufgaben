\documentclass{lehramt-informatik-haupt}
\usepackage{multicol}
\liLadePakete{syntax,mathe,kontrollflussgraph}

\usepackage{array}
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Theorie-Teil
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Testen}

\begin{liQuellen}
\item \cite[Kapitel 4 „Software-Text“; Seite 157-246]{hoffmann:software}
\end{liQuellen}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Black-Box-Test\footcite[Seite 32]{sosy:fs:5}}

Die Grundlage für das Black-Box Testverfahren sind \memph{Anforderungen
und Spezifikationen}, für die der innere Aufbau der Komponenten oder des
Systems (also die konkrete Umsetzung und Implementierung) zum Zeitpunkt
des Tests \memph{nicht bekannt} sein muss. Die Testobjekte werden daher
\memph{unabhängig von ihrer Realisierung getestet}. Aufgrund der
Betrachtung des zu testenden Objekts als Black-Box werden die Testfälle
von \memph{Daten getrieben} (\memph{Data-Driven}) und beziehen sich auf
Anforderungen und das spezifizierte Verhalten der Testobjekte. Das
Testobjekt wird mit definierten Eingangsparametern aufgerufen. Die
Ergebnisse - nach Abarbeitung durch das Testobjekt - werden mit den
erwarteten Ergebnissen verglichen. Stimmen die tatsächlichen Ergebnisse
nicht mit den erwarteten Ergebnissen überein, liegt ein Fehler vor. Ziel
ist es dabei, eine \memph{möglichst hohe Anforderungsüberdeckung} zu
erreichen, also möglichst alle Anforderungen zu testen. Um die Anzahl
der Tests bei gleichbleibender Testintensität zu reduzieren, bedient man
sich Techniken, wie \memph{Äquivalenzklassenzerlegung} und
\memph{Grenzwertanalyse}. Dabei versucht man, die Menge an Eingabe- und
Ausgabedaten zu beschränken, um mit minimalem Aufwand möglichst alle
Testfälle abzudecken.\footcite[Seite 140-141]{schatten}

%%
%
%%

\subsection{Äquivalenzklassenzerlegung\footcite[Seite 250]{schneider}}

Das \memph{vollständige Testen} einer Komponente oder eines
Software-Systems ist in der Regel aufgrund der Vielzahl an
unterschiedenen Werten, die sowohl Eingangsparameter als auch
Ausgangsparameter annehmen können, kaum realisierbar und auch meist
nicht sinnvoll. Um die Anzahl der Testdaten auf ein vernünftiges Minimum
zu reduzieren, bedient man sich der Äquivalenzklassenzerlegung. Die
Äquivalenzklassenzerlegung hilft dabei, \emph{Bereiche von
Eingabewerten} zu identifizieren, die jeweils \memph{dieselben
Ergebnisse} liefern. Aus diesen Klassen von Eingabewerte wählt man
jeweils einen \memph{Vertreter (Repräsentanten)} aus, der dann für den
konkreten Testfall verwendet wird.

Komplizierter wird die Äquivalenzklassenzerlegung, falls Bedingungen mit
mehreren Parametern zu testen sind, da sämtliche Kombinationen von
Parameterklassen getestet werden müssen. Allerdings gilt auch hier
wieder, dass \memph{pro Äquivalenzklassenkombination nur ein
Repräsentant} ausgewählt werden muss und die Anzahl der Testfälle auf
diese Weise beschränkt werden kann.\footcite[Seite 142]{schatten}

%%
%
%%

\subsection{Grenzwertanalyse\footcite[Seite 251]{schneider}}

Einen besonderen Stellenwert nehmen \memph{Bereichsgrenzen von
Äquivalenzklassen} ein, da diese häufige Ursachen für Fehler sind, die
beispielsweise durch \memph{Tippfehler} verursacht werden. Statt eines
„\texttt{<=}“ wird ein „\texttt{<}“ geschrieben, was speziell an den
Systemgrenzen zu einem Fehlverhalten des Systems führt. Diese
Fehlerquelle kann beispielsweise mit der Grenzwertanalyse erkannt
werden. Die Kernidee bei der Grenzwertanalyse ist, (a)
\memph{Grenzbereiche zu identifizieren} und (b) \memph{Testdaten aus dem
nahen Umfeld} dieser Bereichsgrenzen auszuwählen. Dabei empfiehlt es
sich, jeweils einen Wert aus dem Grenzbereich der einen und der anderen
Klasse auszuwählen. Optional kann natürlich auch der exakte Grenzwert in
einem Testfall spezifiziert werden, der aber - bei genauer Analyse -
ohnehin einer der beiden Klassen zugeordnet werden kann.
\footcite[Seite 142]{schatten}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{White-Box-Testtechniken\footcite[Seite 199-246]{hoffmann:software}}

\begin{liQuellen}
\item \cite{wiki:white-box-test}
\item \cite[Seite 199-246]{hoffmann:software}
\end{liQuellen}

Quellcode ist bekannt und wird zum Testen benutzt\footcite[Seite
32]{sosy:fs:5}

%%
%
%%

\subsection{Kontrollflussorientiertes Testen\footcite[Seite 34]{sosy:fs:5}}

\begin{liQuellen}
\item \cite{wiki:kontrollfluss-test}
\item \cite[Kapitel 8.6.3 „Methoden zur Testfallermittlung“, Seite 251-252]{schneider}
\end{liQuellen}

Dynamische White-Box-Tests, die sich am Kontrollflussgraphen des
Programms orientieren.

\begin{itemize}
\item Anweisungsüberdeckungstest
\item Zweigüberdeckungstest
\item Pfadüberdeckungstest
\item Bedingungsüberdeckungstest
\end{itemize}

%%
%
%%

\subsection{Kontrollflussgraph}

Ein Kontrollflussgraph (englisch: \memph{control-flow graph} (CFG))
bezeichnet einen \memph{gerichteten Graphen} der dazu dient, den
Kontrollfluss eines Computerprogramms zu beschreiben. Sie werden unter
anderem zur Programmoptimierung
eingesetzt.\footcite{wiki:kontrollflussgraph}

Jeder Graph enthält genau \memph{einen Startknoten} und \memph{einen
Endknoten}. \memph{Verschiedenen Aussprungspunkte} (z. B. mehrere
return-Anweisungen) werden in einem neuen, \memph{zusätzlich
eingeführten Knoten} zusammengeführt.\footcite[Seite
203]{hoffmann:software}

Der \memph{kantenmarkierter} Kontrollﬂussgraphen ist ein Graph, indem
die \memph{Anweisungen den Knoten} und die
\memph{Verzweigungsbedingungen den Kanten} zugeordnet werden. Die
meisten White-Box-Tests basieren auf dieser Art der
Kontrollﬂussmodellierung.\footcite[Seite 203]{hoffmann:software}

\memph{Expandierte Kontrollﬂussgraphen} enthalten für jeden Befehl einen
separaten Knoten.\footcite[Seite 204]{hoffmann:software}

\memph{Kollabierte Kontrollﬂussgraphen} zeichnen sich dadurch aus, dass
verzweigungsfreie Befehlsblöcke vollständig in einem einzigen Knoten
zusammengefasst werden.\footcite[Seite 204]{hoffmann:software}

Der Kontrollflussgraph wird in manchen Aufgaben auch
\memph{Ablaufdiagramm} genannt. Gestrichelte Kanten können
eingezeichnet werden, um einen \liJavaCode{false}-Zweig von einem
\liJavaCode{true}-Zweig besser unterscheiden zu können. Oftmals sind die
Knoten mit dem Präfix „n“ (für node) benannt. \emph{S} steht für
Start-Knoten und \emph{E} steht für End-Knoten.

\subsubsection{Kontrollflussgraphen der elementaren Verzweigungs- und
Schleifenkonstrukte\footcite[Seite 205]{hoffmann:software}}

\begin{itemize}
\item \liJavaCode{if (B) X;}

\item \liJavaCode{if (B) X; else Y;}

\item \liJavaCode{while (B) X;}

\item \liJavaCode{do X; while (B);}
\end{itemize}

\begin{multicols}{2}
\liJavaDatei[firstline=4,lastline=16]{testen/Beispiel}

\begin{tikzpicture}[li kontrollfluss,xscale=0.7,yscale=-0.8]
\node[knoten] at (0,0) (S) {S};
\node[knoten] at (0,1) (1) {1};
\node[knoten] at (0,2) (2) {2};
\node[knoten] at (1,3) (3) {3};
\node[knoten] at (1,4) (4) {4};
\node[knoten] at (0,5) (5) {5};
\node[knoten] at (1,6) (6) {6};
\node[knoten] at (0,7) (E) {E};

\draw[->] (S) -- (1);
\draw[->] (1) -- (2);
\draw[->] (2) -- (3) \bedingung{above right}{y > x};
\draw[->] (2) -- (5) \bedingung{left}{y <= x};
\draw[->] (3) -- (4);
\draw[->] (4) -- (5);
\draw[->] (5) -- (6) \bedingung{above right}{2 * max < 3 * min};
\draw[->] (5) -- (E) \bedingung{left}{2 * max >= 3 * min};
\draw[->] (6) -- (E);
\end{tikzpicture}
\end{multicols}

%%
%
%%

\subsubsection{$C_0$-Test: Anweisungsüberdeckung (Statement Coverage)\footcite[Seite 36]{sosy:fs:5}}

Anweisungsüberdeckungstests, auch $C_0$-Test genannt, testen \memph{jede
Anweisung mindestens ein Mal}. Wurde jede Anweisung in einem Programm
mindestens einmal ausgeführt, spricht man von \memph{vollständiger
Anweisungsüberdeckung}. Wurde vollständige Anweisungsüberdeckung
erreicht, dann steht fest, dass \memph{kein toter Code} (Anweisungen,
die niemals durchlaufen werden) im Programm existiert.
\footcite{wiki:kontrollfluss-test}

\texttt{(S, 1, 2, 3, 4, 5, 6, E)}
bzw.
\texttt{x=4, y=5}

%%
%
%%

\subsubsection{$C_1$-Test: Zweigüberdeckung (Branch Coverage)\footcite[Seite 37]{sosy:fs:5}}

Die Zweigüberdeckung fordert, dass jede \memph{Kante} des
Kontrollflussgraphen von mindestens einem Testfall durchlaufen werden
muss. Um das Kriterium zu erfüllen, müssen die Testfälle so gewählt
werden, dass jede Verzweigungsbedingung mindestens \memph{einmal wahr}
und mindestens \memph{einmal falsch} wird. Da hierdurch alle Knoten
ebenfalls mindestens einmal besucht werden müssen, ist die
\memph{Anweisungsüberdeckung} in der Zweigüberdeckung \memph{vollständig
enthalten}.\footcite[Seite 209]{hoffmann:software}

Der Zweigüberdeckungstest wird auch Entscheidungsüberdeckungstest
genannt, da die Hilfsvariable mindestens einmal mit dem Wert true und
false durchlaufen werden muss. In diesem Fall muss die While-Schleife
mindestens zweimal durchlaufen werden.\footcite{wiki:kontrollfluss-test}

\liPseudoUeberschrift{vollständige Zweigüberdeckung}

\texttt{\{(S, 1, 2, 3, 4, 5, 6, E), (S, 1, 2, 5, E)\}}
bzw.
\texttt{\{x=4, y=5; x=3, y=2\}}

%%
%
%%

\paragraph{Zyklomatische Komplexität\footcite[Seite 38]{sosy:fs:5}}

\begin{itemize}
\item gibt an, wie viele Testfälle höchstens nötig sind, um eine
Zweigüberdeckung zu erreichen

\item i.A. Metrik für “Testbarkeit/Komplexität”
\end{itemize}

\noindent
Berechnung durch Anzahl Binärverzweigungen $b$ ($p$ Anzahl der
Zusammenhangskomponenten des Kontrollflussgraphen)

\begin{displaymath}
M = b + p
\end{displaymath}

$\rightarrow M = 2 + 1 = 3$

\noindent
oder durch Anzahl Kanten $e$ und Knoten $n$

\begin{displaymath}
M = e - n + 2p
\end{displaymath}

$\rightarrow M = 9 - 8 + 2 \cdot 1 = 3$\footcite[Kapitel 4.4.6
McCabe-Überdeckung, Seite 216-220]{hoffmann:software}

%%
%
%%

\subsubsection{$C_2$-Test: Pfadüberdeckung (Path Coverage)\footcite[Seite 39]{sosy:fs:5}}

Die Pfadüberdeckung ist die mit Abstand mächtigste
White-Box-Prüftechnik, besitzt aufgrund ihrer immensen Komplexität
aber nur eine äußerst geringe Praxisbedeutung.

%%
%
%%

\paragraph{C2a Vollständige Pfadüberdeckung (Full Path Coverage):}

Das Kriterium der vollständigen Pfadüberdeckung wird erst dann erfüllt,
wenn für jeden möglichen Pfad, der den Eingangsknoten des
Kontrollflussgraphen mit dem Ausgangsknoten verbindet, ein separater
Testfall existiert.\footcite[Seite 210]{hoffmann:software}

Um die Limitierungen der vollständigen Pfadüberdeckung zu überwinden,
wurden in der Vergangenheit mehrere Variationen vorgeschlagen, mit deren
Hilfe sich die kombinatorische Explosion zumindest teilweise eindämmen
lässt. Von Bedeutung sind in diesem Zusammenhang insbesondere die
\memph{Boundary-Interior-Pfadüberdeckung} und die \memph{strukturierte
Pfadüberdeckung}. Beide Variationen basieren auf der Beobachtung, dass
ein Großteil der Fehler innerhalb eines Schleifenkonstrukts bereits nach
wenigen Iterationsschritten zum Vorschein kommt. Mit anderen Worten:
Eine weitere Erhöhung der ausgeführten Schleifeniterationen kann die
erreichbare Fehlererkennungsrate nur noch marginal steigern. Beide der
hier vorgestellten Pfadüberdeckungsvarianten tragen diesem Phänomen
Rechnung und versuchen, die Anzahl der Schleifendurchläufe
dementsprechend einzugrenzen:

%%
%
%%

\paragraph{C2b Schleife-Inneres-Pfadüberdeckung (Boundary-Interior Path Coverage):}

\noindent
Der Boundary-Interior-Pfadtest konstruiert für jede Schleife des
Programms drei Gruppen von Testfällen, die alle erfolgreich abgearbeitet
werden müssen.

\begin{description}
\item[Äußere Pfade]
Die Testfälle durchlaufen das Programm auf Pfaden, die den
\memph{Schleifenkörper nicht betreten}. Für Schleifen fester Lauflänge
sowie für While-Schleifen, die erst am Ende des Schleifenkörpers die
Wiederholungsbedingung auswerten, ist diese Testfallgruppe leer.

\item[Grenzpfade (boundary paths, boundary test)] Die Testfälle
durchlaufen das Programm auf Pfaden, die den Schleifenkörper betreten,
jedoch zu \memph{keiner Wiederholung} führen. Innerhalb des
Schleifeninneren müssen \memph{alle möglichen Pfade getestet} werden.
Für Schleifen fester Lauflänge ist diese Testfallgruppe leer.

\item[Innere Pfade (interior test)] Die Testfälle durchlaufen das
Programm auf Pfaden, die den Schleifenkörper betreten und
\memph{mindestens eine weitere Iteration} ausführen. Die Testfälle
werden so gewählt, dass \memph{innerhalb der ersten beiden Ausführungen
alle möglichen Pfade abgearbeitet} werden.\footcite[Seite 212]{hoffmann:software}
\end{description}

%%
%
%%

\paragraph{C2c Strukturierte Pfadüberdeckung (Structured Path Coverage):}

\noindent
Anzahl der Schleifendurchläufe auf eine
Zahl $n$ reduziert

\liPseudoUeberschrift{vollständige Pfadüberdeckung}

\texttt{(S, 1, 2, 3, 4, 5, 6, E), (S, 1, 2, 5, E),
(S, 1, 2, 3, 4, 5, E), (S, 1, 2, 5, 6, E)}

%%
%
%%

\subsubsection{$C_3$-Test: Bedingungsüberdeckung (Condition Coverage)\footcite[Seite 40]{sosy:fs:5}}

Problem: zusammengesetzte, hierarchische Bedingungen nicht ausreichend
getestet

Einfachbedingungsüberdeckung:
Alle atomaren Prädikate müssen mindestens einmal beide Wahrheitswerte
annehmen.
(→ A = 0, B = 1; A = 1, B = 0)
Mehrfachbedingungsüberdeckung:
Alle Wahrheitskombinationen müssen getestet werden.
(→ A = 0, B = 1; A = 1, B = 0; A = 1, B = 1; A = 0, B = 0)
Minimaler Mehrfachbedingungsüberdeckung: („Zwischenlösung“)
Alle atomaren und zusammengesetzten Prädikate müssen einmal beide
Wahrheitswerte annehmen.

{
\footnotesize
\noindent
\begin{tabular}{llL{4cm}L{3cm}}
&
&
\textbf{erfüllte Bedingung} &
\textbf{Durchführbarkeit}
\\

\hline

%%
%
%%

\textbf{Anweisungsüberdeckungstest}
&
C0 &
jede Anweisung wird mindestens einmal ausgeführt &
relativ einfach \\

\hline

%%
%
%%

\textbf{Zweigüberdeckungstest} &
C1 &
jede Kante im Kontrollflussgraph (KFG) wird mindestens einmal durchlaufen &
realistische Mindestanforderung, vertretbarer Aufwand \\

\hline

%%
%
%%

\textbf{Pfadüberdeckungstest} &
C2 &
&
\\

Vollständig &
C2a &
Alle möglichen Pfade werden durchlaufen &
unmöglich bei Schleifen \\

Boundary-Interior &
C2b &
wie C2a, Schleifen werden jedoch nach speziellen Regeln durchlaufen &
aufwendig \\

Strukturiert &
C2c &
wie C2b, Schleifen werden jedoch genau n-mal durchlaufen &
aufwendig \\

\hline

%%
%
%%

\textbf{Bedingungsüberdeckungstest} &
C3 &
&
\\

Einfachbedingung &
C3a &
jede atomare Bedingung wird einmal mit true und false getestet &
\\

Mehrfachbedingung &
C3b &
jede true/false Kombination der atomaren Bedingungen wird getestet &
sehr hoher Aufwand \\

Minimale Mehrfachbedingung &
C3c &
jede atomare Bedingung und die Gesamtbedingung wird mit true und false getestet &
hoher Aufwand\\
\end{tabular}

Quelle: Wikipedia\footcite{wiki:kontrollfluss-test}
}

%%
%
%%

\subsection{Datenflussorientiertes Testen}

\begin{liQuellen}
\item \cite[Kapitel 8.6.3 „Methoden zur Testfallermittlung“, Seite 250-251]{schneider}
\item \cite[Kapitel 4.4.7 Def-Uses-Überdeckung, Seite 220-227]{hoffmannn}

\end{liQuellen}
Im Gegensatz zu allen bisher betrachteten Überdeckungskriterien, die
ausschließlich den Kontrollfluss eines Programms in Betracht ziehen,
leiten die Defs-Uses-Kriterien die auszuführenden Pfade aus dem
Datenfluss ab. Hierzu werden die \memph{Variablenzugriffe} des
untersuchten Programms analysiert und \memph{mit verschiedenen
Datenflussattributen versehen}. Die vergebenen Attribute teilen die
Variablenzugriffe in \memph{drei Klassen} ein:

Sie sind besonders geeignet für objektorientiert entwickelte Systeme.

\def\TmpBeispiel#1{(Beispiel: \liJavaCode{#1})}

\begin{description}
\item[Definitorische Nutzung (\texttt{def-use}):]

In diese Klasse fallen alle Zugriffe, die den aktuellen \memph{Wert
einer Variablen überschreiben}. Alle Variablenzugriffe auf der linken
Seite einer Zuweisung fallen in diese Kategorie. \TmpBeispiel{x = 42;}

\item[Referenzierende Nutzung (\texttt{r-use}):]

In diese Klasse fallen alle Zugriffe, die den Wert einer Variablen
\memph{verwenden, jedoch nicht verändern}. Zwischen einer Zuweisung und
einer nachfolgenden Referenz, die den zugewiesenen Wert verwendet,
besteht eine \texttt{du}-Interaktion. Referenzierende Nutzungen können
weiter in berechnende und prädikative Nutzungen unterteilt werden.

\begin{description}
\item[Berechnende Nutzung (\texttt{c-use}):]

In diese Klasse fallen alle Zugriffe, die den \memph{Wert einer
Variablen in einer Berechnung verwenden} (\memph{computational use},
kurz \texttt{c-use}). Zwischen einer Zuweisung und einer sich
anschließenden berechnenden Nutzung besteht eine
\texttt{dc}-Interaktion. \TmpBeispiel{x = x * 2;} (+ \texttt{def-use})
\footcite[Seite 220]{hoffmannn}

\item[Prädikative Nutzung (\texttt{p-use}):]

In diese Klasse fallen alle Zugriffe, die den Wert einer Variablen
\memph{prädikativ}, d. h. innerhalb eines \memph{booleschen Ausdrucks}
verwenden (\memph{predicative use}, kurz \texttt{p-use}). Zwischen einer
Zuweisung und einer sich anschließenden prädikativen Nutzung besteht
eine dp-Interaktion. \TmpBeispiel{if (x > 42)}
\footcite[Seite 221]{hoffmannn}
\end{description}
\end{description}
\footcite[Seite 42]{sosy:fs:5}

%%
%
%%

\subsubsection{Datenflussgraph}

\liJavaDatei[firstline=18,lastline=25]{testen/Beispiel}

\begin{description}
\item[def-use:] Knoten
\item[c-use:] Knoten
\item[p-use:] Kanten\footcite[Seite 43]{sosy:fs:5}
\end{description}

\begin{tikzpicture}[li kontrollfluss,xscale=0.7,yscale=-1.5]
\node[knoten] at (0,0) (S) {S};
\node[knoten] at (0,1) (1) {1};
\node[knoten] at (1,2) (2) {2};
\node[knoten] at (0,3) (E) {E};

\draw[->] (S) -- (1);
\draw[->] (1) edge node[name=e11]{} (2);
\draw[->] (1) edge node[name=e1E]{} (E);
\draw[->] (2) -- (E);

\node[usebox] at (3,0) {def(min), def(max)}
  edge[dotted] (S);

\node[usebox] at (3,0.75) {p-use(min), p-use(max)}
  edge[dotted] (e11.center)
  edge[dotted] (e1E.center);

\node[usebox] at (3,2) {def(tmp), c-use(max)\\def(max), c-use(min)\\def(min), c-use(tmp)}
  edge[dotted] (2);

\node[usebox] at (3,3) {c-use(min), c-use(max)}
  edge[dotted] (E);
\end{tikzpicture}

%%
%
%%

\subsubsection{Überdeckungskriterium}

Definitionsfreier Pfad: Wird $x$ im Knoten $0$ definiert, so ist der
Pfad 0, 1, 2, 3, 4, 5 definitionsfrei, wenn $x$ in keinem weiteren
Knoten 1, 2, 3, 4, 5 erneut definiert wird.

\bigskip\noindent
Testfälle durchlaufen für jede Definition einer Variable einen
definitionsfreien Pfad zu ...

\begin{description}

\item[all definitions:] mindestens einem p- oder c-use
→ S, 1, 2, E

\item[all c-uses:] allen erreichbaren c-uses
→ S, 1, 2, E und S, 1, E

\item[all p-uses:] allen erreichbaren p-uses
→ S, 1, 2, E und S, 1, E

\item[all uses:] zu allen erreichbaren p- und c-uses
→ S, 1, 2, E und S, 1, E

\item[all c-uses/some p-uses bzw. all p-uses/some c-uses:] falls zu
manchen Variablendefinitionen kein c- bzw. p-use vorhanden ist,
stattdessen mindestens einen p-use bzw. c-use testen.
\end{description}

\footcite[Seite 44]{sosy:fs:5}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Design by Contract\footcite{wiki:design-by-contract}}

Ziel des Design by contract ist das reibungslose Zusammenspiel einzelner
Programmmodule durch die Definition formaler Verträge zur Verwendung von
Schnittstellen, die über deren statische Definition hinausgehen.

Das reibungslose Zusammenspiel der Programmmodule wird durch einen
„Vertrag“ erreicht, der beispielsweise bei der Verwendung einer Methode
einzuhalten ist. Dieser besteht aus

\begin{description}
\item[Vorbedingungen] (englisch precondition), also den Zusicherungen,
die der Aufrufer einzuhalten hat

\item[Nachbedingungen] (englisch postcondition), also den Zusicherungen,
die der Aufgerufene einhalten wird, sowie den

\item[Invarianten] (englisch class invariants), über alle Instanzen
einer Klasse hinweg geltende Grundannahmen.
\end{description}

Der Vertrag kann sich auf die gesamte verfügbare Information beziehen,
also auf Variablen- und Parameter-Inhalte ebenso wie auf Objektzustände
des betroffenen Objekts oder anderer zugreifbarer Objekte. Sofern sich
der Aufrufende an Vorbedingungen und Invarianten hält, können keine
Fehler auftreten und die Methode liefert garantiert keine unerwarteten
Ergebnisse.

\literatur

\end{document}
