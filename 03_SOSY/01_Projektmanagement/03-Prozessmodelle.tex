\documentclass{lehramt-informatik-haupt}
\usepackage{tabularx}
\liLadePakete{wasserfall}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Theorie-Teil
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Prozessmodelle / Vorgehensmodelle}

\begin{quellen}
\item \cite[Seite 47-69]{schatten}
\end{quellen}

\noindent
Ein Prozessmodell ist ein für die Softwareentwicklung angepasstes
Vorgehensmodell bei der professionellen Anwendungsentwicklung. Es dient
dazu, die Softwareentwicklung übersichtlicher zu gestalten und in der
Komplexität beherrschbar zu machen.\footcite[Seite 25]{sosy:fs:1}

\section{Beispiele}

\begin{itemize}
\item Wasserfallmodell
\item V-Modell
\item Spiralmodell
\item Agile Entwicklung
\end{itemize}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Wasserfallmodell}

\begin{quellen}
\item \cite[Kapitel 3.2 „Wasserfallmodell“, Seite 48-49]{schatten}
\item \cite[Seite 26]{sosy:fs:1}
\item \cite[Kapitel 8.2.3 Plangetriebene Vorgehensmodelle, Seite 226-227]{schneider}
\item \cite{wiki:wasserfallmodell}
\end{quellen}

Das Wasserfallmodell ist der Klassiker unter den Vorgehensmodellen. Das
Modell wurde bereits in den 1970er Jahren veröffentlicht und wird heute
nur noch selten für bestimmte Anwendungsgebiete eingesetzt, bei denen
ein \memph{strikt sequenzieller Projektablauf} möglich ist. Namensgebend
ist, dass die sequenziellen Schritte des Lebenszyklusses eines
Software-Produkts in Form eines Wasserfalls dargestellt werden.

Alle Schritte werden sequenziell durchlaufen, wobei jeweils die
\memph{vorangegangene Phase vollständig abgeschlossen} und freigegeben
werden muss, \memph{bevor die nächste Phase gestartet} werden kann. Als
\emph{Abschluss jeder Phase} sind Verifikations- und
\memph{Validierungsschritte} vorgesehen, die quasi als Freigabe der
erstellten Produkte verwendet werden. Wird die geforderte Qualität an
der Stelle nicht erreicht, kann zur vorangegangenen Phase
\memph{„zurückgesprungen“} werden.
\footcite[Seite 48]{schatten}

Aufgrund der \emph{guten Planbarkeit} durch klar abgegrenzte Phasen wird
das Wasserfallmodell typischerweise bei stabilen und \memph{genau
beschriebenen Anforderungen} und Abläufen eingesetzt.

Nachteilig wirkt sich allerdings aus, dass dieses Modell \emph{nur wenig
Flexibilität} aufweist und somit nur schwer auf (späte) Änderungen im
Projekt reagieren kann. Als weitere Folge werden Fehler unter Umständen
erst sehr spät im Entwicklungsprozess oder erst beim Kunden erkannt. Das
hat zur Folge, dass teuere Nacharbeiten notwendig werden und das Projekt
in Zeitnot kommen kann.

Ein weiterer Nachteil des Wasserfallmodells ist, dass durch den
sequenziellen Ablauf eine \memph{finale Software-Lösung erst sehr spät
zur Verfügung} steht, der Kunde also erst gegen Ende des Projekts sieht,
was er tatsächlich bekommen wird und dann grundlegende Änderungen nicht
mehr leicht machbar sind.

In der Praxis der modernen Software-Entwicklung ist das Modell
gelegentlich noch anzutreffen, wird aber zunehmend \memph{von
flexibleren Prozessmodellen verdrängt.}

\begin{figure}
\begin{tikzpicture}[wasserfall]
\node {Systemanforderung}; % A-1
\node {Softwareanforderung};
\node {Analyse};
\node {Entwurf};
\node {Implementierung};
\node {Test};
\node {Betrieb};

%
\foreach \i [count=\j] in {2,...,7}
{
  \draw[->, thick] (A-\i) -| (A-\j);
  \draw[->, thick] (A-\j) -| (A-\i);
}
\end{tikzpicture}
\caption{Nach researchgate.net\footcite[Seite 26]{sosy:fs:1}}
\end{figure}

\begin{figure}
\begin{tikzpicture}[wasserfall]
\node {Anforderungen}; % A-1
\node {Entwurf};
\node {Implementation};
\node {Überprüfung};
\node {Wartung};

%
\foreach \i [count=\j] in {2,...,5}
{
  \draw[->, thick] (A-\i) -| (A-\j);
  \draw[->, thick] (A-\j) -| (A-\i);
}
\end{tikzpicture}
\caption{Nach Wikipedia \footcite{wiki:wasserfallmodell}}
\end{figure}

\subsection{Phasen\footcite{wiki:wasserfallmodell}}

\begin{enumerate}
\item Anforderungsanalyse und -spezifikation
(Requirement analysis and specification)
resultiert im Lastenheft

\item Systemdesign und -spezifikation
(System design and specification)
resultiert in der Softwarearchitektur

\item Programmierung und Modultests
(Coding and module testing)
resultiert in der eigentlichen Software

\item Integrations- und Systemtest
(Integration and system testing)

\item Auslieferung, Einsatz und Wartung
(Delivery, deployment and maintenance)
\end{enumerate}

\noindent
Eine andere Variante macht daraus sechs Schritte:

\begin{enumerate}
\item Planung
(mit Erstellung des Lastenhefts, Projektkalkulation und Projektplan)
(Systems Engineering)

\item Definition
(mit Erstellung des Pflichtenhefts, Produktmodell, GUI-Modell und evtl.
schon Benutzerhandbuch)
(Analysis)

\item Entwurf
(UML, Struktogramme)
(Design)

\item Implementierung
(Coding)

\item Testen
(Testing)

\item Einsatz und Wartung
(Maintenance)
\end{enumerate}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{V-Modell}

\begin{quellen}
\item \cite[Seite 49-52]{schatten}
\item \cite[Seite 27]{sosy:fs:1}
\item \cite[Kapitel 8.2.3 Plangetriebene Vorgehensmodelle, Seite 226-227]{schneider}
\item \cite{wiki:v-modell}
\end{quellen}

Das V-Modell organisiert \memph{ähnlich dem Wasserfallmodell} den
Softwareentwicklungsprozess in \memph{Phasen}. \memph{Zusätzlich} zu
diesen Entwicklungsphasen definiert das V-Modell auch das Vorgehen zur
\memph{Qualitätssicherung (Testen)}, indem den einzelnen
\memph{Entwicklungsphasen Testphasen gegenüber gestellt} werden. Auf der
linken Seite wird mit einer funktionalen/fachlichen Spezifikation
begonnen, die immer tiefer detailliert zu einer technischen
Spezifikation und Implementierungsgrundlage ausgebaut wird. In der
Spitze erfolgt die Implementierung, die anschließend auf der rechten
Seite gegen die entsprechenden Spezifikationen der linken Seite getestet
wird. So entsteht bildlich das namensgebende „V“, welches die einzelnen
Entwicklungsebenen ihren jeweiligen Testebenen gegenüberstellt.
\footcite{wiki:v-modell}

\subsection{Erweiterung des Wasserfall-Modells im Hinblick auf die beiden
Qualitätssicherungsaspekte}

\begin{description}
\item[Verifikation]

Überprüfung der Übereinstimmung zwischen einem Software-Produkt und der
Spezifikation

Frage: Are we doing things right?

\item[Validierung]

Überprüfung der Eignung eines Softwareprodukts bezogen auf seinen
Einsatzzweck

Frage: Are we doing right things?\footcite[Seite 27]{sosy:fs:1}
\end{description}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Inkrementelles Vorgehen\footcite[Seite 56]{schatten}}

Eine inkrementelle – also schrittweise – Vorgehensweise wird vor allem
bei großen und \memph{komplexen Systemen} eingesetzt, von denen rasch
erste verwendbare Teile ausgeliefert werden sollen. Ein Hauptziel ist
dabei, möglichst \memph{rasch} mit einer \memph{(Teil-)Lösung} auf den
Markt zu kommen und dann das Software-Produkt \memph{durch laufende
Ergänzungen auszubauen}.

Die Eckpunkte der Entwicklung sind: \memph{Analyse}, \memph{Design},
\memph{Implementierung}, \memph{Integration} und \memph{Auslieferung}.
Dabei werden \memph{alle Phasen für eine Version} (oder ein Release)
durchlaufen, bis diese Version abgeschlossen ist und ausgeliefert werden
kann. \memph{Parallel bzw. zeitlich versetzt} kann bereits mit der
Planung und Umsetzung der \memph{Folgeversion} begonnen werden.

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Spiralmodell}

\begin{quellen}
\item \cite[Seite 57-58]{schatten}
\item \cite[Seite 28]{sosy:fs:1}
\item \cite{wiki:spiralmodell}
\end{quellen}

Das Spiralmodell stellt eine \memph{konkrete Ausprägung der
inkrementellen Entwicklung} dar, in dem \memph{vier grundlegende
Schritte} solange zyklisch durchlaufen werden, bis das Produkt in einer
zufriedenstellenden Qualität vorliegt

\begin{enumerate}
\item Definition von Zielen und Alternativen.
\item Einschätzung des Risikos.
\item Entwicklung und Durchführung von Tests und Evaluierungen der
aktuellen Ergebnisse.
\item Feedback zur erstellten Lösung und Planung für die nächste
Iteration.\footcite[Seite 57]{schatten}
\end{enumerate}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Agile Vorgehensmodelle}

\begin{quellen}
\item \cite[Seite 62-65]{schatten}
\item \cite[Seite 29-31]{sosy:fs:1}
\item \cite[Kapitel 8.2.4 Agile Modelle, Seite 229-231]{schneider}
\end{quellen}

\memph{Kritikpunkte an traditionellen Vorgehensmodellen} sind unter
anderem mangelhafte Flexibilität (durch vorgegebene starre Strukturen),
mangelnde Einbeziehung des Kunden in den Entwicklungsprozess sowie ein
(scheinbar unnötig) hoher Dokumentationsaufwand. Agile
Software-Entwicklungsprozesse sollen diese Nachteile beheben und ein
\memph{höheres Maß an Flexibilität und Kundennähe} bei einem
\memph{Mindestmaß an Dokumentation} ermöglichen. Agile
Entwicklungsprozesse gehen auf das \memph{Agile Manifest}, das von 17
Software-Entwicklern im Jahr 2001 veröffentlicht wurde, zurück:

\begin{quote}
\itshape
„Individuals and interactions over processes and tools\\
Working software over comprehensive documentation\\
Customer collaboration over contract negotiation\\
Responding to change over following a plan.“
\end{quote}

%%
%
%%

\subsection{SCRUM}

SCRUM definiert ein agiles Software-Projekt aus der Sicht des
Projektmanagements und besteht aus einer Sammlung von Prozeduren, Rollen
und Methoden zur erfolgreichen Projektdurchführung. Das Prozessmodell
umfasst drei wesentliche Phasen:

\begin{description}
\item[Pregame] In einem \memph{Pregame} erfolgt die Festlegung der
wesentlichen Produkteigenschaften und der grundlegenden Architektur
sowie die Projektplanung. Alle Eigenschaften und gewünschten Features
werden \memph{gemeinsam mit dem Kunden} in einem Produkt-Backlog
gesammelt und priorisiert. In diesem \memph{Produkt-Backlog} werden auch
geänderte Anforderungen gesammelt.

\item[Sprint] Die eigentliche Entwicklungsarbeit wird in einem
\memph{Sprint} durchgeführt. Vor einem Sprint werden die
\memph{wichtigsten und machbaren Features} aus dem priorisierten
Produkt-Backlog ausgewählt und in das Sprint-Backlog übernommen. Wichtig
ist dabei, dass die Auswahl und Planung nur so viele Features umfasst,
wie das Team im nächsten Sprint auch tatsächlich umsetzen kann. Das
\memph{Sprint-Backlog} beinhaltet also einen \memph{machbaren Auszug aus
dem Produkt-Backlog}.

\item[Postgame] Die abschließende Phase – das \memph{Postgame} – umfasst
die \memph{Bereitstellung und Auslieferung neuer Funktionalität} in Form
von (neuen) Releases.\footcite[Seite 63]{schatten}
\end{description}

% https://natanael.arndt.xyz/notes/agile
% donut diagram
% http://www.texample.net/tikz/examples/circular-arrows-text/
\usetikzlibrary{decorations.text}
\newcommand{\arcarrow}[8]{
% inner radius, middle radius, outer radius, start angle,
% end angle, tip protusion angle, color, text, text-direction
  \pgfmathsetmacro{\rin}{#1}
  \pgfmathsetmacro{\rmid}{#2}
  \pgfmathsetmacro{\rout}{#3}
  \pgfmathsetmacro{\astart}{#4}
  \pgfmathsetmacro{\aend}{#5}
  \pgfmathsetmacro{\atip}{#6}
  \fill[fill=white,draw=black]   (\astart:\rin) arc (\astart:\aend:\rin)
       -- (\aend+\atip:\rmid) -- (\aend:\rout) arc (\aend:\astart:\rout)
       -- (\astart+\atip:\rmid) -- cycle;
  \ifthenelse{#8=1}{
    \path[decoration = {text along path, text = {#7}, text align = {align = center}, raise = -0.5ex}, decorate]
    (\astart+\atip:\rmid) arc (\astart+\atip:\aend+(\atip/2):\rmid);
  }{
    \path[decoration = {text along path, text = {#7}, text align = {align = center}, raise = -0.5ex}, decorate]
    (\aend+\atip:\rmid) arc (\aend+\atip:\astart+(\atip/2):\rmid);
  }
}

\begin{tikzpicture}
\arcarrow{2}{2.4}{2.8}{0}{40}{-5}{Test}{0}
\arcarrow{2}{2.4}{2.8}{45}{120}{-5}{Implementierung}{0}
\arcarrow{2}{2.4}{2.8}{125}{175}{-5}{Entwurf}{0}
\arcarrow{2}{2.4}{2.8}{180}{270}{-5}{Anforderungsanalyse}{1}
\arcarrow{2}{2.4}{2.8}{275}{355}{-5}{Planung anpassen}{1}
\end{tikzpicture}

\literatur

\end{document}
