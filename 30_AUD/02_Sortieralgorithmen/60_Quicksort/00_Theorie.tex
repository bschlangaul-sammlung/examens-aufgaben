\documentclass{lehramt-informatik-haupt}
\liLadePakete{syntax,quicksort}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Theorie-Teil
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{QuickSort: Sortieren durch Zerlegen}

\begin{liQuellen}
\item \cite[Seite 55]{aud:fs:tafeluebung-11}
\item \cite{wiki:quicksort}
\item \cite[Seite 135-139 (PDF 153-157)]{saake}
\end{liQuellen}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Funktionsweise}

Listen mit maximal \memph{einem} Element sind
\memph{trivialerweise sortiert}.
%
Falls die zu sortierende Liste mehr als ein Element beinhaltet wird ein
sogenanntes \memph{Pivot-Element} (vom Französischen \emph{pivot}
„\memph{Dreh-/Angelpunkt}“) ausgewählt.
%
Alle \memph{kleineren} Elemente werden \memph{vor} und alle
\memph{größeren} \memph{hinter} das Pivot-Element verschoben. Der
Algorithmus verfährt \memph{rekursiv} mit den beiden Teillisten.
%
Der Algorithmus arbeitet nach dem \memph{Teile-Und-Herrsche-Prinzip}.

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Eigenschaften}

\begin{itemize}
\item Laufzeitkomplexität:

\begin{itemize}
\item $\mathcal{O}(n \cdot log(n))$ (im Best-/Average-Case)
\item $\mathcal{O}(n^2)$ (im Worst-Case)
\end{itemize}

\item in „klassischer“ Variante \emph{instabil}
\item durch Rekursion wachsender Aufrufstapel
$\rightarrow$ out-of-place
\end{itemize}

\newpage

\section{Minimales Code-Beispiel zum Auswendiglernen}

% Zerlege
\liJavaDatei[firstline=28,lastline=48]{sortier/QuickMinimal}
% Sortiere rekursiv
\liJavaDatei[firstline=66,lastline=73]{sortier/QuickMinimal}

\section{Implementation nach Saake\footcite[Seite 138 (PDF 156)]{saake}}

\liJavaDatei[firstline=14,lastline=57]{sortier/QuickSaake}

\newpage

\section{Weitere Implementation}

\liJavaDatei[firstline=14,lastline=57]{sortier/QuickHorare}

Im Gegensatz zu der Implementation von Saake wird hier der Pivot-Wert
nicht an den oberen Rand und dann wieder zurück kopiert.

%\liJavaDatei[firstline=13,lastline=63]{sortier/QuickSortDoWhile}

\QSinitialize{8, 2, 1, 5, 9, 7, 3}
\loop
\QSpivotStep
\ifnum\value{pivotcount}>0
  \QSsortStep
\repeat

\literatur

\end{document}
