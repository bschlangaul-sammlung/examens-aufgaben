\documentclass{lehramt-informatik-haupt}
\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Theorie-Teil
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Sortieralgorithmen}

\begin{liQuellen}
\cite{wiki:sortierverfahren}
\end{liQuellen}

\section{Klassifizierung der Sortieralgorithmen}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\subsection{Interne vs. externe Verfahren\footcite[Seite 34]{aud:fs:tafeluebung-11}}

Bei \memph{internen Sortierverfahren} ist stets ein \memph{direkter
Zugriff} auf \memph{alle} zu sortierenden Elemente notwendig. Alle
Elemente müssen \emph{gleichzeitig} im Hauptspeicher liegen.

Bei \memph{externen Sortierverfahren} ist der Zugriff auf einen
\memph{Teil} der zu sortierenden Elemente beschränkt. Nur ein Teil der
Daten muss gleichzeitig im \emph{Hauptspeicher} liegen. Dieses Verfahren
eignet sich für Sortierung von \memph{Massendaten} auf \memph{externen
Speichermedien}.\footcite[Seite 124]{saake}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\subsection{Vergleichsbasierte vs. Nicht-Vergleichsbasierte Verfahren\footcite[Seite
35]{aud:fs:tafeluebung-11}}

Beim vergleichsbasierten Sortieren \memph{vergleicht} der Algorithmus
mehrfach jeweils \memph{zwei Elemente} miteinander. Die Elementen werden
aufgrund aufgrund ihrer \emph{relativen Position} vertauscht. Beispiele:
\verb|QuickSort|, \verb|MergeSort|

Beim nicht-vergleichsbasiertes Sortieren benötigt der Algorithmus
\memph{keinen direkten Vergleich} zwischen zwei Elementen, er
\memph{zählt} stattdessen die Werte oder betrachtet \memph{„einzelne
Stellen“} Beispiele: \verb|CountingSort|, \verb|RadixSort|

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\subsection{Stabil vs. Instabil\footcite[Seite 36]{aud:fs:tafeluebung-11}}

\begin{itemize}
\item stabiles Sortierverfahren:\\
%
$\rightarrow$ Sortierverfahren, welches die Eingabereihenfolge von
Elementen mit \emph{gleichem Wert} beim Sortieren \emph{bewahrt}

Insbesondere dann wichtig, wenn hintereinander nach \emph{mehreren
Kriterien} sortiert wird.
\end{itemize}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\subsection{In-Place vs. Out-Of-Place}

\begin{itemize}

%%
%
%%

\item in-place (in situ)

\begin{itemize}
\item Speicherverbrauch unabhängig von Eingabegröße\\
%
$\rightarrow$ braucht nur eine konstante Menge an zusätzlichem
Speicher\\
%
$\rightarrow$ überschreibt im Allgemeinen die Eingabe- mit den
Ausgabedaten
\end{itemize}

%%
%
%%

\item out-of-place (ex situ)

\begin{itemize}
\item Speicherverbrauch abhängig von Eingabegröße\\
%
$\rightarrow$ Speicherverbrauch steigt mit Anzahl der zu sortierenden
Elemente
\end{itemize}

\end{itemize}

\noindent
\textbf{Achtung:} Aufrufstapel  \emph{Rekursive Algorithmen}, deren
Aufruftiefe von der Eingabegröße abhängt, arbeiten genaugenommen
\emph{out-of-place}, denn für die Funktionsschachteln auf dem
Aufrufestapel wird Speicherplatz benötigt. Manchmal bezeichnet man aber
auch solche Algorithmen mit einem Speicherverbrauch von
$\mathcal{O}(log(n))$ als in-place.

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\subsection{Laufzeitkomplexität}

 \cite[Seite 38]{aud:fs:tafeluebung-11}

\begin{itemize}

%%
%
%%

\item für die Laufzeitkomplexität unterscheidet man verschiedene Fälle:

\begin{itemize}
\item Best-Case
\item Average-Case
\item Worst-Case
\end{itemize}

%%
%
%%

\item adaptive Sortierverfahren:

\begin{itemize}
\item Laufzeit abhängig vom \emph{Grad der Vorsortierung}

$\rightarrow$ \emph{schneller}, wenn Eingabe schon \emph{„einigermaßen“
sortiert} ist

$\rightarrow$ Laufzeit in \emph{Best-Case} und \emph{Worst-Case}
\emph{unterschiedlich}

\end{itemize}

%%
%
%%

\item \emph{untere Schranken} für die Laufzeit (n: Anzahl an Elementen):

\begin{itemize}
\item vergleichsbasiertes Sortieren: nicht besser möglich als
$\mathcal{O}(log(n))$
\item nicht-vergleichsbasiertes Sortieren: lineare Laufzeit möglich
\end{itemize}

\end{itemize}

\literatur

\end{document}
