\documentclass{lehramt-informatik-haupt}
\liLadePakete{syntax}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Theorie-Teil
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{QuickSort: Sortieren durch Zerlegen}

\begin{liQuellen}
\item \cite[Seite 55]{aud:fs:tafeluebung-11}
\item \cite{wiki:quicksort}
\item \cite[Seite 135-139 (PDF 153-157)]{saake}
\end{liQuellen}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Funktionsweise}

Listen mit maximal \memph{einem} Element sind
\memph{trivialerweise sortiert}.
%
Falls die zu sortierende Liste mehr als ein Element beinhaltet wird ein
sogenanntes \memph{Pivot-Element} (vom Französischen \emph{pivot}
„\memph{Dreh-/Angelpunkt}“) ausgewählt.
%
Alle \memph{kleineren} Elemente werden \memph{vor} und alle
\memph{größeren} \memph{hinter} das Pivot-Element verschoben. Der
Algorithmus verfährt \memph{rekursiv} mit den beiden Teillisten.
%
Der Algorithmus arbeitet nach dem \memph{Teile-Und-Herrsche-Prinzip}.

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Eigenschaften}

\begin{itemize}
\item Laufzeitkomplexität:

\begin{itemize}
\item $\mathcal{O}(n \cdot log(n))$ (im Best-/Average-Case)
\item $\mathcal{O}(n^2)$ (im Worst-Case)
\end{itemize}

\item in „klassischer“ Variante \emph{instabil}
\item durch Rekursion wachsender Aufrufstapel
$\rightarrow$ out-of-place
\end{itemize}

\newpage

\section{Implementation nach Saake (Pivot-Element rechts)\footcite[Seite 138 (PDF 156)]{saake}}

\liJavaDatei[firstline=14,lastline=47]{sortier/QuickSort}

\newpage

\section{Weitere Implementation (Pivot-Element in  der Mitte)}

\liJavaDatei[firstline=15,lastline=50]{sortier/QuickSortMitte}

\literatur

\end{document}
