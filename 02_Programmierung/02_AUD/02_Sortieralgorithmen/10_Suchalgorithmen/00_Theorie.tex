\documentclass{lehramt-informatik-haupt}
\liLadePakete{syntax}
\usepackage{multicol}
\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Theorie-Teil
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Suchalgorithmen}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Suchen Allgemein}

Eine der wichtigsten und häufigsten Aufgaben in der Informatik ist das
Suchen.
%
Die Suche in unsortierter Datenmenge ist langwierig. Es gibt keine
Möglichkeit, das ideal zu gestalten.
%
Das Suchen in sortierten Daten ist sinnvoll, denn es kann optimiert
werden.

\subsection{Möglichkeiten:}

\begin{description}
\item[Sequenzielle Suche:] Es wird eine Folge vom ersten Element an
durchlaufen. Die Suche ist beendet, wenn das gesuchte Element gefunden
ist oder die gesamte Folge ohne Ergebnis durchlaufen wurde.

\item[Binäre Suche:] Wir „verkleinern“ die zu durchsuchenden Menge durch
Herausgreifen eines Elements aus der Folge und vergleichen, ob mein
gesuchtes Element vor oder nach diesem Element in der Folge liegt. Es
muss nur noch eine Hälfte durchsucht werden. In dieser fahren wir analog
fort.
\end{description}

Ein Bewertungskriterium für das Suchverfahren ist der
Berechnungsaufwand. Wie viele Schritte sind durchschnittlich nötig, um
eine Folge zu durchlaufen?\footcite[Seite 16 (PDF 8)]{aud:fs:2}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Binäre Suche}

Die binäre Suche ist ein Algorithmus, der auf einem Feld (also meist „in
einer Liste“) sehr effizient ein gesuchtes Element findet bzw. eine
zuverlässige Aussage über das Fehlen dieses Elementes liefert.
Voraussetzung ist, dass die Elemente in dem Feld \emph{sortiert} sind.
Der Algorithmus basiert auf einer einfachen Form des Schemas \emph{Teile
und Herrsche}, zugleich stellt er auch einen \emph{Greedy-Algorithmus}
dar. Ordnung und spätere Suche müssen sich auf denselben Schlüssel
beziehen.
\footcite{wiki:binaere-suche}

\cite[Seite 17 (PDF 9)]{aud:fs:2}

\section{Iterativer Ansatz}

\begin{minted}{java}
public int binsearch(int[] a, int lo, int hi, int x){
  while (lo <= hi) {
    int m = lo + (hi - lo) / 2;
    if (x < a[m]){
      hi = m - 1;
    } else if (x > a[m]) {
      lo = m + 1;
    } else {
      return m;
    }
  }
  return -1;
}
\end{minted}

\section{Rekursiver Ansatz}

\begin{minted}{java}
public int binsearch(int[] a, int lo, int hi, int x){
  if (lo > hi){
    return -1;
  }
  int m = lo + (hi - lo) / 2;
  if (x < a[m]) {
    return binsearch(a, lo, m - 1, x);
  }
  if (x > a[m]) {
    return binsearch(a, m + 1, hi, x);
  }
  return m;
}
\end{minted}

\literatur

\end{document}
