\documentclass{lehramt-informatik-haupt}
\liLadePakete{syntax}
\usepackage{multicol}
\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Theorie-Teil
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Suchalgorithmen}

\begin{liQuellen}
\item \cite[Seite 120-123]{saake}
\end{liQuellen}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Suchen Allgemein}

Eine der wichtigsten und häufigsten Aufgaben in der Informatik ist das
Suchen.
%
Die Suche in unsortierter Datenmenge ist langwierig. Es gibt keine
Möglichkeit, das ideal zu gestalten.
%
Das Suchen in sortierten Daten ist sinnvoll, denn es kann optimiert
werden.

\subsection{Möglichkeiten:}

\begin{description}
\item[Sequenzielle Suche:] Es wird eine Folge vom ersten Element an
durchlaufen. Die Suche ist beendet, wenn das gesuchte Element gefunden
ist oder die gesamte Folge ohne Ergebnis durchlaufen wurde.

\item[Binäre Suche:] Wir „verkleinern“ die zu durchsuchenden Menge durch
Herausgreifen eines Elements aus der Folge und vergleichen, ob mein
gesuchtes Element vor oder nach diesem Element in der Folge liegt. Es
muss nur noch eine Hälfte durchsucht werden. In dieser fahren wir analog
fort.
\end{description}

Ein Bewertungskriterium für das Suchverfahren ist der
Berechnungsaufwand. Wie viele Schritte sind durchschnittlich nötig, um
eine Folge zu durchlaufen?\footcite[Seite 16 (PDF 8)]{aud:fs:2}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Binäre Suche}

Die binäre Suche ist ein Algorithmus, der auf einem Feld (also meist „in
einer Liste“) sehr effizient ein gesuchtes Element findet bzw. eine
zuverlässige Aussage über das Fehlen dieses Elementes liefert.
Voraussetzung ist, dass die Elemente in dem Feld \emph{sortiert} sind.
Der Algorithmus basiert auf einer einfachen Form des Schemas \emph{Teile
und Herrsche}, zugleich stellt er auch einen \emph{Greedy-Algorithmus}
dar. Ordnung und spätere Suche müssen sich auf denselben Schlüssel
beziehen.
\footcite{wiki:binaere-suche}

\cite[Seite 17 (PDF 9)]{aud:fs:2}

\section{Iterativer Ansatz}

\liJavaDatei[firstline=7,lastline=22]{suche/BinaereSuche}

\section{Rekursiver Ansatz}

\liJavaDatei[firstline=24,lastline=40]{suche/BinaereSuche}

\section{Komplexität}

Im schlechtesten Fall muss nicht die gesamte Folge durchsucht werden.
Nach dem ersten Teilen der Folge bleiben nur noch $\frac{n}{2}$
Elemente, nach dem zweiten Schritt $\frac{n}{4}$, nach dem dritten
$\frac{n}{8}$ usw. Allgemein bedeutet dies, dass im $i$-ten Durchlauf
maximal $\frac{n}{2^i}$ Elemente zu durchsuchen sind. Entsprechend
werden $\log_2 n$ Schritte benötigt.
\footcite[Seite 122]{saake}

\literatur

\end{document}
