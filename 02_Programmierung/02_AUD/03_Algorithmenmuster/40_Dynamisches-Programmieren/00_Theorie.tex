\documentclass{lehramt-informatik-haupt}
\liLadePakete{syntax,mathe}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Theorie-Teil
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Dynamische Programmierung}

\begin{liQuellen}
\item \cite[Seite 10-12]{aud:fs:3}
\item \cite[Seite 230-235 (PDF 248-253)]{saake}
\item \cite{wiki:dynamische-programmierung}
\end{liQuellen}

\noindent
Dynamische Programmierung ist eine Methode zum algorithmischen Lösen
eines Optimierungsproblems durch \memph{Aufteilung in Teilprobleme} und
\memph{systematische Speicherung} von Zwischenresultaten.
\footcite{wiki:dynamische-programmierung}
Dynamische Programmierung vereint Aspekte der drei bisher vorgestellten
Algorithmenmuster. Vom Ansatz der Greedy-Algorithmen wird die Wahl
optimaler Teillösungen übernommen, von Divide-and-conquer und
Backtracking die rekursive Herangehensweise basierend auf einem
Konfigurationsbaum. Während Divide-and-conquer-Verfahren unabhängige
Teilprobleme durch rekursive Aufrufe lösen, werden bei der dynamischen
Programmierung abhängige Teilprobleme optimiert gelöst, indem mehrfach
auftretende Teilprobleme nur einmal gelöst werden.
\footcite[Seite 230 (PDF 248)]{saake}
Als Vorteil der dynamischen Programmierung kann eine \memph{Verbesserung
der Laufzeit-Effizienz} genannt werden. Es wird jedoch mehr
\memph{Speicherplatz} benötigt.
\footcite{aud:fs:3}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Das Rucksack-Problem\footcite[Seite 231-235]{saake}}

\liJavaDatei{muster/rucksack/Rucksack}

\literatur

\end{document}
