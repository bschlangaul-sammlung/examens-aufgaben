\documentclass{lehramt-informatik-haupt}
\liLadePakete{mathe,syntax}
\usepackage{paralist}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Theorie-Teil
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Rekursion}

\begin{liQuellen}
\item \cite[Seite 27-30]{saake}
\item \cite[Seite 178 6.1.2.5]{schneider}
\item \cite{wiki:rekursive-programmierung}
\end{liQuellen}

\noindent
Bei der \emph{rekursiven Programmierung} ruft sich eine
\memph{Prozedur}, \memph{Funktion} oder \memph{Methode} in einem
Computerprogramm \memph{selbst wieder auf} (d. h. enthält eine
Rekursion). Auch der gegenseitige Aufruf stellt eine Rekursion dar.

Wichtig bei der rekursiven Programmierung ist eine
\memph{Abbruchbedingung} in dieser Funktion, weil sich das rekursive
Programm sonst (theoretisch) unendlich oft selbst aufrufen würde.
\footcite{wiki:rekursive-programmierung}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Ein Beispiel: Das Begrüßungsproblem\footcite[Seite 12-14]{aud:fs:1}}

\begin{minted}{java}
int anzahlBegruessungen(int anzahlPersonen) {
  if (anzahlPersonen < 2) {
    return 0;
  } else {
    return anzahlBegruessungen(anzahlPersonen - 1) + (anzahlPersonen - 1);
  }
}
\end{minted}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Typen von Rekursion\footcite{net:html:gehaxelt:rekursionsarten}}

\begin{itemize}
\item \textbf{Indirekte Rekursion}

Bei der indirekten Rekursion ruft die Funktion eine andere Funktion auf,
welche wiederum die aufrufende Funktion aufruft.

\item \textbf{Direkte Rekursion}

Bei der direkten Rekursion ruft sich eine Funktion wieder selbst auf.

\begin{itemize}

%%
%
%%

\item \textbf{Repetitive Rekursion}

Bei der repetitiven Rekursion ruft sich die Funktion mit einem
\emph{veränderten Parameter} auf:

\begin{minted}{java}
public int f(int x, int y) {
  if (x == 0) return y
  y = y + x
  return func(x - 1, y)
}
\end{minted}

%%
%
%%

\item \textbf{Lineare Rekursion}

Bei der linearen Rekursion wird der \emph{übergebene Parameter} mit dem
Rekursion\emph{sergebnis verrechnet}:

\begin{minted}{java}
public int f(int x) {
  if (x == 0) return 1
  return x * f(x - 1)
}
\end{minted}

%%
%
%%

\item \textbf{Baumartige Rekursion}

Die baumartige Rekursion kommt zum Einsatz, wenn man das Ergebnis aus
\emph{zwei verschiedenen Rekursionsaufrufen} berechnet.

\begin{minted}{java}
public int f(int x) {
  if (x == 1) return 0
  return f(x - 1) + f(x - 2)
}
\end{minted}

%%
%
%%

\item \textbf{Geschachtelte Rekursion}

Bei der geschachtelten Rekursion ist das \emph{Ergebnis} des
Rekursionsaufrufes \emph{Parameter eines Rekursionsaufrufes}.

\begin{minted}{java}
public int f(int x) {
  if (x == 1) return 0
  return f(x - f(x-1))
}
\end{minted}

%%
%
%%

\item \textbf{Verschränkte Rekursion}

Bei der verschränkten Rekursion \emph{rufen} sich \emph{zwei Funktionen
gegenseitig} auf.

\begin{minted}{java}
public int f(int x) {
  if (x == 0) return 1
  return g(x - 1)
}

public int g(int x) {
  if (x == 1) return 0
  return f(x - 1)
}
\end{minted}
\end{itemize}
\end{itemize}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Iterativ vs. Rekursiv}

\cite[Seite 16-19 (Gedruckte Seitenzahlen stimmen nicht)]{aud:fs:1}

Interativ

\begin{minted}{java}
public static void pizzaIterativ (int anzahlStuecke){
  for (int i = 1; i< anzahlStuecke; i++) {
    schneiden();
  }
  essen();
}
\end{minted}

Rekursiv

\begin{minted}{java}
public static pizzaRekursiv (int anzahlStuecke)
  if (anzahlStuecke == 1) {
    essen();
  } else {
    schneiden();
    pizzaRekursiv(anzahlStuecke - 1);
  }
}
\end{minted}

\literatur

\end{document}
