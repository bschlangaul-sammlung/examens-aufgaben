\documentclass{lehramt-informatik-haupt}
\liLadePakete{graph,syntax,pseudo}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Theorie-Teil
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Tiefensuche, Breitensuche}

\section{Tiefesuche}

\begin{liQuellen}
\item \cite[Seite 39-52 (PDF 32-45)]{aud:fs:6}
\item \cite{wiki:tiefensuche}
\item \cite[Kapitel 6.2.2.2 Graphalgorithmen, Seite 185]{schneider}
\end{liQuellen}

Die Tiefensuche (englisch \memph{depth-first search}, \memph{DFS}) ist
in der Informatik ein Verfahren zum Suchen von Knoten in einem Graphen.

Der Tiefendurchlauf ist das Standardverfahren zum Durchlaufen eines
Graphen bei dem \memph{jeder Knoten mindestens einmal} und \memph{jede
Kante genau einmal} besucht wird. Man geht vom jeweiligen Knoten
\memph{erst zu einem nicht besuchten Nachbarknoten} und setzt den
Algorithmus dort \memph{rekursiv} fort. Bei schon besuchten Knoten wird
abgebrochen. Als Hilfsstruktur wird ein \memph{Stack} (Stapelspeicher,
Keller) verwendet. Der konkrete Durchlauf hängt von der Reihenfolge der
Knoten in den Adjazenzlisten bzw. in der Adjazenzmatrix ab.
\footcite[Seite 40]{aud:fs:6}

\begin{liGraphenFormat}
A: 1 5
B: 0 4
C: 0 2
D: 1 0
E: 2 2
F: 3 1
G: 6 2
H: 5 3
I: 4 5
J: 5 5
K: 6 4
L: 7 3
M: 8 0
A -- B
A -- C
A -- E
B -- C
C -- E
C -- I
D -- E
D -- F
F -- G
F -- H
F -- I
F -- M
I -- J
L -- K
M -- L
\end{liGraphenFormat}

\begin{center}
\begin{tikzpicture}[li graph]
\node (A) at (1,5) {A};
\node (B) at (0,4) {B};
\node (C) at (0,2) {C};
\node (D) at (1,0) {D};
\node (E) at (2,2) {E};
\node (F) at (3,1) {F};
\node (G) at (6,2) {G};
\node (H) at (5,3) {H};
\node (I) at (4,5) {I};
\node (J) at (5,5) {J};
\node (K) at (6,4) {K};
\node (L) at (7,3) {L};
\node (M) at (8,0) {M};

\path (A) edge node {} (B);
\path (A) edge node {} (C);
\path (A) edge node {} (E);
\path (B) edge node {} (C);
\path (C) edge node {} (E);
\path (C) edge node {} (I);
\path (D) edge node {} (E);
\path (D) edge node {} (F);
\path (F) edge node {} (G);
\path (F) edge node {} (H);
\path (F) edge node {} (I);
\path (F) edge node {} (M);
\path (I) edge node {} (J);
\path (L) edge node {} (K);
\path (M) edge node {} (L);
\end{tikzpicture}
\end{center}

\begin{verbatim}
      add A [A]
del A       []
      add B [B]
      add C [C, B]
      add E [E, C, B]
del E       [C, B]
      add D [D, C, B]
del D       [C, B]
      add F [F, C, B]
del F       [C, B]
      add G [G, C, B]
      add H [H, G, C, B]
      add I [I, H, G, C, B]
      add M [M, I, H, G, C, B]
del M       [I, H, G, C, B]
      add L [L, I, H, G, C, B]
del L       [I, H, G, C, B]
      add K [K, I, H, G, C, B]
del K       [I, H, G, C, B]
del I       [H, G, C, B]
      add J [J, H, G, C, B]
del J       [H, G, C, B]
del H       [G, C, B]
del G       [C, B]
del C       [B]
del B       []
\end{verbatim}

\subsection{Implementierung der Tiefensuche}

\begin{itemize}
\item Eine Möglichkeit, abzuspeichern, welche Knoten bereits besucht
wurden $\rightarrow$ Boolean-Array

\item Eine Methode, die für uns diese Markierung der Knoten als besucht
übernimmt (und somit die eigentliche Tiefensuche durchführt)
$\rightarrow$  Knoten als besucht eintragen, existierende Nachbarknoten
suchen und prüfen, ob diese bereits besucht wurden, falls nicht: diese
durch rekursiven Aufruf besuchen

\item Eine Methode, um die Tiefensuche zu starten $\rightarrow$  Wenn
ein übergebnisener Startknoten existiert, dann müssen erst alle Knoten
als nicht besucht markiert werden und dann vom Startknoten aus das
Besuchen der Knoten gestartet werden
\end{itemize}
\footcite[Seite 45]{aud:fs:6}

\section{Pseudocode: Tiefensuche mit explizitem Stack\footcite[Seite 51 (PDF 45)]{aud:fs:6}}

\begin{algorithm}[H]
\KwData{$G$: Graph, $k$: Startknoten in $G$}
  $S$ := leerer Stack\;
  lege $k$ oben auf $S$\;
  markiere $k$\;
\While{$S$ nicht leer ist}{
  $a$ := entferne oberstes Element von $S$\;
  bearbeite Knoten $a$\;
    \For{alle Nachfolger $n$ von $a$}{
    \If{$n$ noch nicht markiert}{
      lege $n$ oben auf $S$\;
      markiere $n$\;
    }
  }
}
\caption{Tiefensuche mit explizitem Stack}
\end{algorithm}

\liJavaDatei{graph/algorithmen/TiefenSucheStapel}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Breitensuche}

\begin{liQuellen}
\item \cite[Seite 53-64 (PDF 46-57)]{aud:fs:6}
\item \cite[Kapitel 6.2.2.2 Graphalgorithmen, Seite 185]{schneider}
\item \cite{wiki:breitensuche}
\end{liQuellen}

Der Breitendurchlauf (englisch \memph{breadth-first search},
\memph{BFS})\footcite{wiki:breitensuche} ist Verfahren zum Durchlaufen
eines Graphen bei dem jeder Knoten genau einmal besucht wird. Man geht
von einem Knoten \memph{erst zu allen Nachbarknoten} \memph{bevor deren
Nachbarn} besucht werden. Bei schon besuchten Knoten wird abgebrochen.
Als Hilfsstruktur wird eine \memph{Queue (Warteschlange)} verwendet.

Der konkrete Durchlauf hängt von der Reihenfolge der Knoten in den
Adjazenzlisten ab.

\begin{center}
\begin{tikzpicture}[li graph]
\node (A) at (1,5) {A};
\node (B) at (0,4) {B};
\node (C) at (0,2) {C};
\node (D) at (1,0) {D};
\node (E) at (2,2) {E};
\node (F) at (3,1) {F};
\node (G) at (6,2) {G};
\node (H) at (5,3) {H};
\node (I) at (4,5) {I};
\node (J) at (5,5) {J};
\node (K) at (6,4) {K};
\node (L) at (7,3) {L};
\node (M) at (8,0) {M};

\path (A) edge node {} (B);
\path (A) edge node {} (C);
\path (A) edge node {} (E);
\path (B) edge node {} (C);
\path (C) edge node {} (E);
\path (C) edge node {} (I);
\path (D) edge node {} (E);
\path (D) edge node {} (F);
\path (F) edge node {} (G);
\path (F) edge node {} (H);
\path (F) edge node {} (I);
\path (F) edge node {} (M);
\path (I) edge node {} (J);
\path (L) edge node {} (K);
\path (M) edge node {} (L);
\end{tikzpicture}
\end{center}

\begin{verbatim}
      add A [A]
del A       []
      add B [B]
      add C [B, C]
      add E [B, C, E]
del B       [C, E]
del C       [E]
      add I [E, I]
del E       [I]
      add D [I, D]
del I       [D]
      add F [D, F]
      add J [D, F, J]
del D       [F, J]
del F       [J]
      add G [J, G]
      add H [J, G, H]
      add M [J, G, H, M]
del J       [G, H, M]
del G       [H, M]
del H       [M]
del M       []
      add L [L]
del L       []
      add K [K]
del K       []
\end{verbatim}

\section{Pseudocode Breitensuche mit Queue
\footcite[Seite 64]{aud:fs:6}}

\begin{algorithm}[H]
\KwData{$G$: Graph, $k$: Startknoten in $G$}
  $Q$ := leerer Queue\;
  füge $k$ in $Q$\;
  markiere $k$\;
\While{$Q$ nicht leer}{
  $a$ := entferne vorderstes Element aus $Q$\;
  bearbeite Knoten $a$\;
  \For{alle Nachfolger $n$ von $a$}{
    \If{$n$ noch nicht markiert}{
      füge $n$ hinten in $Q$\;
      markiere $n$\;
    }
  }
}
\caption{Breitensuche mit Queue}
\end{algorithm}

\liJavaDatei{graph/algorithmen/BreitenSucheWarteschlange}

\literatur

\end{document}
