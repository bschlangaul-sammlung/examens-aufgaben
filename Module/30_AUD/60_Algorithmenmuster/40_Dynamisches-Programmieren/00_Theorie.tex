\documentclass{bschlangaul-theorie}
\liLadePakete{syntax,mathe}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Theorie-Teil
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Dynamische Programmierung}

\begin{liQuellen}
\item \cite[Seite 10-12]{aud:fs:3}
\item \cite[Seite 230-235 (PDF 248-253)]{saake}
\item \cite{wiki:dynamische-programmierung}
\end{liQuellen}

\noindent
Dynamische Programmierung ist eine Methode zum algorithmischen Lösen
eines Optimierungsproblems durch \memph{Aufteilung in Teilprobleme} und
\memph{systematische Speicherung} von Zwischenresultaten.
\footcite{wiki:dynamische-programmierung}

Dynamische Programmierung \memph{vereint Aspekte} der drei bisher
vorgestellten \memph{Algorithmenmuster}. Vom Ansatz der
\memph{Greedy}-Algorithmen wird die \memph{Wahl optimaler Teillösungen}
übernommen, von \memph{Divide-and-conquer} und \memph{Backtracking} die
\memph{rekursive Herangehensweise} basierend auf einem
Konfigurationsbaum. Während Divide-and-conquer-Verfahren unabhängige
Teilprobleme durch rekursive Aufrufe lösen, werden bei der dynamischen
Programmierung abhängige Teilprobleme optimiert gelöst, indem mehrfach
auftretende Teilprobleme nur einmal gelöst werden.
\footcite[Seite 230 (PDF 248)]{saake}

Als Vorteil der dynamischen Programmierung kann eine \memph{Verbesserung
der Laufzeit-Effizienz} genannt werden. Es wird jedoch mehr
\memph{Speicherplatz} benötigt.
\footcite{aud:fs:3}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Das Rucksack-Problem\footcite[Seite 231-235]{saake}}

\liJavaDatei{muster/rucksack/Rucksack}

\literatur

\end{document}
