\documentclass{bschlangaul-theorie}
\bLadePakete{syntax,uml,mathe,tabelle}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Theorie-Teil
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Listen}

\begin{bQuellen}
\cite[Kapitel 6.2.1.2, Seite 180-181]{schneider}
\cite[Kapitel 13.2 Verkettete Listen Seite 323-330 (PDF 339-346)]{saake}
\cite[Kapitel 13.3 Doppelt verkette Liste, Seite 323-330 (PDF 339-346)]{saake}

\end{bQuellen}

Eine Liste ist eine Zusammenfassung von Daten gleicher Struktur. Listen
sind aus mehreren Elementen aufgebaut. Listen sind eine \bEmph{rekursive
Datenstruktur}. Rekursive Datenstrukturen sind \bEmph{dynamisch}, da zur
Laufzeit \bEmph{neue Elemente} erzeugt und \bEmph{hinzugefügt} werden
können.

Jedes Element enthält einen Inhalt (beliebiger Datentyp). Jedes Element
einer Liste beinhaltet zudem einen \bEmph{Verweis} auf das
\bEmph{nächste Listenelement} (Zeiger), also auf ein Objekt derselben
Klasse. Diese Struktur nennt man rekursiv.

\section{Rekursive Definition}

Eine Liste ist entweder eine \bEmph{leere Liste} oder besteht aus
\bEmph{Kopfelement und Restliste}. Der Zeiger des letzten Elements zeigt
auf \bEmph{NIL(Not In List)}

\section{Operationen:}

\begin{compactitem}
\item Einfügen eines Elements (Aufbau)
\item Entfernen eines Elements (Abbau)
\item Suchen eines Elements
\end{compactitem}

\section{Liste vs. Array}

Beim Array muss bei der Deklaration die Länge angegeben werden, diese
ist unveränderlich, die Liste wächst hingegen dynamisch. Beim Array
ist der direkte Zugriff auf die Einzelelemente möglich, durch die Liste
muss iteriert werden.
\footcite[Seite 4]{aud:fs:4}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Löschen eines inneren Listenelements}

Vom Vorgängerelement muss der Zeiger „nächstes Element“auf das
Folgeelement gesetzt werden. Das zu löschende Element wird später vom
Garbage Collector aufgeräumt.
\footcite[Seite 9-10]{aud:fs:4}

\begin{minted}{java}
while (element.next_element != NULL) { // Ende der Liste?
  if (element.next_element.wert != a) // Zu löschen?
    element = element.next_element; // Nein? Weitersuchen!
  else
    element.next_element=element.next_element.next_element; // Ja? Next-Zeiger anpassen!
}
\end{minted}

\section{Einfügen eines Listenelements}

Vom neuen Element muss der Zeiger „nächstes Element“ auf das
„Nachfolgeelement“ gesetzt werden. Vom „Vorgängerelement“ muss der
Zeiger „nächstes Element“auf das neue Element gesetzt werden.
\footcite[Seite 11-12]{aud:fs:4}

\begin{minted}{java}
if (element.next_element.wert < a) // Einfügestelle erreicht?
  element = element.next_element; // Nein? Weitersuchen!
else {
  new_element.next_element = element.next_element; // Ja? Einfügen!
  element.next_element = new_element;
}
\end{minted}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Listen im Vergleich}

\begin{tabularx}{\linewidth}{|l|X|X|}

\hline
%%
%
%%

\textbf{Merkmal} & \textbf{Liste} & \textbf{Array}
\\
\hline\hline

%%
%
%%

\textbf{Speicherverhalten} &

Speicherung einer variablen Anzahl verketteter Elemente. Listengröße
während des Programmablaufs änderbar &

Speicherung einer festen Anzahl zusammengehörender Element. Arraygröße
während des Programmablaufs nicht änderbar.

\\
\hline

%%
%
%%

\textbf{Zugriffszeit} &

Jedes Element muss nacheinander durchlaufen werden $\rightarrow$ langsam
&

Jedes Element ist durch einen Index direkt abrufbar $\rightarrow$
schnell

\\
\hline

%%
%
%%

\textbf{Datensortierung} &

Unkompliziert duch Änderung der Verkettung $\rightarrow$
Daten bleiben an ihrem Speicherort &

Kompliziert durch Datenaustausch $\rightarrow$
Speicherort der Daten ändert sich

\\
\hline

\textbf{Wahlfreier Zugriff} &

wahlfreier Zugriff über den Index &

keine wahlfreier Zugriff, sondern \emph{sequential access}, je länger
die Liste, umso länger dauert der Zugriff (im \emph{average} und
\emph{worst case})

\end{tabularx}
\footcite[Seite 8]{aud:fs:4}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Didaktisch aufbereitetes einfaches Beispiel einer Liste}

\bJavaDatei{liste/einfach/Element}
\bJavaDatei{liste/einfach/Liste}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Einfache Liste (nach Saake)}

\bJavaDatei{liste/LeereListeFehler}
\bJavaDatei{liste/Liste}
\bJavaDatei{liste/ListenKnoten}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Doppelt verkettete Liste (nach Saake)}

\bJavaDatei{liste/DoppeltVerketteteListe}

\end{document}
