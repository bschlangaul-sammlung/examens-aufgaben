\documentclass{bschlangaul-theorie}
\liLadePakete{syntax,mathe}
\usepackage{amsmath}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Theorie-Teil
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Hashing}

\begin{liQuellen}
\item \cite[Kapitel 6.3.3 Streutabellen (Hashing), Seite
188-189]{schneider}
\item \cite[Seite 22-39]{aud:fs:tafeluebung-10}
\item \cite[Seite 419-439]{saake}
\item \cite{wiki:hashtabelle}
\end{liQuellen}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Grundlagen}
Das Ziel von Hashing ist einerseits einen \memph{extrem großen
Schlüsselraum} auf einen vernünftig \memph{kleinen Bereich von ganzen
Zahlen} abzubilden und andererseits dass \memph{zwei Schlüssel auf die
selbe Zahl} abgebildet werden, soll möglichst \memph{unwahrscheinlich}
sein.\footnote{Seite 4
\url{https://moves.rwth-aachen.de/wp-content/uploads/SS15/dsal/lec13.pdf}}

Daten werden in einer \memph{Streu(wert)tabelle} (hash table) abgelegt.
Aufgrund des wahlfreien Zugriffs eignen sich Felder zum Abspeichern der
Daten.
%
Eine \memph{Hashfunktion} $h$ bildet ein Datenelement auf einen
\memph{Hashwert} ab. Das Datenelement benötigt dazu einen
\memph{Schlüssel} (key), der das Element eindeutig identifiziert. Der
Hashwert wird als Index in dem Feld verwendet. Das Datenelement wird
im entsprechenden \memph{Bucket} der Tabelle gespeichert.
%
Bei der \memph{Suche} nach einem Element mit \memph{bekanntem Schlüssel}
wird der Index mittels der Hashfunktion bestimmt. Dies geschieht mit
\memph{konstantem Aufwand}.
%
Der Aufwand des Nachschlagens an entsprechender Stelle ist abhängig von
der \emph{Organisationsform}.
\footcite[Seite 25]{aud:fs:tafeluebung-10}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Kollisionen}

Da Hashfunktionen im Allgemeinen \memph{nicht eindeutig (injektiv)}
sind, können zwei unterschiedliche Schlüssel zum selben Hash-Wert, also
zum selben Feld in der Tabelle, führen. Dieses Ereignis wird als
\memph{Kollision} bezeichnet. In diesem Fall muss die Hashtabelle
mehrere Werte in demselben Bucket aufnehmen.

Zur Behandlung von Kollisionen werden kollidierte Daten nach einer
\memph{Ausweichstrategie in alternativen Feldern} oder in einer
\memph{Liste} gespeichert. Schlimmstenfalls können Kollisionen zu einer
\memph{Entartung der Hashtabelle} führen, wenn wenige Hashwerte sehr
vielen Objekten zugewiesen wurden, während andere Hashwerte unbenutzt
bleiben.\footcite{wiki:hashtabelle}

Um das Kollisions-Problem zu handhaben, gibt es diverse
Kollisionsauflösungsstrategien.

%%
%
%%

\subsection{geschlossenes Hashing mit offener Adressierung}

Wenn dabei ein Eintrag an einer schon belegten Stelle in der
Tabelle abgelegt werden soll, wird stattdessen eine \memph{andere freie
Stelle genommen}. Häufig werden drei Varianten unterschieden:

\subsubsection{lineares Sondieren}

es wird um ein \memph{konstantes Intervall} verschoben nach einer freien
Stelle gesucht. Meistens wird die Intervallgröße auf 1 festgelegt.

\subsubsection{quadratisches Sondieren}

Nach jedem erfolglosen Suchschritt wird das \memph{Intervall quadriert}.

\subsubsection{doppeltes Hashen}

eine \memph{weitere Hash-Funktion} liefert das Intervall.

%%
%
%%

\subsection{offenes Hashing mit geschlossener Adressierung}

Anstelle der gesuchten Daten enthält die Hashtabelle hier
\memph{Behälter} (englisch \memph{Buckets}), die alle Daten mit gleichem
Hash-Wert aufnehmen. Es müssen die \memph{Elemente im Behälter
durchsucht werden}. Oft wird die Verkettung durch eine lineare Liste pro
Behälter realisiert.
\footcite{wiki:hashtabelle}

%-----------------------------------------------------------------------
%
%-----------------------------------------------------------------------

\section{Die Divisionsrestmethode\footcite{wiki:divisionsrestmethode}}

Die Divisionsrestmethode - auch Modulo genannt liefert eine
Hashfunktion. Die Funktion lautet:  $h(k)=k{\bmod {m}}$. $m$ ist die
Größe der Hashtabelle. Die Hash-Funktion kann sehr schnell berechnet
werden. Die Wahl der Tabellengröße $m$ beeinflusst die
Kollisionswahrscheinlichkeit der Funktionswerte von $h$. Für
praxisrelevante Anwendungen liefert die Wahl einer Primzahl für $m$.

\section{Belegungsfaktor\footcite[Seite 29]{aud:fs:tafeluebung-10}}

$\text{Belegungsfaktor} =
\frac{\text{Anzahl tatsächlich eingetragener Schlüssel}}
{\text{Anzahl Hashwerte}}$

\literatur

\end{document}
